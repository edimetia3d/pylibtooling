
// GENERATED AT 10/30/2023, 13:27:04

#include "clang/Tooling/ASTDiff/ASTDiff.h"
#include "clang/Tooling/ASTDiff/ASTDiffInternal.h"
#include "clang/Tooling/AllTUsExecution.h"
#include "clang/Tooling/ArgumentsAdjusters.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/CompilationDatabase.h"
#include "clang/Tooling/CompilationDatabasePluginRegistry.h"
#include "clang/Tooling/Core/Diagnostic.h"
#include "clang/Tooling/Core/Replacement.h"
#include "clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h"
#include "clang/Tooling/DependencyScanning/DependencyScanningService.h"
#include "clang/Tooling/DependencyScanning/DependencyScanningTool.h"
#include "clang/Tooling/DependencyScanning/DependencyScanningWorker.h"
#include "clang/Tooling/DependencyScanning/ModuleDepCollector.h"
#include "clang/Tooling/DiagnosticsYaml.h"
#include "clang/Tooling/Execution.h"
#include "clang/Tooling/FileMatchTrie.h"
#include "clang/Tooling/FixIt.h"
#include "clang/Tooling/Inclusions/HeaderAnalysis.h"
#include "clang/Tooling/Inclusions/HeaderIncludes.h"
#include "clang/Tooling/Inclusions/IncludeStyle.h"
#include "clang/Tooling/Inclusions/StandardLibrary.h"
#include "clang/Tooling/JSONCompilationDatabase.h"
#include "clang/Tooling/NodeIntrospection.h"
#include "clang/Tooling/Refactoring.h"
#include "clang/Tooling/Refactoring/ASTSelection.h"
#include "clang/Tooling/Refactoring/AtomicChange.h"
#include "clang/Tooling/Refactoring/Extract/Extract.h"
#include "clang/Tooling/Refactoring/Extract/SourceExtraction.h"
#include "clang/Tooling/Refactoring/Lookup.h"
#include "clang/Tooling/Refactoring/RecursiveSymbolVisitor.h"
#include "clang/Tooling/Refactoring/RefactoringAction.h"
#include "clang/Tooling/Refactoring/RefactoringActionRule.h"
#include "clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h"
#include "clang/Tooling/Refactoring/RefactoringActionRules.h"
#include "clang/Tooling/Refactoring/RefactoringActionRulesInternal.h"
#include "clang/Tooling/Refactoring/RefactoringDiagnostic.h"
#include "clang/Tooling/Refactoring/RefactoringOption.h"
#include "clang/Tooling/Refactoring/RefactoringOptionVisitor.h"
#include "clang/Tooling/Refactoring/RefactoringOptions.h"
#include "clang/Tooling/Refactoring/RefactoringResultConsumer.h"
#include "clang/Tooling/Refactoring/RefactoringRuleContext.h"
#include "clang/Tooling/Refactoring/Rename/RenamingAction.h"
#include "clang/Tooling/Refactoring/Rename/SymbolName.h"
#include "clang/Tooling/Refactoring/Rename/SymbolOccurrences.h"
#include "clang/Tooling/Refactoring/Rename/USRFinder.h"
#include "clang/Tooling/Refactoring/Rename/USRFindingAction.h"
#include "clang/Tooling/Refactoring/Rename/USRLocFinder.h"
#include "clang/Tooling/RefactoringCallbacks.h"
#include "clang/Tooling/ReplacementsYaml.h"
#include "clang/Tooling/StandaloneExecution.h"
#include "clang/Tooling/Syntax/BuildTree.h"
#include "clang/Tooling/Syntax/Mutations.h"
#include "clang/Tooling/Syntax/Nodes.h"
#include "clang/Tooling/Syntax/TokenBufferTokenManager.h"
#include "clang/Tooling/Syntax/TokenManager.h"
#include "clang/Tooling/Syntax/Tokens.h"
#include "clang/Tooling/Syntax/Tree.h"
#include "clang/Tooling/ToolExecutorPluginRegistry.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Tooling/Transformer/MatchConsumer.h"
#include "clang/Tooling/Transformer/Parsing.h"
#include "clang/Tooling/Transformer/RangeSelector.h"
#include "clang/Tooling/Transformer/RewriteRule.h"
#include "clang/Tooling/Transformer/SourceCode.h"
#include "clang/Tooling/Transformer/SourceCodeBuilders.h"
#include "clang/Tooling/Transformer/Stencil.h"
#include "clang/Tooling/Transformer/Transformer.h"

#ifndef GITHUB_COM_PYBIND11_WEAVER
#define GITHUB_COM_PYBIND11_WEAVER
#include <atomic>
#include <functional>
#include <map>
#include <mutex>
#include <thread>
#include <utility>

#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace pybind11_weaver {

template <class BindT, class PB11T> void TryAddDefaultCtor(PB11T &handle) {
  if constexpr (std::is_default_constructible<BindT>::value) {
    handle.def(pybind11::init<>());
  }
}

template <class ClassT, class MethodRetT, class... MethodArgs> struct FnPtrT {
  using type = MethodRetT (ClassT::*)(MethodArgs...);
  using const_type = MethodRetT (ClassT::*)(MethodArgs...) const;
  using const_rref_type = MethodRetT (ClassT::*)(MethodArgs...) const &&;
  using const_lref_type = MethodRetT (ClassT::*)(MethodArgs...) const &;
  using rref_type = MethodRetT (ClassT::*)(MethodArgs...) &&;
  using lref_type = MethodRetT (ClassT::*)(MethodArgs...) &;
};
template <class FnTtype> struct FnPtrT<void, FnTtype> {
  using type = FnTtype *;
};

struct _PointerWrapperBase {
  _PointerWrapperBase(void *ptr_) : ptr(ptr_) {}
  _PointerWrapperBase(intptr_t ptr_v) : ptr(reinterpret_cast<void *>(ptr_v)) {}
  intptr_t get_ptr() { return reinterpret_cast<intptr_t>(ptr); }
  void set_ptr(intptr_t ptr_v) { ptr = reinterpret_cast<void *>(ptr_v); }
  static void FastBind(pybind11::module &m) {
    pybind11::class_<_PointerWrapperBase, std::shared_ptr<_PointerWrapperBase>>(
        m, "_PointerWrapperBase", pybind11::dynamic_attr())
        .def(pybind11::init<void *>())
        .def(pybind11::init<intptr_t>())
        .def("get_ptr", &_PointerWrapperBase::get_ptr)
        .def("set_ptr", &_PointerWrapperBase::set_ptr);
  }
  void *ptr;
};

template <class T> struct PointerWrapper : public _PointerWrapperBase {
  static_assert(std::is_pointer<T>::value, "T must be a pointer type");
  using _PointerWrapperBase::_PointerWrapperBase;

  static void FastBind(pybind11::module &m, const std::string &name) {
    pybind11::class_<PointerWrapper, std::shared_ptr<PointerWrapper>,
                     _PointerWrapperBase>(m, name.c_str(),
                                          pybind11::dynamic_attr())
        .def(pybind11::init<intptr_t>())
        .def_static("from_capsule", [](pybind11::capsule o) {
          return std::make_shared<PointerWrapper<T>>(
              reinterpret_cast<void *>(o.get_pointer()));
        });
  }
  T Cptr() { return reinterpret_cast<T>(ptr); }
};
template <class T> using WrappedPtrT = std::shared_ptr<PointerWrapper<T>>;

template <class T> WrappedPtrT<T> WrapP(T ptr) {
  if (!ptr) {
    return nullptr;
  }
  return WrappedPtrT<T>{new PointerWrapper<T>((void *)ptr)};
}

struct Guardian {
  std::vector<std::function<void()>> dtor_callbacks;
  ~Guardian() {
    for (auto &fn : dtor_callbacks) {
      fn();
    }
  }
};

template <typename R, typename... Args> struct FnPointerWrapper {
  using CppFnT = R(Args...);

  template <class CR, typename... CArgs> struct GetCptr {
    using CFnPtrT = CR (*)(CArgs...);
    static CFnPtrT Run(std::function<CppFnT> to_call, Guardian &&guard,
                       CFnPtrT c_wrapper, const char *uuid0, int64_t uuid1) {
      // lock
      guard.dtor_callbacks.push_back(
          [uuid0, uuid1]() { ReleaseFnProxy(uuid0, uuid1); });
      SetFnProxy(uuid0, uuid1, to_call);
      return c_wrapper;
    }
  };

  using FnMapT =
      std::map<const char *, std::map<int64_t, std::function<CppFnT>>>;
  static void SetFnProxy(const char *uuid0, int64_t uuid1,
                         std::function<CppFnT> &fn) {
    FnMapMutex().lock();
    while (FnMap()[uuid0].count(uuid1) != 0) {
      // The chance is so low, spin lock should be fine
      FnMapMutex().unlock();
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      FnMapMutex().lock();
    }
    FnMap()[uuid0][uuid1] = fn;
    FnMapMutex().unlock();
  }

  static std::function<CppFnT> GetFnProxy(const char *uuid0, int64_t uuid1) {
    std::lock_guard<std::mutex> _(FnMapMutex());
    auto ret = FnMap()[uuid0][uuid1];
    return ret;
  }

  static void ReleaseFnProxy(const char *uuid0, int64_t uuid1) {
    std::lock_guard<std::mutex> _(FnMapMutex());
    FnMap()[uuid0].erase(uuid1);
  }
  static FnMapT &FnMap() {
    static FnMapT fns;
    return fns;
  }

  static std::mutex &FnMapMutex() {
    static std::mutex m;
    return m;
  }
};

class CallUpdateGuard {
public:
  using Fn = std::function<void(void)>;
  CallUpdateGuard(Fn fn) : fn_(fn) {}

  CallUpdateGuard(CallUpdateGuard &&rhs) {
    this->fn_ = rhs.fn_;
    rhs.fn_ = nullptr;
  }

  void operator()() {
    if (fn_) {
      fn_();
      fn_ = nullptr;
    }
  }

  ~CallUpdateGuard() { this->operator()(); }

private:
  Fn fn_;
};

struct EntityScope {
  explicit EntityScope(int64_t, int64_t) {} // a tag for disabled scope
  explicit EntityScope(pybind11::module_ &parent_h) : module_{&parent_h} {}
  explicit EntityScope(pybind11::detail::generic_type &parent_h)
      : type_{&parent_h} {}
  explicit operator pybind11::module_ &() { return *module_; }
  explicit operator pybind11::detail::generic_type &() { return *type_; }
  operator pybind11::handle &() {
    if (module_) {
      return *module_;
    } else {
      return *type_;
    }
  }
  bool IsDisabled() const { return module_ == nullptr && type_ == nullptr; }

private:
  pybind11::detail::generic_type *type_ = nullptr;
  pybind11::module_ *module_ = nullptr;
};

struct EntityBase {
  virtual ~EntityBase() = default;

  virtual void Update() = 0;

  virtual EntityScope AsScope() = 0;
};

struct DisabledEntity : public EntityBase {
  void Update() override {}
  EntityScope AsScope() override { return EntityScope{0, 0}; }
};

struct CustomBindingRegistry {
  using CTorT = std::function<std::shared_ptr<EntityBase>(EntityScope &&)>;
  using RegistryT = std::map<std::string, CTorT>;

  bool contains(const std::string &key) const {
    return registry_.count(key) > 0;
  }
  CTorT at(const std::string &key) const { return registry_.at(key); }

  template <class BindingT> void DisableBinding() {
    auto key = std::string(BindingT::Key());
    registry_.emplace(
        key, [](EntityScope &&) { return std::make_shared<DisabledEntity>(); });
  }

  void RegCustomBinding(const std::string &key, CTorT &&ctor) {
    registry_.emplace(key, std::move(ctor));
  }

  template <class BindingT> void SetCustomBinding() {
    auto key = std::string(BindingT::Key());
    registry_.emplace(key, [](EntityScope &&parent_h) {
      return std::make_shared<BindingT>(std::move(parent_h));
    });
  }

private:
  RegistryT registry_;
};

template <class EntityT>
std::shared_ptr<EntityBase>
CreateEntity(EntityScope &&parent_h, const CustomBindingRegistry &registry) {
  if (parent_h.IsDisabled()) {
    return std::make_shared<DisabledEntity>();
  }
  auto key = std::string(EntityT::Key());
  if (!registry.contains(key)) {
    return std::make_shared<EntityT>(std::move(parent_h));
  } else {
    auto fn = registry.at(key);
    return fn(std::move(parent_h));
  }
}

} // namespace pybind11_weaver
#endif // GITHUB_COM_PYBIND11_WEAVER

namespace {

using pybind11_weaver::EntityBase;
using pybind11_weaver::EntityScope;

template <class Pybind11T = pybind11::module_>
struct Bind_clang : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "clang")} {}

  template <class... HandleArgsT>
  explicit Bind_clang(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang

using Entity_clang = Bind_clang<>;

#else

struct Entity_clang : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang(EntityScope parent_h) {}
  static const char *Key() { return "clang"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang

template <class Pybind11T = pybind11::module_>
struct Bind_clang_diff : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_diff(EntityScope parent_h)
      : handle{
            static_cast<pybind11::module_ &>(parent_h).def_submodule("diff")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_diff(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff

using Entity_clang_diff = Bind_clang_diff<>;

#else

struct Entity_clang_diff : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff

template <class Pybind11T = pybind11::class_<clang::diff::ASTDiff>>
struct Bind_clang_diff_ASTDiff : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getMapped() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the ID of the node that is mapped to the given node in SourceTree.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_ASTDiff_getMapped
    handle.def(
        "getMapped",
        static_cast<pybind11_weaver::FnPtrT<
            clang::diff::ASTDiff, clang::diff::NodeId,
            const clang::diff::SyntaxTree &, clang::diff::NodeId>::const_type>(
            &clang::diff::ASTDiff::getMapped),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_ASTDiff_Ctor0
    handle.def(
        pybind11::init<clang::diff::SyntaxTree &, clang::diff::SyntaxTree &,
                       const clang::diff::ComparisonOptions &>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_diff_ASTDiff(EntityScope parent_h)
      : handle{parent_h, "ASTDiff", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_diff_ASTDiff(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getMapped();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff_ASTDiff"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff_ASTDiff

using Entity_clang_diff_ASTDiff = Bind_clang_diff_ASTDiff<>;

#else

struct Entity_clang_diff_ASTDiff : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff_ASTDiff(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff_ASTDiff"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff_ASTDiff

template <class Pybind11T = pybind11::enum_<clang::diff::ChangeKind>>
struct Bind_clang_diff_ChangeKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_diff_ChangeKind(EntityScope parent_h)
      : handle{parent_h, "ChangeKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_diff_ChangeKind(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("None", clang::diff::ChangeKind::None);
    handle.value("Delete", clang::diff::ChangeKind::Delete,
                 R"_pb11_weaver(// (Src): delete node Src.)_pb11_weaver");
    handle.value(
        "Update", clang::diff::ChangeKind::Update,
        R"_pb11_weaver(// (Src, Dst): update the value of node Src to match Dst.)_pb11_weaver");
    handle.value(
        "Insert", clang::diff::ChangeKind::Insert,
        R"_pb11_weaver(// (Src, Dst, Pos): insert Src as child of Dst at offset Pos.)_pb11_weaver");
    handle.value(
        "Move", clang::diff::ChangeKind::Move,
        R"_pb11_weaver(// (Src, Dst, Pos): move Src to be a child of Dst at offset Pos.)_pb11_weaver");
    handle.value("UpdateMove", clang::diff::ChangeKind::UpdateMove,
                 R"_pb11_weaver(// Same as Move plus Update.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff_ChangeKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff_ChangeKind

using Entity_clang_diff_ChangeKind = Bind_clang_diff_ChangeKind<>;

#else

struct Entity_clang_diff_ChangeKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff_ChangeKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff_ChangeKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff_ChangeKind

template <class Pybind11T = pybind11::class_<clang::diff::ComparisonOptions>>
struct Bind_clang_diff_ComparisonOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_isMatchingAllowed() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns false if the nodes should never be matched.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_ComparisonOptions_isMatchingAllowed
    handle.def(
        "isMatchingAllowed",
        static_cast<pybind11_weaver::FnPtrT<
            clang::diff::ComparisonOptions, bool, const clang::diff::Node &,
            const clang::diff::Node &>::const_type>(
            &clang::diff::ComparisonOptions::isMatchingAllowed),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_diff_ComparisonOptions(EntityScope parent_h)
      : handle{parent_h, "ComparisonOptions", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_diff_ComparisonOptions(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_isMatchingAllowed();
    pybind11_weaver::TryAddDefaultCtor<clang::diff::ComparisonOptions>(handle);
    handle.def_readwrite(
        "MinHeight", &clang::diff::ComparisonOptions::MinHeight,
        R"_pb11_weaver(/// During top-down matching, only consider nodes of at least this height.)_pb11_weaver");
    handle.def_readwrite(
        "MinSimilarity", &clang::diff::ComparisonOptions::MinSimilarity,
        R"_pb11_weaver(/// During bottom-up matching, match only nodes with at least this value as
  /// the ratio of their common descendants.)_pb11_weaver");
    handle.def_readwrite(
        "MaxSize", &clang::diff::ComparisonOptions::MaxSize,
        R"_pb11_weaver(/// Whenever two subtrees are matched in the bottom-up phase, the optimal
  /// mapping is computed, unless the size of either subtrees exceeds this.)_pb11_weaver");
    handle.def_readwrite("StopAfterTopDown",
                         &clang::diff::ComparisonOptions::StopAfterTopDown);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff_ComparisonOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff_ComparisonOptions

using Entity_clang_diff_ComparisonOptions = Bind_clang_diff_ComparisonOptions<>;

#else

struct Entity_clang_diff_ComparisonOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff_ComparisonOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff_ComparisonOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff_ComparisonOptions

template <class Pybind11T = pybind11::class_<clang::diff::Node>>
struct Bind_clang_diff_Node : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getType() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_Node_getType
    handle.def(
        "getType",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::Node,
                                            clang::ASTNodeKind>::const_type>(
            &clang::diff::Node::getType));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTypeLabel() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_Node_getTypeLabel
    handle.def(
        "getTypeLabel",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::Node,
                                            llvm::StringRef>::const_type>(
            &clang::diff::Node::getTypeLabel));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isLeaf() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_Node_isLeaf
    handle.def(
        "isLeaf",
        static_cast<
            pybind11_weaver::FnPtrT<clang::diff::Node, bool>::const_type>(
            &clang::diff::Node::isLeaf));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getIdentifier() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_Node_getIdentifier
    handle.def(
        "getIdentifier",
        static_cast<pybind11_weaver::FnPtrT<
            clang::diff::Node, std::optional<llvm::StringRef>>::const_type>(
            &clang::diff::Node::getIdentifier));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getQualifiedIdentifier() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_Node_getQualifiedIdentifier
    handle.def("getQualifiedIdentifier",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::diff::Node,
                   std::optional<std::basic_string<char>>>::const_type>(
                   &clang::diff::Node::getQualifiedIdentifier));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_diff_Node(EntityScope parent_h)
      : handle{parent_h, "Node", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Represents a Clang AST node, alongside some additional information.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_diff_Node(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getType();
    AddMethod_getTypeLabel();
    AddMethod_isLeaf();
    AddMethod_getIdentifier();
    AddMethod_getQualifiedIdentifier();
    pybind11_weaver::TryAddDefaultCtor<clang::diff::Node>(handle);
    handle.def_readwrite("Depth", &clang::diff::Node::Depth);
    handle.def_readwrite("Height", &clang::diff::Node::Height);
    handle.def_readwrite("Shift", &clang::diff::Node::Shift);
    handle.def_readwrite("Change", &clang::diff::Node::Change);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff_Node"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff_Node

using Entity_clang_diff_Node = Bind_clang_diff_Node<>;

#else

struct Entity_clang_diff_Node : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff_Node(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff_Node"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff_Node

template <class Pybind11T = pybind11::class_<clang::diff::NodeId>>
struct Bind_clang_diff_NodeId : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_isValid() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_NodeId_isValid
    handle.def(
        "isValid",
        static_cast<
            pybind11_weaver::FnPtrT<clang::diff::NodeId, bool>::const_type>(
            &clang::diff::NodeId::isValid));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isInvalid() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_NodeId_isInvalid
    handle.def(
        "isInvalid",
        static_cast<
            pybind11_weaver::FnPtrT<clang::diff::NodeId, bool>::const_type>(
            &clang::diff::NodeId::isInvalid));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Within a tree, this identifies a node by its preorder offset.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_NodeId_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Within a tree, this identifies a node by its preorder offset.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_NodeId_Ctor1
    handle.def(pybind11::init<int>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_diff_NodeId(EntityScope parent_h)
      : handle{parent_h, "NodeId", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Within a tree, this identifies a node by its preorder offset.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_diff_NodeId(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_isValid();
    AddMethod_isInvalid();
    AddCtor0();
    AddCtor1();
    handle.def_readwrite("Id", &clang::diff::NodeId::Id);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff_NodeId"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff_NodeId

using Entity_clang_diff_NodeId = Bind_clang_diff_NodeId<>;

#else

struct Entity_clang_diff_NodeId : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff_NodeId(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff_NodeId"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff_NodeId

template <class Pybind11T = pybind11::class_<clang::diff::SyntaxTree>>
struct Bind_clang_diff_SyntaxTree : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getASTContext() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getASTContext
    handle.def(
        "getASTContext",
        static_cast<pybind11_weaver::FnPtrT<
            clang::diff::SyntaxTree, const clang::ASTContext &>::const_type>(
            &clang::diff::SyntaxTree::getASTContext));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFilename() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getFilename
    handle.def(
        "getFilename",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree,
                                            llvm::StringRef>::const_type>(
            &clang::diff::SyntaxTree::getFilename));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSize() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getSize
    handle.def(
        "getSize",
        static_cast<
            pybind11_weaver::FnPtrT<clang::diff::SyntaxTree, int>::const_type>(
            &clang::diff::SyntaxTree::getSize));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRootId() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getRootId
    handle.def(
        "getRootId",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree,
                                            clang::diff::NodeId>::const_type>(
            &clang::diff::SyntaxTree::getRootId));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_begin() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_begin
    handle.def(
        "begin",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree,
                                            clang::diff::NodeId>::const_type>(
            &clang::diff::SyntaxTree::begin));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_end() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_end
    handle.def(
        "end",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree,
                                            clang::diff::NodeId>::const_type>(
            &clang::diff::SyntaxTree::end));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNode() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getNode
    handle.def(
        "getNode",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree,
                                            const clang::diff::Node &,
                                            clang::diff::NodeId>::const_type>(
            &clang::diff::SyntaxTree::getNode));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findPositionInParent() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_findPositionInParent
    handle.def(
        "findPositionInParent",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree, int,
                                            clang::diff::NodeId>::const_type>(
            &clang::diff::SyntaxTree::findPositionInParent));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSourceRangeOffsets() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the starting and ending offset of the node in its source file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getSourceRangeOffsets
    handle.def(
        "getSourceRangeOffsets",
        static_cast<pybind11_weaver::FnPtrT<
            clang::diff::SyntaxTree, std::pair<unsigned int, unsigned int>,
            const clang::diff::Node &>::const_type>(
            &clang::diff::SyntaxTree::getSourceRangeOffsets),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNodeValue() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Serialize the node attributes to a string representation. This should
  /// uniquely distinguish nodes of the same kind. Note that this function just
  /// returns a representation of the node value, not considering descendants.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getNodeValue
    handle.def(
        "getNodeValue",
        static_cast<pybind11_weaver::FnPtrT<clang::diff::SyntaxTree,
                                            std::basic_string<char>,
                                            clang::diff::NodeId>::const_type>(
            &clang::diff::SyntaxTree::getNodeValue),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNodeValue1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_getNodeValue1
    handle.def("getNodeValue",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::diff::SyntaxTree, std::basic_string<char>,
                   const clang::diff::Node &>::const_type>(
                   &clang::diff::SyntaxTree::getNodeValue));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// SyntaxTree objects represent subtrees of the AST.
/// They can be constructed from any Decl or Stmt.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_diff_SyntaxTree_Ctor0
    handle.def(pybind11::init<clang::ASTContext &>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_diff_SyntaxTree(EntityScope parent_h)
      : handle{
            parent_h, "SyntaxTree", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// SyntaxTree objects represent subtrees of the AST.
/// They can be constructed from any Decl or Stmt.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_diff_SyntaxTree(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getASTContext();
    AddMethod_getFilename();
    AddMethod_getSize();
    AddMethod_getRootId();
    AddMethod_begin();
    AddMethod_end();
    AddMethod_getNode();
    AddMethod_findPositionInParent();
    AddMethod_getSourceRangeOffsets();
    AddMethod_getNodeValue();
    AddMethod_getNodeValue1();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_diff_SyntaxTree"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_diff_SyntaxTree

using Entity_clang_diff_SyntaxTree = Bind_clang_diff_SyntaxTree<>;

#else

struct Entity_clang_diff_SyntaxTree : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_diff_SyntaxTree(EntityScope parent_h) {}
  static const char *Key() { return "clang_diff_SyntaxTree"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_diff_SyntaxTree

template <class Pybind11T = pybind11::module_>
struct Bind_clang_driver : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_driver(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "driver")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_driver(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_driver"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_driver

using Entity_clang_driver = Bind_clang_driver<>;

#else

struct Entity_clang_driver : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_driver(EntityScope parent_h) {}
  static const char *Key() { return "clang_driver"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_driver

template <class Pybind11T = pybind11::module_>
struct Bind_clang_syntax : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_syntax(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "syntax")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax

using Entity_clang_syntax = Bind_clang_syntax<>;

#else

struct Entity_clang_syntax : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax

template <class Pybind11T = pybind11::class_<clang::syntax::Arena>>
struct Bind_clang_syntax_Arena : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getAllocator() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Arena_getAllocator
    handle.def("getAllocator",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Arena, llvm::BumpPtrAllocatorImpl<> &>::type>(
                   &clang::syntax::Arena::getAllocator));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Arena(EntityScope parent_h)
      : handle{parent_h, "Arena", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A memory arena for syntax trees.
// FIXME: use BumpPtrAllocator directly.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Arena(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getAllocator();
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::Arena>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Arena"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Arena

using Entity_clang_syntax_Arena = Bind_clang_syntax_Arena<>;

#else

struct Entity_clang_syntax_Arena : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Arena(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Arena"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Arena

template <class Pybind11T = pybind11::class_<
              clang::syntax::BinaryOperatorExpression,
              std::unique_ptr<clang::syntax::BinaryOperatorExpression,
                              pybind11::nodelete>>>
struct Bind_clang_syntax_BinaryOperatorExpression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BinaryOperatorExpression_classof
    handle.def_static(
        "classof",
        [](clang::syntax::BinaryOperatorExpression &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::BinaryOperatorExpression::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLhs() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BinaryOperatorExpression_getLhs
    handle.def("getLhs", [](clang::syntax::BinaryOperatorExpression &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::BinaryOperatorExpression,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::BinaryOperatorExpression::getLhs),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOperatorToken() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BinaryOperatorExpression_getOperatorToken
    handle.def("getOperatorToken", [](clang::syntax::BinaryOperatorExpression
                                          &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::BinaryOperatorExpression,
                                      clang::syntax::Leaf *>::type>(
              &clang::syntax::BinaryOperatorExpression::getOperatorToken),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRhs() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BinaryOperatorExpression_getRhs
    handle.def("getRhs", [](clang::syntax::BinaryOperatorExpression &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::BinaryOperatorExpression,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::BinaryOperatorExpression::getRhs),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// <lhs> <operator> <rhs>
///
/// For example:
///   a + b
///   a bitor 1
///   a |= b
///   a and_eq b)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BinaryOperatorExpression_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_BinaryOperatorExpression(EntityScope parent_h)
      : handle{parent_h, "BinaryOperatorExpression", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// <lhs> <operator> <rhs>
///
/// For example:
///   a + b
///   a bitor 1
///   a |= b
///   a and_eq b)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_BinaryOperatorExpression(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getLhs();
    AddMethod_getOperatorToken();
    AddMethod_getRhs();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_BinaryOperatorExpression"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_BinaryOperatorExpression

using Entity_clang_syntax_BinaryOperatorExpression =
    Bind_clang_syntax_BinaryOperatorExpression<>;

#else

struct Entity_clang_syntax_BinaryOperatorExpression
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_BinaryOperatorExpression(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_BinaryOperatorExpression"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_BinaryOperatorExpression

template <class Pybind11T = pybind11::class_<clang::syntax::FileRange>>
struct Bind_clang_syntax_FileRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_file() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_file
    handle.def("file",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::FileRange,
                                                   clang::FileID>::const_type>(
                   &clang::syntax::FileRange::file));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_beginOffset() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Start is a start offset (inclusive) in the corresponding file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_beginOffset
    handle.def("beginOffset",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::FileRange,
                                                   unsigned int>::const_type>(
                   &clang::syntax::FileRange::beginOffset),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_endOffset() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// End offset (exclusive) in the corresponding file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_endOffset
    handle.def("endOffset",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::FileRange,
                                                   unsigned int>::const_type>(
                   &clang::syntax::FileRange::endOffset),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_length() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_length
    handle.def("length",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::FileRange,
                                                   unsigned int>::const_type>(
                   &clang::syntax::FileRange::length));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_contains() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Check if \p Offset is inside the range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_contains
    handle.def(
        "contains",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::FileRange, bool,
                                            unsigned int>::const_type>(
            &clang::syntax::FileRange::contains),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_touches() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Check \p Offset is inside the range or equal to its endpoint.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_touches
    handle.def(
        "touches",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::FileRange, bool,
                                            unsigned int>::const_type>(
            &clang::syntax::FileRange::touches),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_text() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets the substring that this FileRange refers to.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_text
    handle.def(
        "text",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::FileRange, llvm::StringRef,
                                    const clang::SourceManager &>::const_type>(
            &clang::syntax::FileRange::text),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_toCharRange() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Convert to the clang range. The returned range is always a char range,
  /// never a token range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_toCharRange
    handle.def("toCharRange",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::FileRange, clang::CharSourceRange,
                   const clang::SourceManager &>::const_type>(
                   &clang::syntax::FileRange::toCharRange),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A half-open character range inside a particular file, the start offset is
/// included and the end offset is excluded from the range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_Ctor0
    handle.def(pybind11::init<clang::FileID, unsigned int, unsigned int>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A half-open character range inside a particular file, the start offset is
/// included and the end offset is excluded from the range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_Ctor1
    handle.def(pybind11::init<const clang::SourceManager &,
                              clang::SourceLocation, unsigned int>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor2() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A half-open character range inside a particular file, the start offset is
/// included and the end offset is excluded from the range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_FileRange_Ctor2
    handle.def(pybind11::init<const clang::SourceManager &,
                              clang::SourceLocation, clang::SourceLocation>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_FileRange(EntityScope parent_h)
      : handle{
            parent_h, "FileRange", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A half-open character range inside a particular file, the start offset is
/// included and the end offset is excluded from the range.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_FileRange(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_file();
    AddMethod_beginOffset();
    AddMethod_endOffset();
    AddMethod_length();
    AddMethod_contains();
    AddMethod_touches();
    AddMethod_text();
    AddMethod_toCharRange();
    AddCtor0();
    AddCtor1();
    AddCtor2();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_FileRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_FileRange

using Entity_clang_syntax_FileRange = Bind_clang_syntax_FileRange<>;

#else

struct Entity_clang_syntax_FileRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_FileRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_FileRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_FileRange

template <class Pybind11T = pybind11::class_<
              clang::syntax::Node,
              std::unique_ptr<clang::syntax::Node, pybind11::nodelete>>>
struct Bind_clang_syntax_Node : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getKind() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getKind
    handle.def("getKind",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Node, clang::syntax::NodeKind>::const_type>(
                   &clang::syntax::Node::getKind));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRole() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getRole
    handle.def("getRole",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Node, clang::syntax::NodeRole>::const_type>(
                   &clang::syntax::Node::getRole));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isDetached() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Whether the node is detached from a tree, i.e. does not have a parent.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_isDetached
    handle.def(
        "isDetached",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::Node, bool>::const_type>(
            &clang::syntax::Node::isDetached),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isOriginal() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Whether the node was created from the AST backed by the source code
  /// rather than added later through mutation APIs or created with factory
  /// functions.
  /// When this flag is true, all subtrees are also original.
  /// This flag is set to false on any modifications to the node or any of its
  /// subtrees, even if this simply involves swapping existing subtrees.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_isOriginal
    handle.def(
        "isOriginal",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::Node, bool>::const_type>(
            &clang::syntax::Node::isOriginal),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_canModify() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If this function return false, the tree cannot be modified because there
  /// is no reasonable way to produce the corresponding textual replacements.
  /// This can happen when the node crosses macro expansion boundaries.
  ///
  /// Note that even if the node is not modifiable, its child nodes can be
  /// modifiable.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_canModify
    handle.def(
        "canModify",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::Node, bool>::const_type>(
            &clang::syntax::Node::canModify),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getParent() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getParent
    handle.def("getParent", [](clang::syntax::Node &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Node, const clang::syntax::Tree *>::const_type>(
              &clang::syntax::Node::getParent),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Tree *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getParent1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getParent1
    handle.def("getParent", [](clang::syntax::Node &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Node,
                                              clang::syntax::Tree *>::type>(
              &clang::syntax::Node::getParent),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Tree *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNextSibling() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getNextSibling
    handle.def("getNextSibling", [](clang::syntax::Node &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Node, const clang::syntax::Node *>::const_type>(
              &clang::syntax::Node::getNextSibling),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNextSibling1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getNextSibling1
    handle.def("getNextSibling", [](clang::syntax::Node &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Node,
                                              clang::syntax::Node *>::type>(
              &clang::syntax::Node::getNextSibling),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getPreviousSibling() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getPreviousSibling
    handle.def("getPreviousSibling", [](clang::syntax::Node &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Node, const clang::syntax::Node *>::const_type>(
              &clang::syntax::Node::getPreviousSibling),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getPreviousSibling1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_getPreviousSibling1
    handle.def("getPreviousSibling", [](clang::syntax::Node &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Node,
                                              clang::syntax::Node *>::type>(
              &clang::syntax::Node::getPreviousSibling),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_dump() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Dumps the structure of a subtree. For debugging and testing purposes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_dump
    handle.def("dump",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Node, std::basic_string<char>,
                   const clang::syntax::TokenManager &>::const_type>(
                   &clang::syntax::Node::dump),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_dumpTokens() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Dumps the tokens forming this subtree.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_dumpTokens
    handle.def("dumpTokens",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Node, std::basic_string<char>,
                   const clang::syntax::TokenManager &>::const_type>(
                   &clang::syntax::Node::dumpTokens),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_assertInvariants() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Asserts invariants on this node of the tree and its immediate children.
  /// Will not recurse into the subtree. No-op if NDEBUG is set.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_assertInvariants
    handle.def(
        "assertInvariants",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::Node, void>::const_type>(
            &clang::syntax::Node::assertInvariants),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_assertInvariantsRecursive() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Runs checkInvariants on all nodes in the subtree. No-op if NDEBUG is set.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Node_assertInvariantsRecursive
    handle.def(
        "assertInvariantsRecursive",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::Node, void>::const_type>(
            &clang::syntax::Node::assertInvariantsRecursive),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Node(EntityScope parent_h)
      : handle{
            parent_h, "Node", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A node in a syntax tree. Each node is either a Leaf (representing tokens) or
/// a Tree (representing language constructrs).)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Node(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getKind();
    AddMethod_getRole();
    AddMethod_isDetached();
    AddMethod_isOriginal();
    AddMethod_canModify();
    AddMethod_getParent();
    AddMethod_getParent1();
    AddMethod_getNextSibling();
    AddMethod_getNextSibling1();
    AddMethod_getPreviousSibling();
    AddMethod_getPreviousSibling1();
    AddMethod_dump();
    AddMethod_dumpTokens();
    AddMethod_assertInvariants();
    AddMethod_assertInvariantsRecursive();
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::Node>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Node"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Node

using Entity_clang_syntax_Node = Bind_clang_syntax_Node<>;

#else

struct Entity_clang_syntax_Node : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Node(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Node"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Node

template <class Pybind11T = pybind11::enum_<clang::syntax::NodeKind>>
struct Bind_clang_syntax_NodeKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_syntax_NodeKind(EntityScope parent_h)
      : handle{
            parent_h, "NodeKind", pybind11::arithmetic(),
            R"_pb11_weaver(/// A kind of a syntax node, used for implementing casts. The ordering and
/// blocks of enumerator constants must correspond to the inheritance hierarchy
/// of syntax::Node.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_NodeKind(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Leaf", clang::syntax::NodeKind::Leaf);
    handle.value("ArraySubscript", clang::syntax::NodeKind::ArraySubscript);
    handle.value("EmptyDeclaration", clang::syntax::NodeKind::EmptyDeclaration);
    handle.value("ExplicitTemplateInstantiation",
                 clang::syntax::NodeKind::ExplicitTemplateInstantiation);
    handle.value("LinkageSpecificationDeclaration",
                 clang::syntax::NodeKind::LinkageSpecificationDeclaration);
    handle.value("NamespaceAliasDefinition",
                 clang::syntax::NodeKind::NamespaceAliasDefinition);
    handle.value("NamespaceDefinition",
                 clang::syntax::NodeKind::NamespaceDefinition);
    handle.value("SimpleDeclaration",
                 clang::syntax::NodeKind::SimpleDeclaration);
    handle.value("StaticAssertDeclaration",
                 clang::syntax::NodeKind::StaticAssertDeclaration);
    handle.value("TemplateDeclaration",
                 clang::syntax::NodeKind::TemplateDeclaration);
    handle.value("TypeAliasDeclaration",
                 clang::syntax::NodeKind::TypeAliasDeclaration);
    handle.value("UnknownDeclaration",
                 clang::syntax::NodeKind::UnknownDeclaration);
    handle.value("UsingDeclaration", clang::syntax::NodeKind::UsingDeclaration);
    handle.value("UsingNamespaceDirective",
                 clang::syntax::NodeKind::UsingNamespaceDirective);
    handle.value("ParenDeclarator", clang::syntax::NodeKind::ParenDeclarator);
    handle.value("SimpleDeclarator", clang::syntax::NodeKind::SimpleDeclarator);
    handle.value("BinaryOperatorExpression",
                 clang::syntax::NodeKind::BinaryOperatorExpression);
    handle.value("CallExpression", clang::syntax::NodeKind::CallExpression);
    handle.value("IdExpression", clang::syntax::NodeKind::IdExpression);
    handle.value("BoolLiteralExpression",
                 clang::syntax::NodeKind::BoolLiteralExpression);
    handle.value("CharacterLiteralExpression",
                 clang::syntax::NodeKind::CharacterLiteralExpression);
    handle.value("CxxNullPtrExpression",
                 clang::syntax::NodeKind::CxxNullPtrExpression);
    handle.value("FloatingLiteralExpression",
                 clang::syntax::NodeKind::FloatingLiteralExpression);
    handle.value("IntegerLiteralExpression",
                 clang::syntax::NodeKind::IntegerLiteralExpression);
    handle.value("StringLiteralExpression",
                 clang::syntax::NodeKind::StringLiteralExpression);
    handle.value("CharUserDefinedLiteralExpression",
                 clang::syntax::NodeKind::CharUserDefinedLiteralExpression);
    handle.value("FloatUserDefinedLiteralExpression",
                 clang::syntax::NodeKind::FloatUserDefinedLiteralExpression);
    handle.value("IntegerUserDefinedLiteralExpression",
                 clang::syntax::NodeKind::IntegerUserDefinedLiteralExpression);
    handle.value("StringUserDefinedLiteralExpression",
                 clang::syntax::NodeKind::StringUserDefinedLiteralExpression);
    handle.value("MemberExpression", clang::syntax::NodeKind::MemberExpression);
    handle.value("ParenExpression", clang::syntax::NodeKind::ParenExpression);
    handle.value("ThisExpression", clang::syntax::NodeKind::ThisExpression);
    handle.value("UnknownExpression",
                 clang::syntax::NodeKind::UnknownExpression);
    handle.value("CallArguments", clang::syntax::NodeKind::CallArguments);
    handle.value("DeclaratorList", clang::syntax::NodeKind::DeclaratorList);
    handle.value("NestedNameSpecifier",
                 clang::syntax::NodeKind::NestedNameSpecifier);
    handle.value("ParameterDeclarationList",
                 clang::syntax::NodeKind::ParameterDeclarationList);
    handle.value("MemberPointer", clang::syntax::NodeKind::MemberPointer);
    handle.value("DecltypeNameSpecifier",
                 clang::syntax::NodeKind::DecltypeNameSpecifier);
    handle.value("GlobalNameSpecifier",
                 clang::syntax::NodeKind::GlobalNameSpecifier);
    handle.value("IdentifierNameSpecifier",
                 clang::syntax::NodeKind::IdentifierNameSpecifier);
    handle.value("SimpleTemplateNameSpecifier",
                 clang::syntax::NodeKind::SimpleTemplateNameSpecifier);
    handle.value("ParametersAndQualifiers",
                 clang::syntax::NodeKind::ParametersAndQualifiers);
    handle.value("BreakStatement", clang::syntax::NodeKind::BreakStatement);
    handle.value("CaseStatement", clang::syntax::NodeKind::CaseStatement);
    handle.value("CompoundStatement",
                 clang::syntax::NodeKind::CompoundStatement);
    handle.value("ContinueStatement",
                 clang::syntax::NodeKind::ContinueStatement);
    handle.value("DeclarationStatement",
                 clang::syntax::NodeKind::DeclarationStatement);
    handle.value("DefaultStatement", clang::syntax::NodeKind::DefaultStatement);
    handle.value("EmptyStatement", clang::syntax::NodeKind::EmptyStatement);
    handle.value("ExpressionStatement",
                 clang::syntax::NodeKind::ExpressionStatement);
    handle.value("ForStatement", clang::syntax::NodeKind::ForStatement);
    handle.value("IfStatement", clang::syntax::NodeKind::IfStatement);
    handle.value("RangeBasedForStatement",
                 clang::syntax::NodeKind::RangeBasedForStatement);
    handle.value("ReturnStatement", clang::syntax::NodeKind::ReturnStatement);
    handle.value("SwitchStatement", clang::syntax::NodeKind::SwitchStatement);
    handle.value("UnknownStatement", clang::syntax::NodeKind::UnknownStatement);
    handle.value("WhileStatement", clang::syntax::NodeKind::WhileStatement);
    handle.value("TrailingReturnType",
                 clang::syntax::NodeKind::TrailingReturnType);
    handle.value("TranslationUnit", clang::syntax::NodeKind::TranslationUnit);
    handle.value("PostfixUnaryOperatorExpression",
                 clang::syntax::NodeKind::PostfixUnaryOperatorExpression);
    handle.value("PrefixUnaryOperatorExpression",
                 clang::syntax::NodeKind::PrefixUnaryOperatorExpression);
    handle.value("UnqualifiedId", clang::syntax::NodeKind::UnqualifiedId);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_NodeKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_NodeKind

using Entity_clang_syntax_NodeKind = Bind_clang_syntax_NodeKind<>;

#else

struct Entity_clang_syntax_NodeKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_NodeKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_NodeKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_NodeKind

template <class Pybind11T = pybind11::enum_<clang::syntax::NodeRole>>
struct Bind_clang_syntax_NodeRole : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_syntax_NodeRole(EntityScope parent_h)
      : handle{
            parent_h, "NodeRole", pybind11::arithmetic(),
            R"_pb11_weaver(/// A relation between a parent and child node, e.g. 'left-hand-side of
/// a binary expression'. Used for implementing accessors.
///
/// In general `NodeRole`s should be named the same as their accessors.
///
/// Some roles describe parent/child relations that occur multiple times in
/// language grammar. We define only one role to describe all instances of such
/// recurring relations. For example, grammar for both "if" and "while"
/// statements requires an opening paren and a closing paren. The opening
/// paren token is assigned the OpenParen role regardless of whether it appears
/// as a child of IfStatement or WhileStatement node. More generally, when
/// grammar requires a certain fixed token (like a specific keyword, or an
/// opening paren), we define a role for this token and use it across all
/// grammar rules with the same requirement. Names of such reusable roles end
/// with a ~Token or a ~Keyword suffix.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_NodeRole(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Detached", clang::syntax::NodeRole::Detached,
                 R"_pb11_weaver(// Roles common to multiple node kinds.
  /// A node without a parent)_pb11_weaver");
    handle.value(
        "Unknown", clang::syntax::NodeRole::Unknown,
        R"_pb11_weaver(/// Children of an unknown semantic nature, e.g. skipped tokens, comments.)_pb11_weaver");
    handle.value(
        "OpenParen", clang::syntax::NodeRole::OpenParen,
        R"_pb11_weaver(/// An opening parenthesis in argument lists and blocks, e.g. '{', '(', etc.)_pb11_weaver");
    handle.value(
        "CloseParen", clang::syntax::NodeRole::CloseParen,
        R"_pb11_weaver(/// A closing parenthesis in argument lists and blocks, e.g. '}', ')', etc.)_pb11_weaver");
    handle.value(
        "IntroducerKeyword", clang::syntax::NodeRole::IntroducerKeyword,
        R"_pb11_weaver(/// A keywords that introduces some grammar construct, e.g. 'if', 'try', etc.)_pb11_weaver");
    handle.value(
        "LiteralToken", clang::syntax::NodeRole::LiteralToken,
        R"_pb11_weaver(/// A token that represents a literal, e.g. 'nullptr', '1', 'true', etc.)_pb11_weaver");
    handle.value("ArrowToken", clang::syntax::NodeRole::ArrowToken,
                 R"_pb11_weaver(/// Tokens or Keywords.)_pb11_weaver");
    handle.value("ExternKeyword", clang::syntax::NodeRole::ExternKeyword,
                 R"_pb11_weaver(/// Tokens or Keywords.)_pb11_weaver");
    handle.value("TemplateKeyword", clang::syntax::NodeRole::TemplateKeyword,
                 R"_pb11_weaver(/// Tokens or Keywords.)_pb11_weaver");
    handle.value(
        "BodyStatement", clang::syntax::NodeRole::BodyStatement,
        R"_pb11_weaver(/// An inner statement for those that have only a single child of kind
  /// statement, e.g. loop body for while, for, etc; inner statement for case,
  /// default, etc.)_pb11_weaver");
    handle.value("ListElement", clang::syntax::NodeRole::ListElement,
                 R"_pb11_weaver(/// List API roles.)_pb11_weaver");
    handle.value("ListDelimiter", clang::syntax::NodeRole::ListDelimiter,
                 R"_pb11_weaver(/// List API roles.)_pb11_weaver");
    handle.value(
        "OperatorToken", clang::syntax::NodeRole::OperatorToken,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Operand", clang::syntax::NodeRole::Operand,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "LeftHandSide", clang::syntax::NodeRole::LeftHandSide,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "RightHandSide", clang::syntax::NodeRole::RightHandSide,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "ReturnValue", clang::syntax::NodeRole::ReturnValue,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "CaseValue", clang::syntax::NodeRole::CaseValue,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "ThenStatement", clang::syntax::NodeRole::ThenStatement,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "ElseKeyword", clang::syntax::NodeRole::ElseKeyword,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "ElseStatement", clang::syntax::NodeRole::ElseStatement,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Expression", clang::syntax::NodeRole::Expression,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Statement", clang::syntax::NodeRole::Statement,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Condition", clang::syntax::NodeRole::Condition,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Message", clang::syntax::NodeRole::Message,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Declarator", clang::syntax::NodeRole::Declarator,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Declaration", clang::syntax::NodeRole::Declaration,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Size", clang::syntax::NodeRole::Size,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Parameters", clang::syntax::NodeRole::Parameters,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "TrailingReturn", clang::syntax::NodeRole::TrailingReturn,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "UnqualifiedId", clang::syntax::NodeRole::UnqualifiedId,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Qualifier", clang::syntax::NodeRole::Qualifier,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "SubExpression", clang::syntax::NodeRole::SubExpression,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Object", clang::syntax::NodeRole::Object,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "AccessToken", clang::syntax::NodeRole::AccessToken,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Member", clang::syntax::NodeRole::Member,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Callee", clang::syntax::NodeRole::Callee,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Arguments", clang::syntax::NodeRole::Arguments,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
    handle.value(
        "Declarators", clang::syntax::NodeRole::Declarators,
        R"_pb11_weaver(// Roles specific to particular node kinds.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_NodeRole"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_NodeRole

using Entity_clang_syntax_NodeRole = Bind_clang_syntax_NodeRole<>;

#else

struct Entity_clang_syntax_NodeRole : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_NodeRole(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_NodeRole"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_NodeRole

template <class Pybind11T = pybind11::class_<clang::syntax::Token>>
struct Bind_clang_syntax_Token : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_kind() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_kind
    handle.def(
        "kind",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::Token,
                                            clang::tok::TokenKind>::const_type>(
            &clang::syntax::Token::kind));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_location() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Location of the first character of a token.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_location
    handle.def(
        "location",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::Token,
                                            clang::SourceLocation>::const_type>(
            &clang::syntax::Token::location),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_endLocation() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Location right after the last character of a token.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_endLocation
    handle.def(
        "endLocation",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::Token,
                                            clang::SourceLocation>::const_type>(
            &clang::syntax::Token::endLocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_length() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_length
    handle.def("length",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::Token,
                                                   unsigned int>::const_type>(
                   &clang::syntax::Token::length));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_text() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Get the substring covered by the token. Note that will include all
  /// digraphs, newline continuations, etc. E.g. tokens for 'int' and
  ///    in\
  ///    t
  /// both have the same kind tok::kw_int, but results of text() are different.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_text
    handle.def(
        "text",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::Token, llvm::StringRef,
                                    const clang::SourceManager &>::const_type>(
            &clang::syntax::Token::text),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_range() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets a range of this token.
  /// EXPECTS: token comes from a file, not from a macro expansion.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_range
    handle.def("range",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Token, clang::syntax::FileRange,
                   const clang::SourceManager &>::const_type>(
                   &clang::syntax::Token::range),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_range_() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Given two tokens inside the same file, returns a file range that starts at
  /// \p First and ends at \p Last.
  /// EXPECTS: First and Last are file tokens from the same file, Last starts
  ///          after First.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_range_
    handle.def_static("range_",
                      static_cast<pybind11_weaver::FnPtrT<
                          void, clang::syntax::FileRange(
                                    const clang::SourceManager &,
                                    const clang::syntax::Token &,
                                    const clang::syntax::Token &)>::type>(
                          &clang::syntax::Token::range),
                      _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_dumpForTests() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_dumpForTests
    handle.def("dumpForTests",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Token, std::basic_string<char>,
                   const clang::SourceManager &>::const_type>(
                   &clang::syntax::Token::dumpForTests));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_str() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// For debugging purposes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_str
    handle.def("str",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::Token, std::basic_string<char>>::const_type>(
                   &clang::syntax::Token::str),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A token coming directly from a file or from a macro invocation. Has just
/// enough information to locate the token in the source code.
/// Can represent both expanded and spelled tokens.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_Ctor0
    handle.def(pybind11::init<clang::SourceLocation, unsigned int,
                              clang::tok::TokenKind>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A token coming directly from a file or from a macro invocation. Has just
/// enough information to locate the token in the source code.
/// Can represent both expanded and spelled tokens.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Token_Ctor1
    handle.def(pybind11::init<const clang::Token &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Token(EntityScope parent_h)
      : handle{
            parent_h, "Token", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A token coming directly from a file or from a macro invocation. Has just
/// enough information to locate the token in the source code.
/// Can represent both expanded and spelled tokens.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Token(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_kind();
    AddMethod_location();
    AddMethod_endLocation();
    AddMethod_length();
    AddMethod_text();
    AddMethod_range();
    AddMethod_range_();
    AddMethod_dumpForTests();
    AddMethod_str();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Token"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Token

using Entity_clang_syntax_Token = Bind_clang_syntax_Token<>;

#else

struct Entity_clang_syntax_Token : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Token(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Token"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Token

template <class Pybind11T = pybind11::class_<clang::syntax::TokenBuffer>>
struct Bind_clang_syntax_TokenBuffer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_expandedTokens() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// All tokens produced by the preprocessor after all macro replacements,
  /// directives, etc. Source locations found in the clang AST will always
  /// point to one of these tokens.
  /// Tokens are in TU order (per SourceManager::isBeforeInTranslationUnit()).
  /// FIXME: figure out how to handle token splitting, e.g. '>>' can be split
  ///        into two '>' tokens by the parser. However, TokenBuffer currently
  ///        keeps it as a single '>>' token.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_expandedTokens
    handle.def("expandedTokens",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBuffer,
                   llvm::ArrayRef<clang::syntax::Token>>::const_type>(
                   &clang::syntax::TokenBuffer::expandedTokens),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_indexExpandedTokens() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds a cache to make future calls to expandedToken(SourceRange) faster.
  /// Creates an index only once. Further calls to it will be no-op.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_indexExpandedTokens
    handle.def(
        "indexExpandedTokens",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::TokenBuffer, void>::type>(
            &clang::syntax::TokenBuffer::indexExpandedTokens),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_expandedTokens1() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the subrange of expandedTokens() corresponding to the closed
  /// token range R.
  /// Consider calling indexExpandedTokens() before for faster lookups.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_expandedTokens1
    handle.def(
        "expandedTokens",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::TokenBuffer, llvm::ArrayRef<clang::syntax::Token>,
            clang::SourceRange>::const_type>(
            &clang::syntax::TokenBuffer::expandedTokens),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_spelledForExpanded() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the subrange of spelled tokens corresponding to AST node spanning
  /// \p Expanded. This is the text that should be replaced if a refactoring
  /// were to rewrite the node. If \p Expanded is empty, the returned value is
  /// std::nullopt.
  ///
  /// Will fail if the expanded tokens do not correspond to a sequence of
  /// spelled tokens. E.g. for the following example:
  ///
  ///   #define FIRST f1 f2 f3
  ///   #define SECOND s1 s2 s3
  ///   #define ID2(X, Y) X Y
  ///
  ///   a FIRST b SECOND c // expanded tokens are: a f1 f2 f3 b s1 s2 s3 c
  ///   d ID2(e f g, h) i  // expanded tokens are: d e f g h i
  ///
  /// the results would be:
  ///   expanded   => spelled
  ///   ------------------------
  ///            a => a
  ///     s1 s2 s3 => SECOND
  ///   a f1 f2 f3 => a FIRST
  ///         a f1 => can't map
  ///        s1 s2 => can't map
  ///         e f  => e f
  ///         g h  => can't map
  ///
  /// EXPECTS: \p Expanded is a subrange of expandedTokens().
  /// Complexity is logarithmic.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_spelledForExpanded
    handle.def("spelledForExpanded",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBuffer,
                   std::optional<llvm::ArrayRef<clang::syntax::Token>>,
                   llvm::ArrayRef<clang::syntax::Token>>::const_type>(
                   &clang::syntax::TokenBuffer::spelledForExpanded),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_expandedForSpelled() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Find the subranges of expanded tokens, corresponding to \p Spelled.
  ///
  /// Some spelled tokens may not be present in the expanded token stream, so
  /// this function can return an empty vector, e.g. for tokens of macro
  /// directives or disabled preprocessor branches.
  ///
  /// Some spelled tokens can be duplicated in the expanded token stream
  /// multiple times and this function will return multiple results in those
  /// cases. This happens when \p Spelled is inside a macro argument.
  ///
  /// FIXME: return correct results on macro arguments. For now, we return an
  ///        empty list.
  ///
  /// (!) will return empty vector on tokens from #define body:
  /// E.g. for the following example:
  ///
  ///   #define FIRST(A) f1 A = A f2
  ///   #define SECOND s
  ///
  ///   a FIRST(arg) b SECOND c // expanded tokens are: a f1 arg = arg f2 b s
  /// The results would be
  ///   spelled           => expanded
  ///   ------------------------
  ///   #define FIRST     => {}
  ///   a FIRST(arg)      => {a f1 arg = arg f2}
  ///   arg               => {arg, arg} // arg #1 is before `=` and arg #2 is
  ///                                   // after `=` in the expanded tokens.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_expandedForSpelled
    handle.def("expandedForSpelled",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBuffer,
                   llvm::SmallVector<llvm::ArrayRef<clang::syntax::Token>, 1>,
                   llvm::ArrayRef<clang::syntax::Token>>::const_type>(
                   &clang::syntax::TokenBuffer::expandedForSpelled),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_expansionStartingAt() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If \p Spelled starts a mapping (e.g. if it's a macro name or '#' starting
  /// a preprocessor directive) return the subrange of expanded tokens that the
  /// macro expands to.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_expansionStartingAt
    handle.def("expansionStartingAt",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBuffer,
                   std::optional<clang::syntax::TokenBuffer::Expansion>,
                   const clang::syntax::Token *>::const_type>(
                   &clang::syntax::TokenBuffer::expansionStartingAt),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_expansionsOverlapping() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns all expansions (partially) expanded from the specified tokens.
  /// This is the expansions whose Spelled range intersects \p Spelled.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_expansionsOverlapping
    handle.def("expansionsOverlapping",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBuffer,
                   std::vector<clang::syntax::TokenBuffer::Expansion>,
                   llvm::ArrayRef<clang::syntax::Token>>::const_type>(
                   &clang::syntax::TokenBuffer::expansionsOverlapping),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_spelledTokens() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Lexed tokens of a file before preprocessing. E.g. for the following input
  ///     #define DECL(name) int name = 10
  ///     DECL(a);
  /// spelledTokens() returns
  ///    {"#", "define", "DECL", "(", "name", ")", "int", "name", "=", "10",
  ///     "DECL", "(", "a", ")", ";"})_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_spelledTokens
    handle.def(
        "spelledTokens",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::TokenBuffer, llvm::ArrayRef<clang::syntax::Token>,
            clang::FileID>::const_type>(
            &clang::syntax::TokenBuffer::spelledTokens),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_spelledTokenAt() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the spelled Token starting at Loc, if there are no such tokens
  /// returns nullptr.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_spelledTokenAt
    handle.def(
        "spelledTokenAt",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::TokenBuffer,
                                            const clang::syntax::Token *,
                                            clang::SourceLocation>::const_type>(
            &clang::syntax::TokenBuffer::spelledTokenAt),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_macroExpansions() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Get all tokens that expand a macro in \p FID. For the following input
  ///     #define FOO B
  ///     #define FOO2(X) int X
  ///     FOO2(XY)
  ///     int B;
  ///     FOO;
  /// macroExpansions() returns {"FOO2", "FOO"} (from line 3 and 5
  /// respecitvely).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_macroExpansions
    handle.def(
        "macroExpansions",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::TokenBuffer,
                                    std::vector<const clang::syntax::Token *>,
                                    clang::FileID>::const_type>(
            &clang::syntax::TokenBuffer::macroExpansions),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_sourceManager() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_sourceManager
    handle.def(
        "sourceManager",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::TokenBuffer,
                                    const clang::SourceManager &>::const_type>(
            &clang::syntax::TokenBuffer::sourceManager));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_dumpForTests() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_dumpForTests
    handle.def(
        "dumpForTests",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::TokenBuffer, std::basic_string<char>>::const_type>(
            &clang::syntax::TokenBuffer::dumpForTests));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A list of tokens obtained by preprocessing a text buffer and operations to
/// map between the expanded and spelled tokens, i.e. TokenBuffer has
/// information about two token streams:
///    1. Expanded tokens: tokens produced by the preprocessor after all macro
///       replacements,
///    2. Spelled tokens: corresponding directly to the source code of a file
///       before any macro replacements occurred.
/// Here's an example to illustrate a difference between those two:
///     #define FOO 10
///     int a = FOO;
///
/// Spelled tokens are {'#','define','FOO','10','int','a','=','FOO',';'}.
/// Expanded tokens are {'int','a','=','10',';','eof'}.
///
/// Note that the expanded token stream has a tok::eof token at the end, the
/// spelled tokens never store a 'eof' token.
///
/// The full list expanded tokens can be obtained with expandedTokens(). Spelled
/// tokens for each of the files can be obtained via spelledTokens(FileID).
///
/// To map between the expanded and spelled tokens use findSpelledByExpanded().
///
/// To build a token buffer use the TokenCollector class. You can also compute
/// the spelled tokens of a file using the tokenize() helper.
///
/// FIXME: allow mappings into macro arguments.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBuffer_Ctor0
    handle.def(pybind11::init<const clang::SourceManager &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TokenBuffer(EntityScope parent_h)
      : handle{
            parent_h, "TokenBuffer", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A list of tokens obtained by preprocessing a text buffer and operations to
/// map between the expanded and spelled tokens, i.e. TokenBuffer has
/// information about two token streams:
///    1. Expanded tokens: tokens produced by the preprocessor after all macro
///       replacements,
///    2. Spelled tokens: corresponding directly to the source code of a file
///       before any macro replacements occurred.
/// Here's an example to illustrate a difference between those two:
///     #define FOO 10
///     int a = FOO;
///
/// Spelled tokens are {'#','define','FOO','10','int','a','=','FOO',';'}.
/// Expanded tokens are {'int','a','=','10',';','eof'}.
///
/// Note that the expanded token stream has a tok::eof token at the end, the
/// spelled tokens never store a 'eof' token.
///
/// The full list expanded tokens can be obtained with expandedTokens(). Spelled
/// tokens for each of the files can be obtained via spelledTokens(FileID).
///
/// To map between the expanded and spelled tokens use findSpelledByExpanded().
///
/// To build a token buffer use the TokenCollector class. You can also compute
/// the spelled tokens of a file using the tokenize() helper.
///
/// FIXME: allow mappings into macro arguments.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TokenBuffer(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_expandedTokens();
    AddMethod_indexExpandedTokens();
    AddMethod_expandedTokens1();
    AddMethod_spelledForExpanded();
    AddMethod_expandedForSpelled();
    AddMethod_expansionStartingAt();
    AddMethod_expansionsOverlapping();
    AddMethod_spelledTokens();
    AddMethod_spelledTokenAt();
    AddMethod_macroExpansions();
    AddMethod_sourceManager();
    AddMethod_dumpForTests();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TokenBuffer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenBuffer

using Entity_clang_syntax_TokenBuffer = Bind_clang_syntax_TokenBuffer<>;

#else

struct Entity_clang_syntax_TokenBuffer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TokenBuffer(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TokenBuffer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenBuffer

template <class Pybind11T =
              pybind11::class_<clang::syntax::TokenBuffer::Expansion>>
struct Bind_clang_syntax_TokenBuffer_Expansion : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_syntax_TokenBuffer_Expansion(EntityScope parent_h)
      : handle{parent_h, "Expansion", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An expansion produced by the preprocessor, includes macro expansions and
  /// preprocessor directives. Preprocessor always maps a non-empty range of
  /// spelled tokens to a (possibly empty) range of expanded tokens. Here is a
  /// few examples of expansions:
  ///    #pragma once      // Expands to an empty range.
  ///    #define FOO 1 2 3 // Expands an empty range.
  ///    FOO               // Expands to "1 2 3".
  /// FIXME(ibiryukov): implement this, currently #include expansions are empty.
  ///    #include <vector> // Expands to tokens produced by the include.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TokenBuffer_Expansion(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::TokenBuffer::Expansion>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TokenBuffer_Expansion"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenBuffer_Expansion

using Entity_clang_syntax_TokenBuffer_Expansion =
    Bind_clang_syntax_TokenBuffer_Expansion<>;

#else

struct Entity_clang_syntax_TokenBuffer_Expansion
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TokenBuffer_Expansion(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TokenBuffer_Expansion"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenBuffer_Expansion

template <class Pybind11T = pybind11::class_<clang::syntax::TokenCollector>>
struct Bind_clang_syntax_TokenCollector : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_consume() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Finalizes token collection. Should be called after preprocessing is
  /// finished, i.e. after running Execute().)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_syntax_TokenCollector_consume
#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenCollector_consume
    handle.def("consume", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Collects tokens for the main file while running the frontend action. An
/// instance of this object should be created on
/// FrontendAction::BeginSourceFile() and the results should be consumed after
/// FrontendAction::Execute() finishes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenCollector_Ctor0
    handle.def(pybind11::init<clang::Preprocessor &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TokenCollector(EntityScope parent_h)
      : handle{
            parent_h, "TokenCollector", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Collects tokens for the main file while running the frontend action. An
/// instance of this object should be created on
/// FrontendAction::BeginSourceFile() and the results should be consumed after
/// FrontendAction::Execute() finishes.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TokenCollector(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_consume();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TokenCollector"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenCollector

using Entity_clang_syntax_TokenCollector = Bind_clang_syntax_TokenCollector<>;

#else

struct Entity_clang_syntax_TokenCollector
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TokenCollector(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TokenCollector"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenCollector

template <class = void>
class PyTrampTokenManager : public clang::syntax::TokenManager {
public:
  using _PB11_WR_BaseT = clang::syntax::TokenManager;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenManagerllvm_StringLiteral_9__const
  llvm::StringLiteral kind() const override {
    using _PB11_WR_RET_TYPE = llvm::StringLiteral;
    using _PB11_WR_CONCREATE_TYPE = clang::syntax::TokenManager;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, kind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenManagerllvm_StringLiteral_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenManagerllvm_StringRef_9Key__const
  llvm::StringRef getText(unsigned long K) const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::syntax::TokenManager;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getText,
                           K);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenManagerllvm_StringRef_9Key__const
};

template <class Pybind11T = pybind11::class_<clang::syntax::TokenManager,
                                             PyTrampTokenManager<>>>
struct Bind_clang_syntax_TokenManager : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_kind() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Describes what the exact class kind of the TokenManager is.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenManager_kind
    handle.def(
        "kind",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::TokenManager,
                                            llvm::StringLiteral>::const_type>(
            &clang::syntax::TokenManager::kind),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getText() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenManager_getText
    handle.def("getText",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::TokenManager,
                                                   llvm::StringRef,
                                                   unsigned long>::const_type>(
                   &clang::syntax::TokenManager::getText));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TokenManager(EntityScope parent_h)
      : handle{parent_h, "TokenManager", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Defines interfaces for operating "Token" in the clang syntax-tree.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TokenManager(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_kind();
    AddMethod_getText();
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::TokenManager>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TokenManager"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenManager

using Entity_clang_syntax_TokenManager = Bind_clang_syntax_TokenManager<>;

#else

struct Entity_clang_syntax_TokenManager
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TokenManager(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TokenManager"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenManager

template <class Pybind11T = pybind11::class_<
              clang::syntax::Tree,
              std::unique_ptr<clang::syntax::Tree, pybind11::nodelete>,
              clang::syntax::Node>>
struct Bind_clang_syntax_Tree : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_classof
    handle.def_static(
        "classof",
        [](clang::syntax::Tree &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::Tree::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFirstChild() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_getFirstChild
    handle.def("getFirstChild", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Tree,
                                              clang::syntax::Node *>::type>(
              &clang::syntax::Tree::getFirstChild),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFirstChild1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_getFirstChild1
    handle.def("getFirstChild", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Tree, const clang::syntax::Node *>::const_type>(
              &clang::syntax::Tree::getFirstChild),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLastChild() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_getLastChild
    handle.def("getLastChild", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Tree,
                                              clang::syntax::Node *>::type>(
              &clang::syntax::Tree::getLastChild),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLastChild1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_getLastChild1
    handle.def("getLastChild", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Tree, const clang::syntax::Node *>::const_type>(
              &clang::syntax::Tree::getLastChild),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findFirstLeaf() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_findFirstLeaf
    handle.def("findFirstLeaf", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Tree, const clang::syntax::Leaf *>::const_type>(
              &clang::syntax::Tree::findFirstLeaf),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findFirstLeaf1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_findFirstLeaf1
    handle.def("findFirstLeaf", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Tree,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::Tree::findFirstLeaf),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findLastLeaf() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_findLastLeaf
    handle.def("findLastLeaf", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::Tree, const clang::syntax::Leaf *>::const_type>(
              &clang::syntax::Tree::findLastLeaf),
          &self);
      return pybind11_weaver::WrapP<const clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findLastLeaf1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_findLastLeaf1
    handle.def("findLastLeaf", [](clang::syntax::Tree &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Tree,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::Tree::findLastLeaf),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getChildren() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_getChildren
    handle.def(
        "getChildren",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::Tree,
            llvm::iterator_range<clang::syntax::Tree::ChildIterator>>::type>(
            &clang::syntax::Tree::getChildren));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getChildren1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_getChildren1
    handle.def(
        "getChildren",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::Tree,
            llvm::iterator_range<clang::syntax::Tree::ConstChildIterator>>::
                        const_type>(&clang::syntax::Tree::getChildren));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findChild() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Find the first node with a corresponding role.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_findChild
    handle.def(
        "findChild",
        [](clang::syntax::Tree &self, clang::syntax::NodeRole R) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              clang::syntax::Tree, const clang::syntax::Node *,
                              clang::syntax::NodeRole>::const_type>(
                              &clang::syntax::Tree::findChild),
                          &self, R);
          return pybind11_weaver::WrapP<const clang::syntax::Node *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findChild1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_findChild1
    handle.def("findChild", [](clang::syntax::Tree &self,
                               clang::syntax::NodeRole R) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::Tree,
                                              clang::syntax::Node *,
                                              clang::syntax::NodeRole>::type>(
              &clang::syntax::Tree::findChild),
          &self, R);
      return pybind11_weaver::WrapP<clang::syntax::Node *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Tree(EntityScope parent_h)
      : handle{parent_h, "Tree", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A node that has children and represents a syntactic language construct.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Tree(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getFirstChild();
    AddMethod_getFirstChild1();
    AddMethod_getLastChild();
    AddMethod_getLastChild1();
    AddMethod_findFirstLeaf();
    AddMethod_findFirstLeaf1();
    AddMethod_findLastLeaf();
    AddMethod_findLastLeaf1();
    AddMethod_getChildren();
    AddMethod_getChildren1();
    AddMethod_findChild();
    AddMethod_findChild1();
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::Tree>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Tree"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Tree

using Entity_clang_syntax_Tree = Bind_clang_syntax_Tree<>;

#else

struct Entity_clang_syntax_Tree : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Tree(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Tree"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Tree

template <class Pybind11T =
              pybind11::class_<clang::syntax::Tree::ChildIterator>>
struct Bind_clang_syntax_Tree_ChildIterator : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_syntax_Tree_ChildIterator(EntityScope parent_h)
      : handle{parent_h, "ChildIterator", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// child_iterator is not invalidated by mutations.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Tree_ChildIterator(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::Tree::ChildIterator>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Tree_ChildIterator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Tree_ChildIterator

using Entity_clang_syntax_Tree_ChildIterator =
    Bind_clang_syntax_Tree_ChildIterator<>;

#else

struct Entity_clang_syntax_Tree_ChildIterator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Tree_ChildIterator(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Tree_ChildIterator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Tree_ChildIterator

template <class Pybind11T =
              pybind11::class_<clang::syntax::Tree::ConstChildIterator>>
struct Bind_clang_syntax_Tree_ConstChildIterator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_ConstChildIterator_Ctor0
    handle.def(pybind11::init<>());
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Tree_ConstChildIterator_Ctor1
    handle.def(pybind11::init<const clang::syntax::Tree::ChildIterator &>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Tree_ConstChildIterator(EntityScope parent_h)
      : handle{parent_h, "ConstChildIterator", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Tree_ConstChildIterator(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Tree_ConstChildIterator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Tree_ConstChildIterator

using Entity_clang_syntax_Tree_ConstChildIterator =
    Bind_clang_syntax_Tree_ConstChildIterator<>;

#else

struct Entity_clang_syntax_Tree_ConstChildIterator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Tree_ConstChildIterator(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Tree_ConstChildIterator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Tree_ConstChildIterator

template <class Pybind11T = pybind11::class_<
              clang::syntax::UnaryOperatorExpression,
              std::unique_ptr<clang::syntax::UnaryOperatorExpression,
                              pybind11::nodelete>>>
struct Bind_clang_syntax_UnaryOperatorExpression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnaryOperatorExpression_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UnaryOperatorExpression &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UnaryOperatorExpression::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOperatorToken() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnaryOperatorExpression_getOperatorToken
    handle.def("getOperatorToken", [](clang::syntax::UnaryOperatorExpression
                                          &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::UnaryOperatorExpression,
                                      clang::syntax::Leaf *>::type>(
              &clang::syntax::UnaryOperatorExpression::getOperatorToken),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOperand() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnaryOperatorExpression_getOperand
    handle.def("getOperand", [](clang::syntax::UnaryOperatorExpression &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::UnaryOperatorExpression,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::UnaryOperatorExpression::getOperand),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An abstract class for prefix and postfix unary operators.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnaryOperatorExpression_Ctor0
    handle.def(pybind11::init<clang::syntax::NodeKind>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UnaryOperatorExpression(EntityScope parent_h)
      : handle{parent_h, "UnaryOperatorExpression", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An abstract class for prefix and postfix unary operators.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UnaryOperatorExpression(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getOperatorToken();
    AddMethod_getOperand();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UnaryOperatorExpression"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UnaryOperatorExpression

using Entity_clang_syntax_UnaryOperatorExpression =
    Bind_clang_syntax_UnaryOperatorExpression<>;

#else

struct Entity_clang_syntax_UnaryOperatorExpression
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UnaryOperatorExpression(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UnaryOperatorExpression"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UnaryOperatorExpression

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::UnknownExpression,
        std::unique_ptr<clang::syntax::UnknownExpression, pybind11::nodelete>>>
struct Bind_clang_syntax_UnknownExpression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnknownExpression_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UnknownExpression &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UnknownExpression::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An expression of an unknown kind, i.e. one not currently handled by the
/// syntax tree.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnknownExpression_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UnknownExpression(EntityScope parent_h)
      : handle{
            parent_h, "UnknownExpression", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An expression of an unknown kind, i.e. one not currently handled by the
/// syntax tree.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UnknownExpression(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UnknownExpression"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UnknownExpression

using Entity_clang_syntax_UnknownExpression =
    Bind_clang_syntax_UnknownExpression<>;

#else

struct Entity_clang_syntax_UnknownExpression
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UnknownExpression(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UnknownExpression"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UnknownExpression

template <class Pybind11T = pybind11::class_<
              clang::syntax::UnqualifiedId,
              std::unique_ptr<clang::syntax::UnqualifiedId, pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_UnqualifiedId : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnqualifiedId_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UnqualifiedId &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UnqualifiedId::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Models an `unqualified-id`. C++ [expr.prim.id.unqual]
/// e.g. the `size` in `std::vector<int>::size`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnqualifiedId_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UnqualifiedId(EntityScope parent_h)
      : handle{
            parent_h, "UnqualifiedId", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Models an `unqualified-id`. C++ [expr.prim.id.unqual]
/// e.g. the `size` in `std::vector<int>::size`.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UnqualifiedId(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UnqualifiedId"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UnqualifiedId

using Entity_clang_syntax_UnqualifiedId = Bind_clang_syntax_UnqualifiedId<>;

#else

struct Entity_clang_syntax_UnqualifiedId
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UnqualifiedId(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UnqualifiedId"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UnqualifiedId

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildSyntaxTree : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Build a syntax tree for the main file.
/// This usually covers the whole TranslationUnitDecl, but can be restricted by
/// the ASTContext's traversal scope.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildSyntaxTree_AddFunction
    handle.def(
        "buildSyntaxTree",
        [](clang::syntax::Arena &A,
           clang::syntax::TokenBufferTokenManager &TBTM,
           clang::ASTContext &Context) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::syntax::TranslationUnit *(
                            clang::syntax::Arena &,
                            clang::syntax::TokenBufferTokenManager &,
                            clang::ASTContext &)>::type>(
                  &clang::syntax::buildSyntaxTree),
              A, TBTM, Context);
          return pybind11_weaver::WrapP<clang::syntax::TranslationUnit *>(
              __ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildSyntaxTree(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildSyntaxTree(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildSyntaxTree"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildSyntaxTree

using Entity_buildSyntaxTree = Bind_buildSyntaxTree<>;

#else

struct Entity_buildSyntaxTree : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildSyntaxTree(EntityScope parent_h) {}
  static const char *Key() { return "buildSyntaxTree"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildSyntaxTree

template <class Pybind11T = pybind11::module_ &>
struct Bind_computeReplacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Computes textual replacements required to mimic the tree modifications made
/// to the syntax tree.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_computeReplacements_AddFunction
    handle.def("computeReplacements",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::Replacements(
                             const clang::syntax::TokenBufferTokenManager &,
                             const clang::syntax::TranslationUnit &)>::type>(
                   &clang::syntax::computeReplacements),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_computeReplacements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_computeReplacements(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "computeReplacements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_computeReplacements

using Entity_computeReplacements = Bind_computeReplacements<>;

#else

struct Entity_computeReplacements : public pybind11_weaver::DisabledEntity {
  explicit Entity_computeReplacements(EntityScope parent_h) {}
  static const char *Key() { return "computeReplacements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_computeReplacements

template <class Pybind11T = pybind11::module_ &>
struct Bind_createEmptyStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Synthesis of Syntax Nodes)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_createEmptyStatement_AddFunction
    handle.def(
        "createEmptyStatement",
        [](clang::syntax::Arena &A,
           clang::syntax::TokenBufferTokenManager &TBTM) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::syntax::EmptyStatement *(
                            clang::syntax::Arena &,
                            clang::syntax::TokenBufferTokenManager &)>::type>(
                  &clang::syntax::createEmptyStatement),
              A, TBTM);
          return pybind11_weaver::WrapP<clang::syntax::EmptyStatement *>(
              __ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createEmptyStatement(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createEmptyStatement(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createEmptyStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createEmptyStatement

using Entity_createEmptyStatement = Bind_createEmptyStatement<>;

#else

struct Entity_createEmptyStatement : public pybind11_weaver::DisabledEntity {
  explicit Entity_createEmptyStatement(EntityScope parent_h) {}
  static const char *Key() { return "createEmptyStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createEmptyStatement

template <class Pybind11T = pybind11::module_ &>
struct Bind_createLeaf1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Infer the token spelling from its `TokenKind`, then create `Leaf` from
/// this token)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_createLeaf1_AddFunction
    handle.def(
        "createLeaf",
        [](clang::syntax::Arena &A,
           clang::syntax::TokenBufferTokenManager &TBTM,
           clang::tok::TokenKind K) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::syntax::Leaf *(
                            clang::syntax::Arena &,
                            clang::syntax::TokenBufferTokenManager &,
                            clang::tok::TokenKind)>::type>(
                  &clang::syntax::createLeaf),
              A, TBTM, K);
          return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createLeaf1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createLeaf1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createLeaf1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createLeaf1

using Entity_createLeaf1 = Bind_createLeaf1<>;

#else

struct Entity_createLeaf1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_createLeaf1(EntityScope parent_h) {}
  static const char *Key() { return "createLeaf1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createLeaf1

template <class Pybind11T = pybind11::module_ &>
struct Bind_createLeaf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(// Synthesis of Leafs
/// Create `Leaf` from token with `Spelling` and assert it has the desired
/// `TokenKind`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_createLeaf_AddFunction
    handle.def(
        "createLeaf",
        [](clang::syntax::Arena &A,
           clang::syntax::TokenBufferTokenManager &TBTM,
           clang::tok::TokenKind K, llvm::StringRef Spelling) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::syntax::Leaf *(
                            clang::syntax::Arena &,
                            clang::syntax::TokenBufferTokenManager &,
                            clang::tok::TokenKind, llvm::StringRef)>::type>(
                  &clang::syntax::createLeaf),
              A, TBTM, K, Spelling);
          return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createLeaf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createLeaf(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createLeaf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createLeaf

using Entity_createLeaf = Bind_createLeaf<>;

#else

struct Entity_createLeaf : public pybind11_weaver::DisabledEntity {
  explicit Entity_createLeaf(EntityScope parent_h) {}
  static const char *Key() { return "createLeaf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createLeaf

template <class Pybind11T = pybind11::module_ &>
struct Bind_createTree : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(// Synthesis of Trees
/// Creates the concrete syntax node according to the specified `NodeKind` `K`.
/// Returns it as a pointer to the base class `Tree`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_createTree_AddFunction
    handle.def(
        "createTree",
        [](clang::syntax::Arena &A,
           llvm::ArrayRef<
               std::pair<clang::syntax::Node *, clang::syntax::NodeRole>>
               Children,
           clang::syntax::NodeKind K) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::syntax::Tree *(
                            clang::syntax::Arena &,
                            llvm::ArrayRef<std::pair<clang::syntax::Node *,
                                                     clang::syntax::NodeRole>>,
                            clang::syntax::NodeKind)>::type>(
                  &clang::syntax::createTree),
              A, Children, K);
          return pybind11_weaver::WrapP<clang::syntax::Tree *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createTree(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createTree(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createTree"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createTree

using Entity_createTree = Bind_createTree<>;

#else

struct Entity_createTree : public pybind11_weaver::DisabledEntity {
  explicit Entity_createTree(EntityScope parent_h) {}
  static const char *Key() { return "createTree"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createTree

template <class Pybind11T = pybind11::module_ &>
struct Bind_deepCopyExpandingMacros : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Creates a completely independent copy of `N` with its macros expanded.
///
/// The copy is:
/// * Detached, i.e. `Parent == NextSibling == nullptr` and
/// `Role == Detached`.
/// * Synthesized, i.e. `Original == false`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_deepCopyExpandingMacros_AddFunction
    handle.def(
        "deepCopyExpandingMacros",
        [](clang::syntax::Arena &A,
           clang::syntax::TokenBufferTokenManager &TBTM,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::syntax::Node *(
                            clang::syntax::Arena &,
                            clang::syntax::TokenBufferTokenManager &,
                            const clang::syntax::Node *)>::type>(
                  &clang::syntax::deepCopyExpandingMacros),
              A, TBTM, (N)->Cptr());
          return pybind11_weaver::WrapP<clang::syntax::Node *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_deepCopyExpandingMacros(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_deepCopyExpandingMacros(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "deepCopyExpandingMacros"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_deepCopyExpandingMacros

using Entity_deepCopyExpandingMacros = Bind_deepCopyExpandingMacros<>;

#else

struct Entity_deepCopyExpandingMacros : public pybind11_weaver::DisabledEntity {
  explicit Entity_deepCopyExpandingMacros(EntityScope parent_h) {}
  static const char *Key() { return "deepCopyExpandingMacros"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_deepCopyExpandingMacros

template <class Pybind11T = pybind11::module_ &>
struct Bind_removeStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Removes a statement or replaces it with an empty statement where one is
/// required syntactically. E.g., in the following example:
///     if (cond) { foo(); } else bar();
/// One can remove `foo();` completely and to remove `bar();` we would need to
/// replace it with an empty statement.
/// EXPECTS: S->canModify() == true)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_removeStatement_AddFunction
    handle.def(
        "removeStatement",
        [](clang::syntax::Arena &A,
           clang::syntax::TokenBufferTokenManager &TBTM,
           pybind11_weaver::WrappedPtrT<clang::syntax::Statement *> S) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(clang::syntax::Arena &,
                             clang::syntax::TokenBufferTokenManager &,
                             clang::syntax::Statement *)>::type>(
                  &clang::syntax::removeStatement),
              A, TBTM, (S)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_removeStatement(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_removeStatement(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "removeStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_removeStatement

using Entity_removeStatement = Bind_removeStatement<>;

#else

struct Entity_removeStatement : public pybind11_weaver::DisabledEntity {
  explicit Entity_removeStatement(EntityScope parent_h) {}
  static const char *Key() { return "removeStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_removeStatement

template <class Pybind11T = pybind11::module_ &>
struct Bind_spelledIdentifierTouching1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_spelledIdentifierTouching1_AddFunction
    handle.def("spelledIdentifierTouching",
               static_cast<pybind11_weaver::FnPtrT<
                   void, const clang::syntax::Token *(
                             clang::SourceLocation,
                             const clang::syntax::TokenBuffer &)>::type>(
                   &clang::syntax::spelledIdentifierTouching));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_spelledIdentifierTouching1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_spelledIdentifierTouching1(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "spelledIdentifierTouching1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_spelledIdentifierTouching1

using Entity_spelledIdentifierTouching1 = Bind_spelledIdentifierTouching1<>;

#else

struct Entity_spelledIdentifierTouching1
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_spelledIdentifierTouching1(EntityScope parent_h) {}
  static const char *Key() { return "spelledIdentifierTouching1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_spelledIdentifierTouching1

template <class Pybind11T = pybind11::module_ &>
struct Bind_spelledIdentifierTouching : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The identifier token that overlaps or touches a spelling location Loc.
/// If there is none, returns nullptr.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_spelledIdentifierTouching_AddFunction
    handle.def("spelledIdentifierTouching",
               static_cast<pybind11_weaver::FnPtrT<
                   void, const clang::syntax::Token *(
                             clang::SourceLocation,
                             llvm::ArrayRef<clang::syntax::Token>)>::type>(
                   &clang::syntax::spelledIdentifierTouching),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_spelledIdentifierTouching(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_spelledIdentifierTouching(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "spelledIdentifierTouching"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_spelledIdentifierTouching

using Entity_spelledIdentifierTouching = Bind_spelledIdentifierTouching<>;

#else

struct Entity_spelledIdentifierTouching
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_spelledIdentifierTouching(EntityScope parent_h) {}
  static const char *Key() { return "spelledIdentifierTouching"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_spelledIdentifierTouching

template <class Pybind11T = pybind11::module_ &>
struct Bind_spelledTokensTouching : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The spelled tokens that overlap or touch a spelling location Loc.
/// This always returns 0-2 tokens.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_spelledTokensTouching_AddFunction
    handle.def("spelledTokensTouching",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::ArrayRef<clang::syntax::Token>(
                             clang::SourceLocation,
                             const clang::syntax::TokenBuffer &)>::type>(
                   &clang::syntax::spelledTokensTouching),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_spelledTokensTouching(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_spelledTokensTouching(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "spelledTokensTouching"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_spelledTokensTouching

using Entity_spelledTokensTouching = Bind_spelledTokensTouching<>;

#else

struct Entity_spelledTokensTouching : public pybind11_weaver::DisabledEntity {
  explicit Entity_spelledTokensTouching(EntityScope parent_h) {}
  static const char *Key() { return "spelledTokensTouching"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_spelledTokensTouching

template <class Pybind11T = pybind11::module_ &>
struct Bind_spelledTokensTouching1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_spelledTokensTouching1_AddFunction
    handle.def("spelledTokensTouching",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::ArrayRef<clang::syntax::Token>(
                             clang::SourceLocation,
                             llvm::ArrayRef<clang::syntax::Token>)>::type>(
                   &clang::syntax::spelledTokensTouching));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_spelledTokensTouching1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_spelledTokensTouching1(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "spelledTokensTouching1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_spelledTokensTouching1

using Entity_spelledTokensTouching1 = Bind_spelledTokensTouching1<>;

#else

struct Entity_spelledTokensTouching1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_spelledTokensTouching1(EntityScope parent_h) {}
  static const char *Key() { return "spelledTokensTouching1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_spelledTokensTouching1

template <class Pybind11T = pybind11::module_ &>
struct Bind_tokenize : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Lex the text buffer, corresponding to \p FID, in raw mode and record the
/// resulting spelled tokens. Does minimal post-processing on raw identifiers,
/// setting the appropriate token kind (instead of the raw_identifier reported
/// by lexer in raw mode). This is a very low-level function, most users should
/// prefer to use TokenCollector. Lexing in raw mode produces wildly different
/// results from what one might expect when running a C++ frontend, e.g.
/// preprocessor does not run at all.
/// The result will *not* have a 'eof' token at the end.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_tokenize_AddFunction
    handle.def("tokenize",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::vector<clang::syntax::Token>(
                             clang::FileID, const clang::SourceManager &,
                             const clang::LangOptions &)>::type>(
                   &clang::syntax::tokenize),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_tokenize(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_tokenize(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "tokenize"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_tokenize

using Entity_tokenize = Bind_tokenize<>;

#else

struct Entity_tokenize : public pybind11_weaver::DisabledEntity {
  explicit Entity_tokenize(EntityScope parent_h) {}
  static const char *Key() { return "tokenize"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_tokenize

template <class Pybind11T = pybind11::module_ &>
struct Bind_tokenize1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Similar to one above, instead of whole file tokenizes a part of it. Note
/// that, the first token might be incomplete if FR.startOffset is not at the
/// beginning of a token, and the last token returned will start before the
/// FR.endOffset but might end after it.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_tokenize1_AddFunction
    handle.def(
        "tokenize",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::vector<clang::syntax::Token>(
                const clang::syntax::FileRange &, const clang::SourceManager &,
                const clang::LangOptions &)>::type>(&clang::syntax::tokenize),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_tokenize1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_tokenize1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "tokenize1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_tokenize1

using Entity_tokenize1 = Bind_tokenize1<>;

#else

struct Entity_tokenize1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_tokenize1(EntityScope parent_h) {}
  static const char *Key() { return "tokenize1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_tokenize1

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::ArraySubscript,
        std::unique_ptr<clang::syntax::ArraySubscript, pybind11::nodelete>,
        clang::syntax::Tree>>
struct Bind_clang_syntax_ArraySubscript : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ArraySubscript_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ArraySubscript &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ArraySubscript::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLbracket() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// TODO: add an accessor for the "static" keyword.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ArraySubscript_getLbracket
    handle.def(
        "getLbracket",
        [](clang::syntax::ArraySubscript &self) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<clang::syntax::ArraySubscript,
                                                  clang::syntax::Leaf *>::type>(
                  &clang::syntax::ArraySubscript::getLbracket),
              &self);
          return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSize() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ArraySubscript_getSize
    handle.def("getSize", [](clang::syntax::ArraySubscript &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::ArraySubscript,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::ArraySubscript::getSize),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRbracket() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ArraySubscript_getRbracket
    handle.def("getRbracket", [](clang::syntax::ArraySubscript &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::ArraySubscript,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::ArraySubscript::getRbracket),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Array size specified inside a declarator.
/// E.g:
///   `[10]` in `int a[10];`
///   `[static 10]` in `void f(int xs[static 10]);`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ArraySubscript_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ArraySubscript(EntityScope parent_h)
      : handle{parent_h, "ArraySubscript", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Array size specified inside a declarator.
/// E.g:
///   `[10]` in `int a[10];`
///   `[static 10]` in `void f(int xs[static 10]);`)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ArraySubscript(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getLbracket();
    AddMethod_getSize();
    AddMethod_getRbracket();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ArraySubscript"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ArraySubscript

using Entity_clang_syntax_ArraySubscript = Bind_clang_syntax_ArraySubscript<>;

#else

struct Entity_clang_syntax_ArraySubscript
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ArraySubscript(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ArraySubscript"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ArraySubscript

template <class Pybind11T = pybind11::class_<
              clang::syntax::Declaration,
              std::unique_ptr<clang::syntax::Declaration, pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_Declaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Declaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::Declaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::Declaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A declaration that can appear at the top-level. Note that this does *not*
/// correspond 1-to-1 to clang::Decl. Syntax trees distinguish between top-level
/// declarations (e.g. namespace definitions) and declarators (e.g. variables,
/// typedefs, etc.). Declarators are stored inside SimpleDeclaration.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Declaration_Ctor0
    handle.def(pybind11::init<clang::syntax::NodeKind>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Declaration(EntityScope parent_h)
      : handle{parent_h, "Declaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A declaration that can appear at the top-level. Note that this does *not*
/// correspond 1-to-1 to clang::Decl. Syntax trees distinguish between top-level
/// declarations (e.g. namespace definitions) and declarators (e.g. variables,
/// typedefs, etc.). Declarators are stored inside SimpleDeclaration.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Declaration(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Declaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Declaration

using Entity_clang_syntax_Declaration = Bind_clang_syntax_Declaration<>;

#else

struct Entity_clang_syntax_Declaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Declaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Declaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Declaration

template <class Pybind11T = pybind11::class_<
              clang::syntax::Declarator,
              std::unique_ptr<clang::syntax::Declarator, pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_Declarator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Declarator_classof
    handle.def_static(
        "classof",
        [](clang::syntax::Declarator &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::Declarator::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Covers a name, an initializer and a part of the type outside declaration
/// specifiers. Examples are:
///     `*a` in `int *a`
///     `a[10]` in `int a[10]`
///     `*a = nullptr` in `int *a = nullptr`
/// Declarators can be unnamed too:
///     `**` in `new int**`
///     `* = nullptr` in `void foo(int* = nullptr)`
/// Most declarators you encounter are instances of SimpleDeclarator. They may
/// contain an inner declarator inside parentheses, we represent it as
/// ParenDeclarator. E.g.
///     `(*a)` in `int (*a) = 10`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Declarator_Ctor0
    handle.def(pybind11::init<clang::syntax::NodeKind>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Declarator(EntityScope parent_h)
      : handle{
            parent_h, "Declarator", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Covers a name, an initializer and a part of the type outside declaration
/// specifiers. Examples are:
///     `*a` in `int *a`
///     `a[10]` in `int a[10]`
///     `*a = nullptr` in `int *a = nullptr`
/// Declarators can be unnamed too:
///     `**` in `new int**`
///     `* = nullptr` in `void foo(int* = nullptr)`
/// Most declarators you encounter are instances of SimpleDeclarator. They may
/// contain an inner declarator inside parentheses, we represent it as
/// ParenDeclarator. E.g.
///     `(*a)` in `int (*a) = 10`)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Declarator(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Declarator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Declarator

using Entity_clang_syntax_Declarator = Bind_clang_syntax_Declarator<>;

#else

struct Entity_clang_syntax_Declarator : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Declarator(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Declarator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Declarator

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::EmptyDeclaration,
        std::unique_ptr<clang::syntax::EmptyDeclaration, pybind11::nodelete>,
        clang::syntax::Declaration>>
struct Bind_clang_syntax_EmptyDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_EmptyDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::EmptyDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::EmptyDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A semicolon in the top-level context. Does not declare anything.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_EmptyDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_EmptyDeclaration(EntityScope parent_h)
      : handle{parent_h, "EmptyDeclaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A semicolon in the top-level context. Does not declare anything.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_EmptyDeclaration(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_EmptyDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_EmptyDeclaration

using Entity_clang_syntax_EmptyDeclaration =
    Bind_clang_syntax_EmptyDeclaration<>;

#else

struct Entity_clang_syntax_EmptyDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_EmptyDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_EmptyDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_EmptyDeclaration

template <class Pybind11T = pybind11::class_<
              clang::syntax::ExplicitTemplateInstantiation,
              std::unique_ptr<clang::syntax::ExplicitTemplateInstantiation,
                              pybind11::nodelete>,
              clang::syntax::Declaration>>
struct Bind_clang_syntax_ExplicitTemplateInstantiation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExplicitTemplateInstantiation_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ExplicitTemplateInstantiation &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ExplicitTemplateInstantiation::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTemplateKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExplicitTemplateInstantiation_getTemplateKeyword
    handle.def("getTemplateKeyword",
               [](clang::syntax::ExplicitTemplateInstantiation &self) {
                 auto &&__ret__ = std::invoke(
                     static_cast<pybind11_weaver::FnPtrT<
                         clang::syntax::ExplicitTemplateInstantiation,
                         clang::syntax::Leaf *>::type>(
                         &clang::syntax::ExplicitTemplateInstantiation::
                             getTemplateKeyword),
                     &self);
                 return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
               });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getExternKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExplicitTemplateInstantiation_getExternKeyword
    handle.def("getExternKeyword", [](clang::syntax::
                                          ExplicitTemplateInstantiation &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::ExplicitTemplateInstantiation,
              clang::syntax::Leaf *>::type>(
              &clang::syntax::ExplicitTemplateInstantiation::getExternKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDeclaration() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExplicitTemplateInstantiation_getDeclaration
    handle.def("getDeclaration", [](clang::syntax::ExplicitTemplateInstantiation
                                        &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::ExplicitTemplateInstantiation,
              clang::syntax::Declaration *>::type>(
              &clang::syntax::ExplicitTemplateInstantiation::getDeclaration),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Declaration *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// template <declaration>
/// Examples:
///     template struct X<int>
///     template void foo<int>()
///     template int var<double>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExplicitTemplateInstantiation_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ExplicitTemplateInstantiation(EntityScope parent_h)
      : handle{parent_h, "ExplicitTemplateInstantiation",
               pybind11::dynamic_attr(),
               R"_pb11_weaver(/// template <declaration>
/// Examples:
///     template struct X<int>
///     template void foo<int>()
///     template int var<double>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ExplicitTemplateInstantiation(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getTemplateKeyword();
    AddMethod_getExternKeyword();
    AddMethod_getDeclaration();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_syntax_ExplicitTemplateInstantiation";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ExplicitTemplateInstantiation

using Entity_clang_syntax_ExplicitTemplateInstantiation =
    Bind_clang_syntax_ExplicitTemplateInstantiation<>;

#else

struct Entity_clang_syntax_ExplicitTemplateInstantiation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ExplicitTemplateInstantiation(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_syntax_ExplicitTemplateInstantiation";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ExplicitTemplateInstantiation

template <class Pybind11T = pybind11::class_<
              clang::syntax::Leaf,
              std::unique_ptr<clang::syntax::Leaf, pybind11::nodelete>,
              clang::syntax::Node>>
struct Bind_clang_syntax_Leaf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Leaf_classof
    handle.def_static(
        "classof",
        [](clang::syntax::Leaf &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::Leaf::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTokenKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Leaf_getTokenKey
    handle.def("getTokenKey",
               static_cast<pybind11_weaver::FnPtrT<clang::syntax::Leaf,
                                                   unsigned long>::const_type>(
                   &clang::syntax::Leaf::getTokenKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A leaf node points to a single token.
// FIXME: add TokenKind field (borrow some bits from the Node::kind).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Leaf_Ctor0
    handle.def(pybind11::init<unsigned long>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Leaf(EntityScope parent_h)
      : handle{parent_h, "Leaf", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A leaf node points to a single token.
// FIXME: add TokenKind field (borrow some bits from the Node::kind).)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Leaf(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getTokenKey();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Leaf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Leaf

using Entity_clang_syntax_Leaf = Bind_clang_syntax_Leaf<>;

#else

struct Entity_clang_syntax_Leaf : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Leaf(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Leaf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Leaf

template <class Pybind11T = pybind11::class_<
              clang::syntax::LinkageSpecificationDeclaration,
              std::unique_ptr<clang::syntax::LinkageSpecificationDeclaration,
                              pybind11::nodelete>,
              clang::syntax::Declaration>>
struct Bind_clang_syntax_LinkageSpecificationDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_LinkageSpecificationDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::LinkageSpecificationDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::LinkageSpecificationDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// extern <string-literal> declaration
/// extern <string-literal> { <decls>  })_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_LinkageSpecificationDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_LinkageSpecificationDeclaration(
      EntityScope parent_h)
      : handle{parent_h, "LinkageSpecificationDeclaration",
               pybind11::dynamic_attr(),
               R"_pb11_weaver(/// extern <string-literal> declaration
/// extern <string-literal> { <decls>  })_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_LinkageSpecificationDeclaration(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_syntax_LinkageSpecificationDeclaration";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_LinkageSpecificationDeclaration

using Entity_clang_syntax_LinkageSpecificationDeclaration =
    Bind_clang_syntax_LinkageSpecificationDeclaration<>;

#else

struct Entity_clang_syntax_LinkageSpecificationDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_LinkageSpecificationDeclaration(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_syntax_LinkageSpecificationDeclaration";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_LinkageSpecificationDeclaration

template <class Pybind11T = pybind11::class_<
              clang::syntax::List,
              std::unique_ptr<clang::syntax::List, pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_List : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_List_classof
    handle.def_static(
        "classof",
        [](clang::syntax::List &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::List::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getElementsAsNodesAndDelimiters() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the elements and corresponding delimiters. Missing elements
  /// and delimiters are represented as null pointers.
  ///
  /// For example, in a separated list:
  /// "a, b, c"  <=> [("a" , ","), ("b" , "," ), ("c" , null)]
  /// "a,  , c"  <=> [("a" , ","), (null, "," ), ("c" , null)]
  /// "a, b  c"  <=> [("a" , ","), ("b" , null), ("c" , null)]
  /// "a, b,"    <=> [("a" , ","), ("b" , "," ), (null, null)]
  ///
  /// In a terminated or maybe-terminated list:
  /// "a; b; c;" <=> [("a" , ";"), ("b" , ";" ), ("c" , ";" )]
  /// "a;  ; c;" <=> [("a" , ";"), (null, ";" ), ("c" , ";" )]
  /// "a; b  c;" <=> [("a" , ";"), ("b" , null), ("c" , ";" )]
  /// "a; b; c"  <=> [("a" , ";"), ("b" , ";" ), ("c" , null)])_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_List_getElementsAsNodesAndDelimiters
    handle.def("getElementsAsNodesAndDelimiters",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::List,
                   std::vector<clang::syntax::List::ElementAndDelimiter<
                       clang::syntax::Node>>>::type>(
                   &clang::syntax::List::getElementsAsNodesAndDelimiters),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getElementsAsNodes() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the elements of the list. Missing elements are represented
  /// as null pointers in the same way as in the return value of
  /// `getElementsAsNodesAndDelimiters()`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_List_getElementsAsNodes
    handle.def(
        "getElementsAsNodes",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::List, std::vector<clang::syntax::Node *>>::type>(
            &clang::syntax::List::getElementsAsNodes),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDelimiterTokenKind() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the appropriate delimiter for this list.
  ///
  /// Useful for discovering the correct delimiter to use when adding
  /// elements to empty or one-element lists.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_List_getDelimiterTokenKind
    handle.def(
        "getDelimiterTokenKind",
        static_cast<pybind11_weaver::FnPtrT<clang::syntax::List,
                                            clang::tok::TokenKind>::const_type>(
            &clang::syntax::List::getDelimiterTokenKind),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTerminationKind() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_List_getTerminationKind
    handle.def("getTerminationKind",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::List,
                   clang::syntax::List::TerminationKind>::const_type>(
                   &clang::syntax::List::getTerminationKind));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_canBeEmpty() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Whether this list can be empty in syntactically and semantically correct
  /// code.
  ///
  /// This list may be empty when the source code has errors even if
  /// canBeEmpty() returns false.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_List_canBeEmpty
    handle.def(
        "canBeEmpty",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::List, bool>::const_type>(
            &clang::syntax::List::canBeEmpty),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_List(EntityScope parent_h)
      : handle{
            parent_h, "List", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A list of Elements separated or terminated by a fixed token.
///
/// This type models the following grammar construct:
/// delimited-list(element, delimiter, termination, canBeEmpty))_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_List(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getElementsAsNodesAndDelimiters();
    AddMethod_getElementsAsNodes();
    AddMethod_getDelimiterTokenKind();
    AddMethod_getTerminationKind();
    AddMethod_canBeEmpty();
    pybind11_weaver::TryAddDefaultCtor<clang::syntax::List>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_List"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_List

using Entity_clang_syntax_List = Bind_clang_syntax_List<>;

#else

struct Entity_clang_syntax_List : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_List(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_List"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_List

template <class Pybind11T =
              pybind11::enum_<clang::syntax::List::TerminationKind>>
struct Bind_clang_syntax_List_TerminationKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_syntax_List_TerminationKind(EntityScope parent_h)
      : handle{parent_h, "TerminationKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_List_TerminationKind(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Terminated",
                 clang::syntax::List::TerminationKind::Terminated);
    handle.value("MaybeTerminated",
                 clang::syntax::List::TerminationKind::MaybeTerminated);
    handle.value("Separated", clang::syntax::List::TerminationKind::Separated);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_List_TerminationKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_List_TerminationKind

using Entity_clang_syntax_List_TerminationKind =
    Bind_clang_syntax_List_TerminationKind<>;

#else

struct Entity_clang_syntax_List_TerminationKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_List_TerminationKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_List_TerminationKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_List_TerminationKind

template <class Pybind11T = pybind11::class_<
              clang::syntax::MemberPointer,
              std::unique_ptr<clang::syntax::MemberPointer, pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_MemberPointer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_MemberPointer_classof
    handle.def_static(
        "classof",
        [](clang::syntax::MemberPointer &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::MemberPointer::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Member pointer inside a declarator
/// E.g. `X::*` in `int X::* a = 0;`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_MemberPointer_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_MemberPointer(EntityScope parent_h)
      : handle{parent_h, "MemberPointer", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Member pointer inside a declarator
/// E.g. `X::*` in `int X::* a = 0;`)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_MemberPointer(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_MemberPointer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_MemberPointer

using Entity_clang_syntax_MemberPointer = Bind_clang_syntax_MemberPointer<>;

#else

struct Entity_clang_syntax_MemberPointer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_MemberPointer(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_MemberPointer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_MemberPointer

template <class Pybind11T = pybind11::class_<
              clang::syntax::NamespaceAliasDefinition,
              std::unique_ptr<clang::syntax::NamespaceAliasDefinition,
                              pybind11::nodelete>,
              clang::syntax::Declaration>>
struct Bind_clang_syntax_NamespaceAliasDefinition : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NamespaceAliasDefinition_classof
    handle.def_static(
        "classof",
        [](clang::syntax::NamespaceAliasDefinition &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::NamespaceAliasDefinition::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// namespace <name> = <namespace-reference>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NamespaceAliasDefinition_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_NamespaceAliasDefinition(EntityScope parent_h)
      : handle{parent_h, "NamespaceAliasDefinition", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// namespace <name> = <namespace-reference>)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_NamespaceAliasDefinition(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_NamespaceAliasDefinition"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_NamespaceAliasDefinition

using Entity_clang_syntax_NamespaceAliasDefinition =
    Bind_clang_syntax_NamespaceAliasDefinition<>;

#else

struct Entity_clang_syntax_NamespaceAliasDefinition
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_NamespaceAliasDefinition(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_NamespaceAliasDefinition"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_NamespaceAliasDefinition

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::NamespaceDefinition,
        std::unique_ptr<clang::syntax::NamespaceDefinition, pybind11::nodelete>,
        clang::syntax::Declaration>>
struct Bind_clang_syntax_NamespaceDefinition : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NamespaceDefinition_classof
    handle.def_static(
        "classof",
        [](clang::syntax::NamespaceDefinition &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::NamespaceDefinition::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// namespace <name> { <decls> })_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NamespaceDefinition_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_NamespaceDefinition(EntityScope parent_h)
      : handle{parent_h, "NamespaceDefinition", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// namespace <name> { <decls> })_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_NamespaceDefinition(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_NamespaceDefinition"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_NamespaceDefinition

using Entity_clang_syntax_NamespaceDefinition =
    Bind_clang_syntax_NamespaceDefinition<>;

#else

struct Entity_clang_syntax_NamespaceDefinition
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_NamespaceDefinition(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_NamespaceDefinition"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_NamespaceDefinition

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::NestedNameSpecifier,
        std::unique_ptr<clang::syntax::NestedNameSpecifier, pybind11::nodelete>,
        clang::syntax::List>>
struct Bind_clang_syntax_NestedNameSpecifier : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NestedNameSpecifier_classof
    handle.def_static(
        "classof",
        [](clang::syntax::NestedNameSpecifier &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::NestedNameSpecifier::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSpecifiers() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NestedNameSpecifier_getSpecifiers
    handle.def("getSpecifiers",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::NestedNameSpecifier,
                   std::vector<clang::syntax::NameSpecifier *>>::type>(
                   &clang::syntax::NestedNameSpecifier::getSpecifiers));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSpecifiersAndDoubleColons() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NestedNameSpecifier_getSpecifiersAndDoubleColons
    handle.def(
        "getSpecifiersAndDoubleColons",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::NestedNameSpecifier,
            std::vector<clang::syntax::List::ElementAndDelimiter<
                clang::syntax::NameSpecifier>>>::type>(
            &clang::syntax::NestedNameSpecifier::getSpecifiersAndDoubleColons));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Models a `nested-name-specifier`. C++ [expr.prim.id.qual]
/// e.g. the `std::vector<int>::` in `std::vector<int>::size`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_NestedNameSpecifier_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_NestedNameSpecifier(EntityScope parent_h)
      : handle{
            parent_h, "NestedNameSpecifier", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Models a `nested-name-specifier`. C++ [expr.prim.id.qual]
/// e.g. the `std::vector<int>::` in `std::vector<int>::size`.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_NestedNameSpecifier(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getSpecifiers();
    AddMethod_getSpecifiersAndDoubleColons();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_NestedNameSpecifier"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_NestedNameSpecifier

using Entity_clang_syntax_NestedNameSpecifier =
    Bind_clang_syntax_NestedNameSpecifier<>;

#else

struct Entity_clang_syntax_NestedNameSpecifier
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_NestedNameSpecifier(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_NestedNameSpecifier"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_NestedNameSpecifier

template <class Pybind11T = pybind11::class_<
              clang::syntax::ParameterDeclarationList,
              std::unique_ptr<clang::syntax::ParameterDeclarationList,
                              pybind11::nodelete>,
              clang::syntax::List>>
struct Bind_clang_syntax_ParameterDeclarationList : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParameterDeclarationList_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ParameterDeclarationList &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ParameterDeclarationList::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getParameterDeclarations() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParameterDeclarationList_getParameterDeclarations
    handle.def("getParameterDeclarations",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::ParameterDeclarationList,
                   std::vector<clang::syntax::SimpleDeclaration *>>::type>(
                   &clang::syntax::ParameterDeclarationList::
                       getParameterDeclarations));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getParametersAndCommas() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParameterDeclarationList_getParametersAndCommas
    handle.def(
        "getParametersAndCommas",
        static_cast<pybind11_weaver::FnPtrT<
            clang::syntax::ParameterDeclarationList,
            std::vector<clang::syntax::List::ElementAndDelimiter<
                clang::syntax::SimpleDeclaration>>>::type>(
            &clang::syntax::ParameterDeclarationList::getParametersAndCommas));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Models a `parameter-declaration-list` which appears within
/// `parameters-and-qualifiers`. See C++ [dcl.fct])_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParameterDeclarationList_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ParameterDeclarationList(EntityScope parent_h)
      : handle{
            parent_h, "ParameterDeclarationList", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Models a `parameter-declaration-list` which appears within
/// `parameters-and-qualifiers`. See C++ [dcl.fct])_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ParameterDeclarationList(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getParameterDeclarations();
    AddMethod_getParametersAndCommas();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ParameterDeclarationList"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ParameterDeclarationList

using Entity_clang_syntax_ParameterDeclarationList =
    Bind_clang_syntax_ParameterDeclarationList<>;

#else

struct Entity_clang_syntax_ParameterDeclarationList
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ParameterDeclarationList(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ParameterDeclarationList"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ParameterDeclarationList

template <class Pybind11T = pybind11::class_<
              clang::syntax::ParametersAndQualifiers,
              std::unique_ptr<clang::syntax::ParametersAndQualifiers,
                              pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_ParametersAndQualifiers : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParametersAndQualifiers_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ParametersAndQualifiers &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ParametersAndQualifiers::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLparen() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParametersAndQualifiers_getLparen
    handle.def("getLparen", [](clang::syntax::ParametersAndQualifiers &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::ParametersAndQualifiers,
                                      clang::syntax::Leaf *>::type>(
              &clang::syntax::ParametersAndQualifiers::getLparen),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getParameters() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParametersAndQualifiers_getParameters
    handle.def("getParameters", [](clang::syntax::ParametersAndQualifiers
                                       &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::ParametersAndQualifiers,
              clang::syntax::ParameterDeclarationList *>::type>(
              &clang::syntax::ParametersAndQualifiers::getParameters),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::ParameterDeclarationList *>(
          __ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRparen() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParametersAndQualifiers_getRparen
    handle.def("getRparen", [](clang::syntax::ParametersAndQualifiers &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::ParametersAndQualifiers,
                                      clang::syntax::Leaf *>::type>(
              &clang::syntax::ParametersAndQualifiers::getRparen),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTrailingReturn() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParametersAndQualifiers_getTrailingReturn
    handle.def(
        "getTrailingReturn", [](clang::syntax::ParametersAndQualifiers &self) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  clang::syntax::ParametersAndQualifiers,
                  clang::syntax::TrailingReturnType *>::type>(
                  &clang::syntax::ParametersAndQualifiers::getTrailingReturn),
              &self);
          return pybind11_weaver::WrapP<clang::syntax::TrailingReturnType *>(
              __ret__);
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Parameter list for a function type and a trailing return type, if the
/// function has one.
/// E.g.:
///  `(int a) volatile ` in `int foo(int a) volatile;`
///  `(int a) &&` in `int foo(int a) &&;`
///  `() -> int` in `auto foo() -> int;`
///  `() const` in `int foo() const;`
///  `() noexcept` in `int foo() noexcept;`
///  `() throw()` in `int foo() throw();`
///
/// (!) override doesn't belong here.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParametersAndQualifiers_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ParametersAndQualifiers(EntityScope parent_h)
      : handle{
            parent_h, "ParametersAndQualifiers", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Parameter list for a function type and a trailing return type, if the
/// function has one.
/// E.g.:
///  `(int a) volatile ` in `int foo(int a) volatile;`
///  `(int a) &&` in `int foo(int a) &&;`
///  `() -> int` in `auto foo() -> int;`
///  `() const` in `int foo() const;`
///  `() noexcept` in `int foo() noexcept;`
///  `() throw()` in `int foo() throw();`
///
/// (!) override doesn't belong here.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ParametersAndQualifiers(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getLparen();
    AddMethod_getParameters();
    AddMethod_getRparen();
    AddMethod_getTrailingReturn();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ParametersAndQualifiers"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ParametersAndQualifiers

using Entity_clang_syntax_ParametersAndQualifiers =
    Bind_clang_syntax_ParametersAndQualifiers<>;

#else

struct Entity_clang_syntax_ParametersAndQualifiers
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ParametersAndQualifiers(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ParametersAndQualifiers"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ParametersAndQualifiers

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::ParenDeclarator,
        std::unique_ptr<clang::syntax::ParenDeclarator, pybind11::nodelete>,
        clang::syntax::Declarator>>
struct Bind_clang_syntax_ParenDeclarator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParenDeclarator_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ParenDeclarator &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ParenDeclarator::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLparen() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParenDeclarator_getLparen
    handle.def("getLparen", [](clang::syntax::ParenDeclarator &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::ParenDeclarator,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::ParenDeclarator::getLparen),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRparen() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParenDeclarator_getRparen
    handle.def("getRparen", [](clang::syntax::ParenDeclarator &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::ParenDeclarator,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::ParenDeclarator::getRparen),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Declarator inside parentheses.
/// E.g. `(***a)` from `int (***a) = nullptr;`
/// See comment of Declarator for more details.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ParenDeclarator_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ParenDeclarator(EntityScope parent_h)
      : handle{parent_h, "ParenDeclarator", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Declarator inside parentheses.
/// E.g. `(***a)` from `int (***a) = nullptr;`
/// See comment of Declarator for more details.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ParenDeclarator(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getLparen();
    AddMethod_getRparen();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ParenDeclarator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ParenDeclarator

using Entity_clang_syntax_ParenDeclarator = Bind_clang_syntax_ParenDeclarator<>;

#else

struct Entity_clang_syntax_ParenDeclarator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ParenDeclarator(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ParenDeclarator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ParenDeclarator

template <class Pybind11T = pybind11::class_<
              clang::syntax::PostfixUnaryOperatorExpression,
              std::unique_ptr<clang::syntax::PostfixUnaryOperatorExpression,
                              pybind11::nodelete>,
              clang::syntax::UnaryOperatorExpression>>
struct Bind_clang_syntax_PostfixUnaryOperatorExpression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_PostfixUnaryOperatorExpression_classof
    handle.def_static(
        "classof",
        [](clang::syntax::PostfixUnaryOperatorExpression &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::PostfixUnaryOperatorExpression::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// <operand> <operator>
///
/// For example:
///   a++
///   b--)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_PostfixUnaryOperatorExpression_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_PostfixUnaryOperatorExpression(
      EntityScope parent_h)
      : handle{parent_h, "PostfixUnaryOperatorExpression",
               pybind11::dynamic_attr(), R"_pb11_weaver(/// <operand> <operator>
///
/// For example:
///   a++
///   b--)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_PostfixUnaryOperatorExpression(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_syntax_PostfixUnaryOperatorExpression";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_PostfixUnaryOperatorExpression

using Entity_clang_syntax_PostfixUnaryOperatorExpression =
    Bind_clang_syntax_PostfixUnaryOperatorExpression<>;

#else

struct Entity_clang_syntax_PostfixUnaryOperatorExpression
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_PostfixUnaryOperatorExpression(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_syntax_PostfixUnaryOperatorExpression";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_PostfixUnaryOperatorExpression

template <class Pybind11T = pybind11::class_<
              clang::syntax::PrefixUnaryOperatorExpression,
              std::unique_ptr<clang::syntax::PrefixUnaryOperatorExpression,
                              pybind11::nodelete>,
              clang::syntax::UnaryOperatorExpression>>
struct Bind_clang_syntax_PrefixUnaryOperatorExpression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_PrefixUnaryOperatorExpression_classof
    handle.def_static(
        "classof",
        [](clang::syntax::PrefixUnaryOperatorExpression &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::PrefixUnaryOperatorExpression::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// <operator> <operand>
///
/// For example:
///   +a          -b
///   !c          not c
///   ~d          compl d
///   *e          &f
///   ++h         --h
///   __real i    __imag i)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_PrefixUnaryOperatorExpression_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_PrefixUnaryOperatorExpression(EntityScope parent_h)
      : handle{parent_h, "PrefixUnaryOperatorExpression",
               pybind11::dynamic_attr(), R"_pb11_weaver(/// <operator> <operand>
///
/// For example:
///   +a          -b
///   !c          not c
///   ~d          compl d
///   *e          &f
///   ++h         --h
///   __real i    __imag i)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_PrefixUnaryOperatorExpression(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_syntax_PrefixUnaryOperatorExpression";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_PrefixUnaryOperatorExpression

using Entity_clang_syntax_PrefixUnaryOperatorExpression =
    Bind_clang_syntax_PrefixUnaryOperatorExpression<>;

#else

struct Entity_clang_syntax_PrefixUnaryOperatorExpression
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_PrefixUnaryOperatorExpression(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_syntax_PrefixUnaryOperatorExpression";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_PrefixUnaryOperatorExpression

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::SimpleDeclaration,
        std::unique_ptr<clang::syntax::SimpleDeclaration, pybind11::nodelete>,
        clang::syntax::Declaration>>
struct Bind_clang_syntax_SimpleDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SimpleDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::SimpleDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::SimpleDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDeclarators() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// FIXME: use custom iterator instead of 'vector'.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SimpleDeclaration_getDeclarators
    handle.def("getDeclarators",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::SimpleDeclaration,
                   std::vector<clang::syntax::SimpleDeclarator *>>::type>(
                   &clang::syntax::SimpleDeclaration::getDeclarators),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Groups multiple declarators (e.g. variables, typedefs, etc.) together. All
/// grouped declarators share the same declaration specifiers (e.g. 'int' or
/// 'typedef').)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SimpleDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_SimpleDeclaration(EntityScope parent_h)
      : handle{
            parent_h, "SimpleDeclaration", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Groups multiple declarators (e.g. variables, typedefs, etc.) together. All
/// grouped declarators share the same declaration specifiers (e.g. 'int' or
/// 'typedef').)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_SimpleDeclaration(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getDeclarators();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_SimpleDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_SimpleDeclaration

using Entity_clang_syntax_SimpleDeclaration =
    Bind_clang_syntax_SimpleDeclaration<>;

#else

struct Entity_clang_syntax_SimpleDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_SimpleDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_SimpleDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_SimpleDeclaration

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::SimpleDeclarator,
        std::unique_ptr<clang::syntax::SimpleDeclarator, pybind11::nodelete>,
        clang::syntax::Declarator>>
struct Bind_clang_syntax_SimpleDeclarator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SimpleDeclarator_classof
    handle.def_static(
        "classof",
        [](clang::syntax::SimpleDeclarator &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::SimpleDeclarator::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A top-level declarator without parentheses. See comment of Declarator for
/// more details.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SimpleDeclarator_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_SimpleDeclarator(EntityScope parent_h)
      : handle{
            parent_h, "SimpleDeclarator", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A top-level declarator without parentheses. See comment of Declarator for
/// more details.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_SimpleDeclarator(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_SimpleDeclarator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_SimpleDeclarator

using Entity_clang_syntax_SimpleDeclarator =
    Bind_clang_syntax_SimpleDeclarator<>;

#else

struct Entity_clang_syntax_SimpleDeclarator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_SimpleDeclarator(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_SimpleDeclarator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_SimpleDeclarator

template <class Pybind11T = pybind11::class_<
              clang::syntax::Statement,
              std::unique_ptr<clang::syntax::Statement, pybind11::nodelete>,
              clang::syntax::Tree>>
struct Bind_clang_syntax_Statement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Statement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::Statement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::Statement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An abstract node for C++ statements, e.g. 'while', 'if', etc.
/// FIXME: add accessors for semicolon of statements that have it.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_Statement_Ctor0
    handle.def(pybind11::init<clang::syntax::NodeKind>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_Statement(EntityScope parent_h)
      : handle{parent_h, "Statement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An abstract node for C++ statements, e.g. 'while', 'if', etc.
/// FIXME: add accessors for semicolon of statements that have it.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_Statement(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_Statement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_Statement

using Entity_clang_syntax_Statement = Bind_clang_syntax_Statement<>;

#else

struct Entity_clang_syntax_Statement : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_Statement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_Statement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_Statement

template <class Pybind11T = pybind11::class_<
              clang::syntax::StaticAssertDeclaration,
              std::unique_ptr<clang::syntax::StaticAssertDeclaration,
                              pybind11::nodelete>,
              clang::syntax::Declaration>>
struct Bind_clang_syntax_StaticAssertDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_StaticAssertDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::StaticAssertDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::StaticAssertDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCondition() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_StaticAssertDeclaration_getCondition
    handle.def("getCondition", [](clang::syntax::StaticAssertDeclaration
                                      &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::StaticAssertDeclaration,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::StaticAssertDeclaration::getCondition),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getMessage() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_StaticAssertDeclaration_getMessage
    handle.def("getMessage", [](clang::syntax::StaticAssertDeclaration &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::StaticAssertDeclaration,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::StaticAssertDeclaration::getMessage),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// static_assert(<condition>, <message>)
/// static_assert(<condition>))_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_StaticAssertDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_StaticAssertDeclaration(EntityScope parent_h)
      : handle{parent_h, "StaticAssertDeclaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// static_assert(<condition>, <message>)
/// static_assert(<condition>))_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_StaticAssertDeclaration(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getCondition();
    AddMethod_getMessage();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_StaticAssertDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_StaticAssertDeclaration

using Entity_clang_syntax_StaticAssertDeclaration =
    Bind_clang_syntax_StaticAssertDeclaration<>;

#else

struct Entity_clang_syntax_StaticAssertDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_StaticAssertDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_StaticAssertDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_StaticAssertDeclaration

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::SwitchStatement,
        std::unique_ptr<clang::syntax::SwitchStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_SwitchStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SwitchStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::SwitchStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::SwitchStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSwitchKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SwitchStatement_getSwitchKeyword
    handle.def("getSwitchKeyword", [](clang::syntax::SwitchStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::SwitchStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::SwitchStatement::getSwitchKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBody() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SwitchStatement_getBody
    handle.def("getBody", [](clang::syntax::SwitchStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::SwitchStatement,
                                      clang::syntax::Statement *>::type>(
              &clang::syntax::SwitchStatement::getBody),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// switch (<cond>) <body>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_SwitchStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_SwitchStatement(EntityScope parent_h)
      : handle{parent_h, "SwitchStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// switch (<cond>) <body>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_SwitchStatement(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getSwitchKeyword();
    AddMethod_getBody();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_SwitchStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_SwitchStatement

using Entity_clang_syntax_SwitchStatement = Bind_clang_syntax_SwitchStatement<>;

#else

struct Entity_clang_syntax_SwitchStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_SwitchStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_SwitchStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_SwitchStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::TemplateDeclaration,
        std::unique_ptr<clang::syntax::TemplateDeclaration, pybind11::nodelete>,
        clang::syntax::Declaration>>
struct Bind_clang_syntax_TemplateDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TemplateDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::TemplateDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::TemplateDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTemplateKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TemplateDeclaration_getTemplateKeyword
    handle.def("getTemplateKeyword", [](clang::syntax::TemplateDeclaration
                                            &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::TemplateDeclaration, clang::syntax::Leaf *>::type>(
              &clang::syntax::TemplateDeclaration::getTemplateKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDeclaration() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TemplateDeclaration_getDeclaration
    handle.def("getDeclaration", [](clang::syntax::TemplateDeclaration &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::TemplateDeclaration,
                                      clang::syntax::Declaration *>::type>(
              &clang::syntax::TemplateDeclaration::getDeclaration),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Declaration *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// template <template-parameters> <declaration>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TemplateDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TemplateDeclaration(EntityScope parent_h)
      : handle{parent_h, "TemplateDeclaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// template <template-parameters> <declaration>)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TemplateDeclaration(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getTemplateKeyword();
    AddMethod_getDeclaration();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TemplateDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TemplateDeclaration

using Entity_clang_syntax_TemplateDeclaration =
    Bind_clang_syntax_TemplateDeclaration<>;

#else

struct Entity_clang_syntax_TemplateDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TemplateDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TemplateDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TemplateDeclaration

template <class = void>
class PyTrampTokenBufferTokenManager
    : public clang::syntax::TokenBufferTokenManager {
public:
  using _PB11_WR_BaseT = clang::syntax::TokenBufferTokenManager;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenBufferTokenManagerllvm_StringLiteral_9__const
  llvm::StringLiteral kind() const override {
    using _PB11_WR_RET_TYPE = llvm::StringLiteral;
    using _PB11_WR_CONCREATE_TYPE = clang::syntax::TokenBufferTokenManager;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, kind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenBufferTokenManagerllvm_StringLiteral_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenBufferTokenManagerllvm_StringRef_9Key__const
  llvm::StringRef getText(unsigned long I) const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::syntax::TokenBufferTokenManager;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getText, I);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_syntax_TokenBufferTokenManagerllvm_StringRef_9Key__const
};

template <class Pybind11T = pybind11::class_<
              clang::syntax::TokenBufferTokenManager,
              PyTrampTokenBufferTokenManager<>, clang::syntax::TokenManager>>
struct Bind_clang_syntax_TokenBufferTokenManager : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_classof
    handle.def_static(
        "classof", static_cast<pybind11_weaver::FnPtrT<
                       void, bool(const clang::syntax::TokenManager *)>::type>(
                       &clang::syntax::TokenBufferTokenManager::classof));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_kind() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_kind
    handle.def(
        "kind",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::TokenBufferTokenManager,
                                    llvm::StringLiteral>::const_type>(
            &clang::syntax::TokenBufferTokenManager::kind));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getText() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_getText
    handle.def("getText",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBufferTokenManager, llvm::StringRef,
                   unsigned long>::const_type>(
                   &clang::syntax::TokenBufferTokenManager::getText));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getToken() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_getToken
    handle.def("getToken",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBufferTokenManager,
                   const clang::syntax::Token *, unsigned long>::const_type>(
                   &clang::syntax::TokenBufferTokenManager::getToken));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_sourceManager() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_sourceManager
    handle.def(
        "sourceManager",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::TokenBufferTokenManager,
                                    clang::SourceManager &>::type>(
            &clang::syntax::TokenBufferTokenManager::sourceManager));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_sourceManager1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_sourceManager1
    handle.def(
        "sourceManager",
        static_cast<
            pybind11_weaver::FnPtrT<clang::syntax::TokenBufferTokenManager,
                                    const clang::SourceManager &>::const_type>(
            &clang::syntax::TokenBufferTokenManager::sourceManager));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_tokenBuffer() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_tokenBuffer
    handle.def("tokenBuffer",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::TokenBufferTokenManager,
                   const clang::syntax::TokenBuffer &>::const_type>(
                   &clang::syntax::TokenBufferTokenManager::tokenBuffer));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A TokenBuffer-powered token manager.
/// It tracks the underlying token buffers, source manager, etc.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TokenBufferTokenManager_Ctor0
    handle.def(
        pybind11::init<const clang::syntax::TokenBuffer &,
                       const clang::LangOptions &, clang::SourceManager &>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TokenBufferTokenManager(EntityScope parent_h)
      : handle{parent_h, "TokenBufferTokenManager", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A TokenBuffer-powered token manager.
/// It tracks the underlying token buffers, source manager, etc.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TokenBufferTokenManager(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_kind();
    AddMethod_getText();
    AddMethod_getToken();
    AddMethod_sourceManager();
    AddMethod_sourceManager1();
    AddMethod_tokenBuffer();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TokenBufferTokenManager"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenBufferTokenManager

using Entity_clang_syntax_TokenBufferTokenManager =
    Bind_clang_syntax_TokenBufferTokenManager<>;

#else

struct Entity_clang_syntax_TokenBufferTokenManager
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TokenBufferTokenManager(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TokenBufferTokenManager"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TokenBufferTokenManager

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::TrailingReturnType,
        std::unique_ptr<clang::syntax::TrailingReturnType, pybind11::nodelete>,
        clang::syntax::Tree>>
struct Bind_clang_syntax_TrailingReturnType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TrailingReturnType_classof
    handle.def_static(
        "classof",
        [](clang::syntax::TrailingReturnType &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::TrailingReturnType::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getArrowToken() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// TODO: add accessors for specifiers.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TrailingReturnType_getArrowToken
    handle.def(
        "getArrowToken",
        [](clang::syntax::TrailingReturnType &self) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<clang::syntax::TrailingReturnType,
                                          clang::syntax::Leaf *>::type>(
                  &clang::syntax::TrailingReturnType::getArrowToken),
              &self);
          return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDeclarator() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// FIXME: This should be a `type-id` following the grammar. Fix this once we
  // have a representation of `type-id`s.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TrailingReturnType_getDeclarator
    handle.def(
        "getDeclarator",
        [](clang::syntax::TrailingReturnType &self) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  clang::syntax::TrailingReturnType,
                  clang::syntax::SimpleDeclarator *>::type>(
                  &clang::syntax::TrailingReturnType::getDeclarator),
              &self);
          return pybind11_weaver::WrapP<clang::syntax::SimpleDeclarator *>(
              __ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Trailing return type after the parameter list, including the arrow token.
/// E.g. `-> int***`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TrailingReturnType_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TrailingReturnType(EntityScope parent_h)
      : handle{
            parent_h, "TrailingReturnType", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Trailing return type after the parameter list, including the arrow token.
/// E.g. `-> int***`.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TrailingReturnType(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getArrowToken();
    AddMethod_getDeclarator();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TrailingReturnType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TrailingReturnType

using Entity_clang_syntax_TrailingReturnType =
    Bind_clang_syntax_TrailingReturnType<>;

#else

struct Entity_clang_syntax_TrailingReturnType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TrailingReturnType(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TrailingReturnType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TrailingReturnType

template <class Pybind11T = pybind11::class_<
              clang::syntax::TypeAliasDeclaration,
              std::unique_ptr<clang::syntax::TypeAliasDeclaration,
                              pybind11::nodelete>,
              clang::syntax::Declaration>>
struct Bind_clang_syntax_TypeAliasDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TypeAliasDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::TypeAliasDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::TypeAliasDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// using <name> = <type>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_TypeAliasDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_TypeAliasDeclaration(EntityScope parent_h)
      : handle{parent_h, "TypeAliasDeclaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// using <name> = <type>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_TypeAliasDeclaration(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_TypeAliasDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_TypeAliasDeclaration

using Entity_clang_syntax_TypeAliasDeclaration =
    Bind_clang_syntax_TypeAliasDeclaration<>;

#else

struct Entity_clang_syntax_TypeAliasDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_TypeAliasDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_TypeAliasDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_TypeAliasDeclaration

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::UnknownDeclaration,
        std::unique_ptr<clang::syntax::UnknownDeclaration, pybind11::nodelete>,
        clang::syntax::Declaration>>
struct Bind_clang_syntax_UnknownDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnknownDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UnknownDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UnknownDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Declaration of an unknown kind, e.g. not yet supported in syntax trees.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnknownDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UnknownDeclaration(EntityScope parent_h)
      : handle{parent_h, "UnknownDeclaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Declaration of an unknown kind, e.g. not yet supported in syntax trees.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UnknownDeclaration(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UnknownDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UnknownDeclaration

using Entity_clang_syntax_UnknownDeclaration =
    Bind_clang_syntax_UnknownDeclaration<>;

#else

struct Entity_clang_syntax_UnknownDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UnknownDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UnknownDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UnknownDeclaration

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::UnknownStatement,
        std::unique_ptr<clang::syntax::UnknownStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_UnknownStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnknownStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UnknownStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UnknownStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A statement of an unknown kind, i.e. one not currently handled by the syntax
/// tree.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UnknownStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UnknownStatement(EntityScope parent_h)
      : handle{
            parent_h, "UnknownStatement", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A statement of an unknown kind, i.e. one not currently handled by the syntax
/// tree.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UnknownStatement(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UnknownStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UnknownStatement

using Entity_clang_syntax_UnknownStatement =
    Bind_clang_syntax_UnknownStatement<>;

#else

struct Entity_clang_syntax_UnknownStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UnknownStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UnknownStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UnknownStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::UsingDeclaration,
        std::unique_ptr<clang::syntax::UsingDeclaration, pybind11::nodelete>,
        clang::syntax::Declaration>>
struct Bind_clang_syntax_UsingDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UsingDeclaration_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UsingDeclaration &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UsingDeclaration::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// using <scope>::<name>
/// using typename <scope>::<name>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UsingDeclaration_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UsingDeclaration(EntityScope parent_h)
      : handle{parent_h, "UsingDeclaration", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// using <scope>::<name>
/// using typename <scope>::<name>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UsingDeclaration(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UsingDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UsingDeclaration

using Entity_clang_syntax_UsingDeclaration =
    Bind_clang_syntax_UsingDeclaration<>;

#else

struct Entity_clang_syntax_UsingDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UsingDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UsingDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UsingDeclaration

template <class Pybind11T = pybind11::class_<
              clang::syntax::UsingNamespaceDirective,
              std::unique_ptr<clang::syntax::UsingNamespaceDirective,
                              pybind11::nodelete>,
              clang::syntax::Declaration>>
struct Bind_clang_syntax_UsingNamespaceDirective : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UsingNamespaceDirective_classof
    handle.def_static(
        "classof",
        [](clang::syntax::UsingNamespaceDirective &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::UsingNamespaceDirective::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// using namespace <name>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_UsingNamespaceDirective_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_UsingNamespaceDirective(EntityScope parent_h)
      : handle{parent_h, "UsingNamespaceDirective", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// using namespace <name>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_UsingNamespaceDirective(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_UsingNamespaceDirective"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_UsingNamespaceDirective

using Entity_clang_syntax_UsingNamespaceDirective =
    Bind_clang_syntax_UsingNamespaceDirective<>;

#else

struct Entity_clang_syntax_UsingNamespaceDirective
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_UsingNamespaceDirective(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_UsingNamespaceDirective"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_UsingNamespaceDirective

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::WhileStatement,
        std::unique_ptr<clang::syntax::WhileStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_WhileStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_WhileStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::WhileStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::WhileStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getWhileKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_WhileStatement_getWhileKeyword
    handle.def("getWhileKeyword", [](clang::syntax::WhileStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::WhileStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::WhileStatement::getWhileKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBody() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_WhileStatement_getBody
    handle.def("getBody", [](clang::syntax::WhileStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::WhileStatement, clang::syntax::Statement *>::type>(
              &clang::syntax::WhileStatement::getBody),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// while (<cond>) <body>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_WhileStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_WhileStatement(EntityScope parent_h)
      : handle{parent_h, "WhileStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// while (<cond>) <body>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_WhileStatement(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getWhileKeyword();
    AddMethod_getBody();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_WhileStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_WhileStatement

using Entity_clang_syntax_WhileStatement = Bind_clang_syntax_WhileStatement<>;

#else

struct Entity_clang_syntax_WhileStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_WhileStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_WhileStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_WhileStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::BreakStatement,
        std::unique_ptr<clang::syntax::BreakStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_BreakStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BreakStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::BreakStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::BreakStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBreakKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BreakStatement_getBreakKeyword
    handle.def("getBreakKeyword", [](clang::syntax::BreakStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::BreakStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::BreakStatement::getBreakKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// break;)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_BreakStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_BreakStatement(EntityScope parent_h)
      : handle{parent_h, "BreakStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// break;)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_BreakStatement(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getBreakKeyword();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_BreakStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_BreakStatement

using Entity_clang_syntax_BreakStatement = Bind_clang_syntax_BreakStatement<>;

#else

struct Entity_clang_syntax_BreakStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_BreakStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_BreakStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_BreakStatement

template <class Pybind11T = pybind11::class_<
              clang::syntax::CallArguments,
              std::unique_ptr<clang::syntax::CallArguments, pybind11::nodelete>,
              clang::syntax::List>>
struct Bind_clang_syntax_CallArguments : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CallArguments_classof
    handle.def_static(
        "classof",
        [](clang::syntax::CallArguments &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::CallArguments::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getArguments() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CallArguments_getArguments
    handle.def("getArguments",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::CallArguments,
                   std::vector<clang::syntax::Expression *>>::type>(
                   &clang::syntax::CallArguments::getArguments));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getArgumentsAndCommas() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CallArguments_getArgumentsAndCommas
    handle.def("getArgumentsAndCommas",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::CallArguments,
                   std::vector<clang::syntax::List::ElementAndDelimiter<
                       clang::syntax::Expression>>>::type>(
                   &clang::syntax::CallArguments::getArgumentsAndCommas));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Models arguments of a function call.
///   call-arguments:
///     delimited_list(expression, ',')
/// Note: This construct is a simplification of the grammar rule for
/// `expression-list`, that is used in the definition of `call-expression`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CallArguments_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_CallArguments(EntityScope parent_h)
      : handle{parent_h, "CallArguments", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Models arguments of a function call.
///   call-arguments:
///     delimited_list(expression, ',')
/// Note: This construct is a simplification of the grammar rule for
/// `expression-list`, that is used in the definition of `call-expression`)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_CallArguments(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getArguments();
    AddMethod_getArgumentsAndCommas();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_CallArguments"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_CallArguments

using Entity_clang_syntax_CallArguments = Bind_clang_syntax_CallArguments<>;

#else

struct Entity_clang_syntax_CallArguments
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_CallArguments(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_CallArguments"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_CallArguments

template <class Pybind11T = pybind11::class_<
              clang::syntax::CaseStatement,
              std::unique_ptr<clang::syntax::CaseStatement, pybind11::nodelete>,
              clang::syntax::Statement>>
struct Bind_clang_syntax_CaseStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CaseStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::CaseStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::CaseStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCaseKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CaseStatement_getCaseKeyword
    handle.def("getCaseKeyword", [](clang::syntax::CaseStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::CaseStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::CaseStatement::getCaseKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCaseValue() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CaseStatement_getCaseValue
    handle.def("getCaseValue", [](clang::syntax::CaseStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::CaseStatement, clang::syntax::Expression *>::type>(
              &clang::syntax::CaseStatement::getCaseValue),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBody() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CaseStatement_getBody
    handle.def("getBody", [](clang::syntax::CaseStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::CaseStatement, clang::syntax::Statement *>::type>(
              &clang::syntax::CaseStatement::getBody),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// case <value>: <body>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CaseStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_CaseStatement(EntityScope parent_h)
      : handle{parent_h, "CaseStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// case <value>: <body>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_CaseStatement(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getCaseKeyword();
    AddMethod_getCaseValue();
    AddMethod_getBody();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_CaseStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_CaseStatement

using Entity_clang_syntax_CaseStatement = Bind_clang_syntax_CaseStatement<>;

#else

struct Entity_clang_syntax_CaseStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_CaseStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_CaseStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_CaseStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::CompoundStatement,
        std::unique_ptr<clang::syntax::CompoundStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_CompoundStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CompoundStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::CompoundStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::CompoundStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLbrace() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CompoundStatement_getLbrace
    handle.def("getLbrace", [](clang::syntax::CompoundStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::CompoundStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::CompoundStatement::getLbrace),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getStatements() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// FIXME: use custom iterator instead of 'vector'.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CompoundStatement_getStatements
    handle.def("getStatements",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::CompoundStatement,
                   std::vector<clang::syntax::Statement *>>::type>(
                   &clang::syntax::CompoundStatement::getStatements),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRbrace() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CompoundStatement_getRbrace
    handle.def("getRbrace", [](clang::syntax::CompoundStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::CompoundStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::CompoundStatement::getRbrace),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// { statement1; statement2;  })_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_CompoundStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_CompoundStatement(EntityScope parent_h)
      : handle{parent_h, "CompoundStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// { statement1; statement2;  })_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_CompoundStatement(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getLbrace();
    AddMethod_getStatements();
    AddMethod_getRbrace();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_CompoundStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_CompoundStatement

using Entity_clang_syntax_CompoundStatement =
    Bind_clang_syntax_CompoundStatement<>;

#else

struct Entity_clang_syntax_CompoundStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_CompoundStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_CompoundStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_CompoundStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::ContinueStatement,
        std::unique_ptr<clang::syntax::ContinueStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_ContinueStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ContinueStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ContinueStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ContinueStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getContinueKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ContinueStatement_getContinueKeyword
    handle.def("getContinueKeyword", [](clang::syntax::ContinueStatement
                                            &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::ContinueStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::ContinueStatement::getContinueKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// continue;)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ContinueStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ContinueStatement(EntityScope parent_h)
      : handle{parent_h, "ContinueStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// continue;)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ContinueStatement(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getContinueKeyword();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ContinueStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ContinueStatement

using Entity_clang_syntax_ContinueStatement =
    Bind_clang_syntax_ContinueStatement<>;

#else

struct Entity_clang_syntax_ContinueStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ContinueStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ContinueStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ContinueStatement

template <class Pybind11T = pybind11::class_<
              clang::syntax::DeclarationStatement,
              std::unique_ptr<clang::syntax::DeclarationStatement,
                              pybind11::nodelete>,
              clang::syntax::Statement>>
struct Bind_clang_syntax_DeclarationStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DeclarationStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::DeclarationStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::DeclarationStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// E.g. 'int a, b = 10;')_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DeclarationStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_DeclarationStatement(EntityScope parent_h)
      : handle{parent_h, "DeclarationStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// E.g. 'int a, b = 10;')_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_DeclarationStatement(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_DeclarationStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_DeclarationStatement

using Entity_clang_syntax_DeclarationStatement =
    Bind_clang_syntax_DeclarationStatement<>;

#else

struct Entity_clang_syntax_DeclarationStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_DeclarationStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_DeclarationStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_DeclarationStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::DeclaratorList,
        std::unique_ptr<clang::syntax::DeclaratorList, pybind11::nodelete>,
        clang::syntax::List>>
struct Bind_clang_syntax_DeclaratorList : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DeclaratorList_classof
    handle.def_static(
        "classof",
        [](clang::syntax::DeclaratorList &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::DeclaratorList::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDeclarators() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DeclaratorList_getDeclarators
    handle.def("getDeclarators",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::DeclaratorList,
                   std::vector<clang::syntax::SimpleDeclarator *>>::type>(
                   &clang::syntax::DeclaratorList::getDeclarators));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDeclaratorsAndCommas() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DeclaratorList_getDeclaratorsAndCommas
    handle.def("getDeclaratorsAndCommas",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::syntax::DeclaratorList,
                   std::vector<clang::syntax::List::ElementAndDelimiter<
                       clang::syntax::SimpleDeclarator>>>::type>(
                   &clang::syntax::DeclaratorList::getDeclaratorsAndCommas));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DeclaratorList_Ctor0
    handle.def(pybind11::init<>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_DeclaratorList(EntityScope parent_h)
      : handle{parent_h, "DeclaratorList", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_DeclaratorList(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getDeclarators();
    AddMethod_getDeclaratorsAndCommas();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_DeclaratorList"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_DeclaratorList

using Entity_clang_syntax_DeclaratorList = Bind_clang_syntax_DeclaratorList<>;

#else

struct Entity_clang_syntax_DeclaratorList
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_DeclaratorList(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_DeclaratorList"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_DeclaratorList

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::DefaultStatement,
        std::unique_ptr<clang::syntax::DefaultStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_DefaultStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DefaultStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::DefaultStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::DefaultStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDefaultKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DefaultStatement_getDefaultKeyword
    handle.def("getDefaultKeyword", [](clang::syntax::DefaultStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::DefaultStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::DefaultStatement::getDefaultKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBody() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DefaultStatement_getBody
    handle.def("getBody", [](clang::syntax::DefaultStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::DefaultStatement,
                                      clang::syntax::Statement *>::type>(
              &clang::syntax::DefaultStatement::getBody),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// default: <body>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_DefaultStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_DefaultStatement(EntityScope parent_h)
      : handle{parent_h, "DefaultStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// default: <body>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_DefaultStatement(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getDefaultKeyword();
    AddMethod_getBody();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_DefaultStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_DefaultStatement

using Entity_clang_syntax_DefaultStatement =
    Bind_clang_syntax_DefaultStatement<>;

#else

struct Entity_clang_syntax_DefaultStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_DefaultStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_DefaultStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_DefaultStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::EmptyStatement,
        std::unique_ptr<clang::syntax::EmptyStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_EmptyStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_EmptyStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::EmptyStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::EmptyStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The no-op statement, i.e. ';'.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_EmptyStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_EmptyStatement(EntityScope parent_h)
      : handle{
            parent_h, "EmptyStatement", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// The no-op statement, i.e. ';'.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_EmptyStatement(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_EmptyStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_EmptyStatement

using Entity_clang_syntax_EmptyStatement = Bind_clang_syntax_EmptyStatement<>;

#else

struct Entity_clang_syntax_EmptyStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_EmptyStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_EmptyStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_EmptyStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::ExpressionStatement,
        std::unique_ptr<clang::syntax::ExpressionStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_ExpressionStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExpressionStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ExpressionStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ExpressionStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getExpression() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExpressionStatement_getExpression
    handle.def("getExpression", [](clang::syntax::ExpressionStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::ExpressionStatement,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::ExpressionStatement::getExpression),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Expression in a statement position, e.g. functions calls inside compound
/// statements or inside a loop body.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ExpressionStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ExpressionStatement(EntityScope parent_h)
      : handle{
            parent_h, "ExpressionStatement", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Expression in a statement position, e.g. functions calls inside compound
/// statements or inside a loop body.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ExpressionStatement(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getExpression();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ExpressionStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ExpressionStatement

using Entity_clang_syntax_ExpressionStatement =
    Bind_clang_syntax_ExpressionStatement<>;

#else

struct Entity_clang_syntax_ExpressionStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ExpressionStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ExpressionStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ExpressionStatement

template <class Pybind11T = pybind11::class_<
              clang::syntax::ForStatement,
              std::unique_ptr<clang::syntax::ForStatement, pybind11::nodelete>,
              clang::syntax::Statement>>
struct Bind_clang_syntax_ForStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ForStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ForStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ForStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getForKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ForStatement_getForKeyword
    handle.def("getForKeyword", [](clang::syntax::ForStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::ForStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::ForStatement::getForKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBody() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ForStatement_getBody
    handle.def("getBody", [](clang::syntax::ForStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::ForStatement, clang::syntax::Statement *>::type>(
              &clang::syntax::ForStatement::getBody),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// for (<init>; <cond>; <increment>) <body>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ForStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ForStatement(EntityScope parent_h)
      : handle{parent_h, "ForStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// for (<init>; <cond>; <increment>) <body>)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ForStatement(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getForKeyword();
    AddMethod_getBody();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ForStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ForStatement

using Entity_clang_syntax_ForStatement = Bind_clang_syntax_ForStatement<>;

#else

struct Entity_clang_syntax_ForStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ForStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ForStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ForStatement

template <class Pybind11T = pybind11::class_<
              clang::syntax::IfStatement,
              std::unique_ptr<clang::syntax::IfStatement, pybind11::nodelete>,
              clang::syntax::Statement>>
struct Bind_clang_syntax_IfStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_IfStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::IfStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::IfStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getIfKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_IfStatement_getIfKeyword
    handle.def("getIfKeyword", [](clang::syntax::IfStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::IfStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::IfStatement::getIfKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getThenStatement() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_IfStatement_getThenStatement
    handle.def("getThenStatement", [](clang::syntax::IfStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::IfStatement, clang::syntax::Statement *>::type>(
              &clang::syntax::IfStatement::getThenStatement),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getElseKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_IfStatement_getElseKeyword
    handle.def("getElseKeyword", [](clang::syntax::IfStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::IfStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::IfStatement::getElseKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getElseStatement() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_IfStatement_getElseStatement
    handle.def("getElseStatement", [](clang::syntax::IfStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<
              clang::syntax::IfStatement, clang::syntax::Statement *>::type>(
              &clang::syntax::IfStatement::getElseStatement),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// if (cond) <then-statement> else <else-statement>
/// FIXME: add condition that models 'expression  or variable declaration')_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_IfStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_IfStatement(EntityScope parent_h)
      : handle{parent_h, "IfStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// if (cond) <then-statement> else <else-statement>
/// FIXME: add condition that models 'expression  or variable declaration')_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_IfStatement(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getIfKeyword();
    AddMethod_getThenStatement();
    AddMethod_getElseKeyword();
    AddMethod_getElseStatement();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_IfStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_IfStatement

using Entity_clang_syntax_IfStatement = Bind_clang_syntax_IfStatement<>;

#else

struct Entity_clang_syntax_IfStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_IfStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_IfStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_IfStatement

template <class Pybind11T = pybind11::class_<
              clang::syntax::RangeBasedForStatement,
              std::unique_ptr<clang::syntax::RangeBasedForStatement,
                              pybind11::nodelete>,
              clang::syntax::Statement>>
struct Bind_clang_syntax_RangeBasedForStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_RangeBasedForStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::RangeBasedForStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::RangeBasedForStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getForKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_RangeBasedForStatement_getForKeyword
    handle.def(
        "getForKeyword", [](clang::syntax::RangeBasedForStatement &self) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<clang::syntax::RangeBasedForStatement,
                                          clang::syntax::Leaf *>::type>(
                  &clang::syntax::RangeBasedForStatement::getForKeyword),
              &self);
          return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getBody() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_RangeBasedForStatement_getBody
    handle.def("getBody", [](clang::syntax::RangeBasedForStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::RangeBasedForStatement,
                                      clang::syntax::Statement *>::type>(
              &clang::syntax::RangeBasedForStatement::getBody),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Statement *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// for (<decl> : <init>) <body>)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_RangeBasedForStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_RangeBasedForStatement(EntityScope parent_h)
      : handle{parent_h, "RangeBasedForStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// for (<decl> : <init>) <body>)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_RangeBasedForStatement(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getForKeyword();
    AddMethod_getBody();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_RangeBasedForStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_RangeBasedForStatement

using Entity_clang_syntax_RangeBasedForStatement =
    Bind_clang_syntax_RangeBasedForStatement<>;

#else

struct Entity_clang_syntax_RangeBasedForStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_RangeBasedForStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_RangeBasedForStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_RangeBasedForStatement

template <
    class Pybind11T = pybind11::class_<
        clang::syntax::ReturnStatement,
        std::unique_ptr<clang::syntax::ReturnStatement, pybind11::nodelete>,
        clang::syntax::Statement>>
struct Bind_clang_syntax_ReturnStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_classof() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ReturnStatement_classof
    handle.def_static(
        "classof",
        [](clang::syntax::ReturnStatement &self,
           pybind11_weaver::WrappedPtrT<const clang::syntax::Node *> N) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, bool(const clang::syntax::Node *)>::type>(
                  &clang::syntax::ReturnStatement::classof),
              (N)->Cptr());
        });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getReturnKeyword() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ReturnStatement_getReturnKeyword
    handle.def("getReturnKeyword", [](clang::syntax::ReturnStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<pybind11_weaver::FnPtrT<clang::syntax::ReturnStatement,
                                              clang::syntax::Leaf *>::type>(
              &clang::syntax::ReturnStatement::getReturnKeyword),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Leaf *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getReturnValue() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ReturnStatement_getReturnValue
    handle.def("getReturnValue", [](clang::syntax::ReturnStatement &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::syntax::ReturnStatement,
                                      clang::syntax::Expression *>::type>(
              &clang::syntax::ReturnStatement::getReturnValue),
          &self);
      return pybind11_weaver::WrapP<clang::syntax::Expression *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/// return <expr>;
/// return;)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_syntax_ReturnStatement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_syntax_ReturnStatement(EntityScope parent_h)
      : handle{parent_h, "ReturnStatement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// return <expr>;
/// return;)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_syntax_ReturnStatement(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_classof();
    AddMethod_getReturnKeyword();
    AddMethod_getReturnValue();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_syntax_ReturnStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_syntax_ReturnStatement

using Entity_clang_syntax_ReturnStatement = Bind_clang_syntax_ReturnStatement<>;

#else

struct Entity_clang_syntax_ReturnStatement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_syntax_ReturnStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_syntax_ReturnStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_syntax_ReturnStatement

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "tooling")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling

using Entity_clang_tooling = Bind_clang_tooling<>;

#else

struct Entity_clang_tooling : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling

template <class Pybind11T =
              pybind11::class_<clang::tooling::ASTMatchRefactorer>>
struct Bind_clang_tooling_ASTMatchRefactorer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_addDynamicMatcher() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ASTMatchRefactorer_addDynamicMatcher
    handle.def("addDynamicMatcher",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ASTMatchRefactorer, void,
                   const clang::ast_matchers::internal::DynTypedMatcher &,
                   clang::tooling::RefactoringCallback *>::type>(
                   &clang::tooling::ASTMatchRefactorer::addDynamicMatcher));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_newASTConsumer() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_ASTMatchRefactorer_newASTConsumer
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ASTMatchRefactorer_newASTConsumer
    handle.def("newASTConsumer", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adaptor between \c ast_matchers::MatchFinder and \c
/// tooling::RefactoringTool.
///
/// Runs AST matchers and stores the \c tooling::Replacements in a map.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ASTMatchRefactorer_Ctor0
    handle.def(pybind11::init<std::map<std::basic_string<char>,
                                       clang::tooling::Replacements> &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ASTMatchRefactorer(EntityScope parent_h)
      : handle{parent_h, "ASTMatchRefactorer", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Adaptor between \c ast_matchers::MatchFinder and \c
/// tooling::RefactoringTool.
///
/// Runs AST matchers and stores the \c tooling::Replacements in a map.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ASTMatchRefactorer(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_addDynamicMatcher();
    AddMethod_newASTConsumer();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ASTMatchRefactorer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ASTMatchRefactorer

using Entity_clang_tooling_ASTMatchRefactorer =
    Bind_clang_tooling_ASTMatchRefactorer<>;

#else

struct Entity_clang_tooling_ASTMatchRefactorer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ASTMatchRefactorer(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ASTMatchRefactorer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ASTMatchRefactorer

template <class Pybind11T = pybind11::class_<clang::tooling::ApplyChangesSpec>>
struct Bind_clang_tooling_ApplyChangesSpec : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_ApplyChangesSpec(EntityScope parent_h)
      : handle{
            parent_h, "ApplyChangesSpec", pybind11::dynamic_attr(),
            R"_pb11_weaver(// Defines specs for applying changes.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ApplyChangesSpec(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ApplyChangesSpec>(
        handle);
    handle.def_readwrite(
        "Cleanup", &clang::tooling::ApplyChangesSpec::Cleanup,
        R"_pb11_weaver(// If true, cleans up redundant/erroneous code around changed code with
  // clang-format's cleanup functionality, e.g. redundant commas around deleted
  // parameter or empty namespaces introduced by deletions.)_pb11_weaver");
    handle.def_readwrite("Format", &clang::tooling::ApplyChangesSpec::Format);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ApplyChangesSpec"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ApplyChangesSpec

using Entity_clang_tooling_ApplyChangesSpec =
    Bind_clang_tooling_ApplyChangesSpec<>;

#else

struct Entity_clang_tooling_ApplyChangesSpec
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ApplyChangesSpec(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ApplyChangesSpec"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ApplyChangesSpec

template <class Pybind11T =
              pybind11::enum_<clang::tooling::ApplyChangesSpec::FormatOption>>
struct Bind_clang_tooling_ApplyChangesSpec_FormatOption : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_ApplyChangesSpec_FormatOption(
      EntityScope parent_h)
      : handle{parent_h, "FormatOption", pybind11::arithmetic(),
               R"_pb11_weaver(// Options for selectively formatting changes with clang-format:
  // kAll: Format all changed lines.
  // kNone: Don't format anything.
  // kViolations: Format lines exceeding the `ColumnLimit` in `Style`.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ApplyChangesSpec_FormatOption(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("kAll", clang::tooling::ApplyChangesSpec::FormatOption::kAll);
    handle.value("kNone",
                 clang::tooling::ApplyChangesSpec::FormatOption::kNone);
    handle.value("kViolations",
                 clang::tooling::ApplyChangesSpec::FormatOption::kViolations);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_ApplyChangesSpec_FormatOption";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ApplyChangesSpec_FormatOption

using Entity_clang_tooling_ApplyChangesSpec_FormatOption =
    Bind_clang_tooling_ApplyChangesSpec_FormatOption<>;

#else

struct Entity_clang_tooling_ApplyChangesSpec_FormatOption
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ApplyChangesSpec_FormatOption(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_ApplyChangesSpec_FormatOption";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ApplyChangesSpec_FormatOption

template <class Pybind11T =
              pybind11::enum_<clang::tooling::ArgumentInsertPosition>>
struct Bind_clang_tooling_ArgumentInsertPosition : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_ArgumentInsertPosition(EntityScope parent_h)
      : handle{parent_h, "ArgumentInsertPosition", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ArgumentInsertPosition(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("BEGIN", clang::tooling::ArgumentInsertPosition::BEGIN);
    handle.value("END", clang::tooling::ArgumentInsertPosition::END);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ArgumentInsertPosition"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ArgumentInsertPosition

using Entity_clang_tooling_ArgumentInsertPosition =
    Bind_clang_tooling_ArgumentInsertPosition<>;

#else

struct Entity_clang_tooling_ArgumentInsertPosition
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ArgumentInsertPosition(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ArgumentInsertPosition"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ArgumentInsertPosition

template <class Pybind11T = pybind11::class_<clang::tooling::AtomicChange>>
struct Bind_clang_tooling_AtomicChange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_toYAMLString() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the atomic change as a YAML string.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_toYAMLString
    handle.def(
        "toYAMLString",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::AtomicChange,
                                            std::basic_string<char>>::type>(
            &clang::tooling::AtomicChange::toYAMLString),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_convertFromYAML() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Converts a YAML-encoded automic change to AtomicChange.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_convertFromYAML
    handle.def_static(
        "convertFromYAML",
        static_cast<pybind11_weaver::FnPtrT<void, clang::tooling::AtomicChange(
                                                      llvm::StringRef)>::type>(
            &clang::tooling::AtomicChange::convertFromYAML),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getKey() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the key of this change, which is a concatenation of the
  /// file name and offset of the key position.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getKey
    handle.def("getKey",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange,
                   const std::basic_string<char> &>::const_type>(
                   &clang::tooling::AtomicChange::getKey),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFilePath() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the path of the file containing this atomic change.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getFilePath
    handle.def("getFilePath",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange,
                   const std::basic_string<char> &>::const_type>(
                   &clang::tooling::AtomicChange::getFilePath),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If this change could not be created successfully, e.g. because of
  /// conflicts among replacements, use this to set an error description.
  /// Thereby, places that cannot be fixed automatically can be gathered when
  /// applying changes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_setError
    handle.def(
        "setError",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::AtomicChange, void,
                                            llvm::StringRef>::type>(
            &clang::tooling::AtomicChange::setError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_hasError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns whether an error has been set on this list.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_hasError
    handle.def("hasError",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::AtomicChange,
                                                   bool>::const_type>(
                   &clang::tooling::AtomicChange::hasError),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the error message or an empty string if it does not exist.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getError
    handle.def("getError",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange,
                   const std::basic_string<char> &>::const_type>(
                   &clang::tooling::AtomicChange::getError),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_replace() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a replacement that replaces the given Range with
  /// ReplacementText.
  /// \returns An llvm::Error carrying ReplacementError on error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_replace
    handle.def(
        "replace",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::AtomicChange, llvm::Error,
            const clang::SourceManager &, const clang::CharSourceRange &,
            llvm::StringRef>::type>(&clang::tooling::AtomicChange::replace),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_replace1() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a replacement that replaces range [Loc, Loc+Length) with
  /// \p Text.
  /// \returns An llvm::Error carrying ReplacementError on error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_replace1
    handle.def(
        "replace",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::AtomicChange, llvm::Error,
            const clang::SourceManager &, clang::SourceLocation, unsigned int,
            llvm::StringRef>::type>(&clang::tooling::AtomicChange::replace),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_insert() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a replacement that inserts \p Text at \p Loc. If this
  /// insertion conflicts with an existing insertion (at the same position),
  /// this will be inserted before/after the existing insertion depending on
  /// \p InsertAfter. Users should use `replace` with `Length=0` instead if they
  /// do not want conflict resolving by default. If the conflicting replacement
  /// is not an insertion, an error is returned.
  ///
  /// \returns An llvm::Error carrying ReplacementError on error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_insert
    handle.def("insert",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange, llvm::Error,
                   const clang::SourceManager &, clang::SourceLocation,
                   llvm::StringRef, bool>::type>(
                   &clang::tooling::AtomicChange::insert),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_addHeader() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a header into the file that contains the key position.
  /// Header can be in angle brackets or double quotation marks. By default
  /// (header is not quoted), header will be surrounded with double quotes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_addHeader
    handle.def(
        "addHeader",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::AtomicChange, void,
                                            llvm::StringRef>::type>(
            &clang::tooling::AtomicChange::addHeader),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_removeHeader() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Removes a header from the file that contains the key position.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_removeHeader
    handle.def(
        "removeHeader",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::AtomicChange, void,
                                            llvm::StringRef>::type>(
            &clang::tooling::AtomicChange::removeHeader),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getReplacements() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a const reference to existing replacements.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getReplacements
    handle.def("getReplacements",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange,
                   const clang::tooling::Replacements &>::const_type>(
                   &clang::tooling::AtomicChange::getReplacements),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getReplacements1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getReplacements1
    handle.def(
        "getReplacements",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::AtomicChange,
                                    clang::tooling::Replacements &>::type>(
            &clang::tooling::AtomicChange::getReplacements));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getInsertedHeaders() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getInsertedHeaders
    handle.def("getInsertedHeaders",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange,
                   llvm::ArrayRef<std::basic_string<char>>>::const_type>(
                   &clang::tooling::AtomicChange::getInsertedHeaders));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRemovedHeaders() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getRemovedHeaders
    handle.def("getRemovedHeaders",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::AtomicChange,
                   llvm::ArrayRef<std::basic_string<char>>>::const_type>(
                   &clang::tooling::AtomicChange::getRemovedHeaders));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getMetadata() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_getMetadata
    handle.def(
        "getMetadata",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::AtomicChange,
                                            const llvm::Any &>::const_type>(
            &clang::tooling::AtomicChange::getMetadata));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An atomic change is used to create and group a set of source edits,
/// e.g. replacements or header insertions. Edits in an AtomicChange should be
/// related, e.g. replacements for the same type reference and the corresponding
/// header insertion/deletion.
///
/// An AtomicChange is uniquely identified by a key and will either be fully
/// applied or not applied at all.
///
/// Calling setError on an AtomicChange stores the error message and marks it as
/// bad, i.e. none of its source edits will be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_Ctor0
    handle.def(
        pybind11::init<const clang::SourceManager &, clang::SourceLocation>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An atomic change is used to create and group a set of source edits,
/// e.g. replacements or header insertions. Edits in an AtomicChange should be
/// related, e.g. replacements for the same type reference and the corresponding
/// header insertion/deletion.
///
/// An AtomicChange is uniquely identified by a key and will either be fully
/// applied or not applied at all.
///
/// Calling setError on an AtomicChange stores the error message and marks it as
/// bad, i.e. none of its source edits will be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_Ctor1
    handle.def(pybind11::init<const clang::SourceManager &,
                              clang::SourceLocation, llvm::Any>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor2() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An atomic change is used to create and group a set of source edits,
/// e.g. replacements or header insertions. Edits in an AtomicChange should be
/// related, e.g. replacements for the same type reference and the corresponding
/// header insertion/deletion.
///
/// An AtomicChange is uniquely identified by a key and will either be fully
/// applied or not applied at all.
///
/// Calling setError on an AtomicChange stores the error message and marks it as
/// bad, i.e. none of its source edits will be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AtomicChange_Ctor2
    handle.def(pybind11::init<llvm::StringRef, llvm::StringRef>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_AtomicChange(EntityScope parent_h)
      : handle{
            parent_h, "AtomicChange", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An atomic change is used to create and group a set of source edits,
/// e.g. replacements or header insertions. Edits in an AtomicChange should be
/// related, e.g. replacements for the same type reference and the corresponding
/// header insertion/deletion.
///
/// An AtomicChange is uniquely identified by a key and will either be fully
/// applied or not applied at all.
///
/// Calling setError on an AtomicChange stores the error message and marks it as
/// bad, i.e. none of its source edits will be applied.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_AtomicChange(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_toYAMLString();
    AddMethod_convertFromYAML();
    AddMethod_getKey();
    AddMethod_getFilePath();
    AddMethod_setError();
    AddMethod_hasError();
    AddMethod_getError();
    AddMethod_replace();
    AddMethod_replace1();
    AddMethod_insert();
    AddMethod_addHeader();
    AddMethod_removeHeader();
    AddMethod_getReplacements();
    AddMethod_getReplacements1();
    AddMethod_getInsertedHeaders();
    AddMethod_getRemovedHeaders();
    AddMethod_getMetadata();
    AddCtor0();
    AddCtor1();
    AddCtor2();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_AtomicChange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_AtomicChange

using Entity_clang_tooling_AtomicChange = Bind_clang_tooling_AtomicChange<>;

#else

struct Entity_clang_tooling_AtomicChange
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_AtomicChange(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_AtomicChange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_AtomicChange

template <class Pybind11T = pybind11::class_<clang::tooling::ClangTool>>
struct Bind_clang_tooling_ClangTool : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_setDiagnosticConsumer() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Set a \c DiagnosticConsumer to use during parsing.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_setDiagnosticConsumer
    handle.def(
        "setDiagnosticConsumer",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::ClangTool, void,
                                            clang::DiagnosticConsumer *>::type>(
            &clang::tooling::ClangTool::setDiagnosticConsumer),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_mapVirtualFile() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Map a virtual file to be used while running the tool.
  ///
  /// \param FilePath The path at which the content will be mapped.
  /// \param Content A null terminated buffer of the file's content.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_mapVirtualFile
    handle.def(
        "mapVirtualFile",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ClangTool, void,
                                    llvm::StringRef, llvm::StringRef>::type>(
            &clang::tooling::ClangTool::mapVirtualFile),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_appendArgumentsAdjuster() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Append a command line arguments adjuster to the adjuster chain.
  ///
  /// \param Adjuster An argument adjuster, which will be run on the output of
  ///        previous argument adjusters.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_appendArgumentsAdjuster
    handle.def("appendArgumentsAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ClangTool, void,
                   std::function<std::vector<std::basic_string<char>>(
                       const std::vector<std::basic_string<char>> &,
                       llvm::StringRef)>>::type>(
                   &clang::tooling::ClangTool::appendArgumentsAdjuster),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_clearArgumentsAdjusters() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Clear the command line arguments adjuster chain.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_clearArgumentsAdjusters
    handle.def(
        "clearArgumentsAdjusters",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ClangTool, void>::type>(
            &clang::tooling::ClangTool::clearArgumentsAdjusters),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Runs an action over all files specified in the command line.
  ///
  /// \param Action Tool action.
  ///
  /// \returns 0 on success; 1 if any error occurred; 2 if there is no error but
  /// some files are skipped due to missing compile commands.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_run
    handle.def("run",
               static_cast<
                   pybind11_weaver::FnPtrT<clang::tooling::ClangTool, int,
                                           clang::tooling::ToolAction *>::type>(
                   &clang::tooling::ClangTool::run),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_buildASTs() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Create an AST for each file specified in the command line and
  /// append them to ASTs.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_ClangTool_buildASTs
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_buildASTs
    handle.def("buildASTs", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setPrintErrorMessage() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Sets whether an error message should be printed out if an action fails. By
  /// default, if an action fails, a message is printed out to stderr.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_setPrintErrorMessage
    handle.def("setPrintErrorMessage",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::ClangTool,
                                                   void, bool>::type>(
                   &clang::tooling::ClangTool::setPrintErrorMessage),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFiles() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the file manager used in the tool.
  ///
  /// The file manager is shared between all translation units.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_getFiles
    handle.def("getFiles",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::ClangTool,
                                                   clang::FileManager &>::type>(
                   &clang::tooling::ClangTool::getFiles),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSourcePaths() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_getSourcePaths
    handle.def("getSourcePaths",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ClangTool,
                   llvm::ArrayRef<std::basic_string<char>>>::const_type>(
                   &clang::tooling::ClangTool::getSourcePaths));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Utility to run a FrontendAction over a set of files.
///
/// This class is written to be usable for command line utilities.
/// By default the class uses ClangSyntaxOnlyAdjuster to modify
/// command line arguments before the arguments are used to run
/// a frontend action. One could install an additional command line
/// arguments adjuster by calling the appendArgumentsAdjuster() method.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ClangTool_Ctor0
    handle.def(pybind11::init<const clang::tooling::CompilationDatabase &,
                              llvm::ArrayRef<std::basic_string<char>>,
                              std::shared_ptr<clang::PCHContainerOperations>,
                              llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>,
                              llvm::IntrusiveRefCntPtr<clang::FileManager>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ClangTool(EntityScope parent_h)
      : handle{parent_h, "ClangTool", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Utility to run a FrontendAction over a set of files.
///
/// This class is written to be usable for command line utilities.
/// By default the class uses ClangSyntaxOnlyAdjuster to modify
/// command line arguments before the arguments are used to run
/// a frontend action. One could install an additional command line
/// arguments adjuster by calling the appendArgumentsAdjuster() method.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ClangTool(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_setDiagnosticConsumer();
    AddMethod_mapVirtualFile();
    AddMethod_appendArgumentsAdjuster();
    AddMethod_clearArgumentsAdjusters();
    AddMethod_run();
    AddMethod_buildASTs();
    AddMethod_setPrintErrorMessage();
    AddMethod_getFiles();
    AddMethod_getSourcePaths();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ClangTool"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ClangTool

using Entity_clang_tooling_ClangTool = Bind_clang_tooling_ClangTool<>;

#else

struct Entity_clang_tooling_ClangTool : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ClangTool(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ClangTool"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ClangTool

template <class Pybind11T =
              pybind11::class_<clang::tooling::CodeRangeASTSelection>>
struct Bind_clang_tooling_CodeRangeASTSelection : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getParents() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the parent hierarchy (top to bottom) for the selected nodes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CodeRangeASTSelection_getParents
    handle.def("getParents",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::CodeRangeASTSelection,
                   llvm::ArrayRef<std::reference_wrapper<
                       const clang::tooling::SelectedASTNode>>>::type>(
                   &clang::tooling::CodeRangeASTSelection::getParents),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_size() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the number of selected statements.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CodeRangeASTSelection_size
    handle.def(
        "size",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::CodeRangeASTSelection, unsigned long>::const_type>(
            &clang::tooling::CodeRangeASTSelection::size),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isInFunctionLikeBodyOfCode() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns true when a selected code range is in a function-like body
  /// of code, like a function, method or a block.
  ///
  /// This function can be used to test against selected expressions that are
  /// located outside of a function, e.g. global variable initializers, default
  /// argument values, or even template arguments.
  ///
  /// Use the \c getFunctionLikeNearestParent to get the function-like parent
  /// declaration.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CodeRangeASTSelection_isInFunctionLikeBodyOfCode
    handle.def(
        "isInFunctionLikeBodyOfCode",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::CodeRangeASTSelection, bool>::const_type>(
            &clang::tooling::CodeRangeASTSelection::isInFunctionLikeBodyOfCode),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFunctionLikeNearestParent() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the nearest function-like parent declaration or null if such
  /// declaration doesn't exist.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CodeRangeASTSelection_getFunctionLikeNearestParent
    handle.def(
        "getFunctionLikeNearestParent",
        [](clang::tooling::CodeRangeASTSelection &self) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<clang::tooling::CodeRangeASTSelection,
                                          const clang::Decl *>::const_type>(
                  &clang::tooling::CodeRangeASTSelection::
                      getFunctionLikeNearestParent),
              &self);
          return pybind11_weaver::WrapP<const clang::Decl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_create() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CodeRangeASTSelection_create
    handle.def_static(
        "create",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::tooling::CodeRangeASTSelection>(
                      clang::SourceRange,
                      const clang::tooling::SelectedASTNode &)>::type>(
            &clang::tooling::CodeRangeASTSelection::create));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_CodeRangeASTSelection(EntityScope parent_h)
      : handle{
            parent_h, "CodeRangeASTSelection", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An AST selection value that corresponds to a selection of a set of
/// statements that belong to one body of code (like one function).
///
/// For example, the following selection in the source.
///
/// \code
/// void function() {
///  // selection begin:
///  int x = 0;
///  {
///     // selection end
///     x = 1;
///  }
///  x = 2;
/// }
/// \endcode
///
/// Would correspond to a code range selection of statements "int x = 0"
/// and the entire compound statement that follows it.
///
/// A \c CodeRangeASTSelection value stores references to the full
/// \c SelectedASTNode tree and should not outlive it.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_CodeRangeASTSelection(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getParents();
    AddMethod_size();
    AddMethod_isInFunctionLikeBodyOfCode();
    AddMethod_getFunctionLikeNearestParent();
    AddMethod_create();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::CodeRangeASTSelection>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_CodeRangeASTSelection"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_CodeRangeASTSelection

using Entity_clang_tooling_CodeRangeASTSelection =
    Bind_clang_tooling_CodeRangeASTSelection<>;

#else

struct Entity_clang_tooling_CodeRangeASTSelection
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_CodeRangeASTSelection(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_CodeRangeASTSelection"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_CodeRangeASTSelection

template <class Pybind11T =
              pybind11::class_<clang::tooling::CommonOptionsParser>>
struct Bind_clang_tooling_CommonOptionsParser : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_create() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A factory method that is similar to the above constructor, except
  /// this returns an error instead exiting the program on error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CommonOptionsParser_create
    handle.def_static(
        "create",
        [](clang::tooling::CommonOptionsParser &self, int &argc,
           pybind11_weaver::WrappedPtrT<const char **> argv,
           llvm::cl::OptionCategory &Category,
           llvm::cl::NumOccurrencesFlag OccurrencesFlag, const char *Overview) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, llvm::Expected<clang::tooling::CommonOptionsParser>(
                            int &, const char **, llvm::cl::OptionCategory &,
                            llvm::cl::NumOccurrencesFlag, const char *)>::type>(
                  &clang::tooling::CommonOptionsParser::create),
              argc, (argv)->Cptr(), Category, OccurrencesFlag, Overview);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCompilations() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a reference to the loaded compilations database.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CommonOptionsParser_getCompilations
    handle.def("getCompilations",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::CommonOptionsParser,
                   clang::tooling::CompilationDatabase &>::type>(
                   &clang::tooling::CommonOptionsParser::getCompilations),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSourcePathList() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a list of source file paths to process.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CommonOptionsParser_getSourcePathList
    handle.def("getSourcePathList",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::CommonOptionsParser,
                   const std::vector<std::basic_string<char>> &>::const_type>(
                   &clang::tooling::CommonOptionsParser::getSourcePathList),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getArgumentsAdjuster() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the argument adjuster calculated from "--extra-arg" and
  //"--extra-arg-before" options.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CommonOptionsParser_getArgumentsAdjuster
    handle.def("getArgumentsAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::CommonOptionsParser,
                   std::function<std::vector<std::basic_string<char>>(
                       const std::vector<std::basic_string<char>> &,
                       llvm::StringRef)>>::type>(
                   &clang::tooling::CommonOptionsParser::getArgumentsAdjuster),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_CommonOptionsParser(EntityScope parent_h)
      : handle{
            parent_h, "CommonOptionsParser", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A parser for options common to all command-line Clang tools.
///
/// Parses a common subset of command-line arguments, locates and loads a
/// compilation commands database and runs a tool with user-specified action. It
/// also contains a help message for the common command-line options.
///
/// An example of usage:
/// \code
/// #include "clang/Frontend/FrontendActions.h"
/// #include "clang/Tooling/CommonOptionsParser.h"
/// #include "clang/Tooling/Tooling.h"
/// #include "llvm/Support/CommandLine.h"
///
/// using namespace clang::tooling;
/// using namespace llvm;
///
/// static cl::OptionCategory MyToolCategory("My tool options");
/// static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);
/// static cl::extrahelp MoreHelp("\nMore help text...\n");
/// static cl::opt<bool> YourOwnOption(...);
/// ...
///
/// int main(int argc, const char **argv) {
///   CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);
///   ClangTool Tool(OptionsParser.getCompilations(),
///                  OptionsParser.getSourcePathList());
///   return Tool.run(newFrontendActionFactory<SyntaxOnlyAction>().get());
/// }
/// \endcode)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_CommonOptionsParser(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_create();
    AddMethod_getCompilations();
    AddMethod_getSourcePathList();
    AddMethod_getArgumentsAdjuster();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::CommonOptionsParser>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_CommonOptionsParser"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_CommonOptionsParser

using Entity_clang_tooling_CommonOptionsParser =
    Bind_clang_tooling_CommonOptionsParser<>;

#else

struct Entity_clang_tooling_CommonOptionsParser
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_CommonOptionsParser(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_CommonOptionsParser"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_CommonOptionsParser

template <class = void>
class PyTrampCompilationDatabase : public clang::tooling::CompilationDatabase {
public:
  using _PB11_WR_BaseT = clang::tooling::CompilationDatabase;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasestd_vector6std_string9_9__const
  std::vector<std::basic_string<char>> getAllFiles() const override {
    using _PB11_WR_RET_TYPE = std::vector<std::basic_string<char>>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::CompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getAllFiles,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasestd_vector6std_string9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasestd_vector6CompileCommand9_9__const
  std::vector<clang::tooling::CompileCommand>
  getAllCompileCommands() const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::CompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getAllCompileCommands,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasestd_vector6CompileCommand9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasestd_vector6CompileCommand9_9StringRef__const
  std::vector<clang::tooling::CompileCommand>
  getCompileCommands(llvm::StringRef FilePath) const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::CompilationDatabase;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getCompileCommands, FilePath);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasestd_vector6CompileCommand9_9StringRef__const
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::CompilationDatabase,
                               PyTrampCompilationDatabase<>>>
struct Bind_clang_tooling_CompilationDatabase : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_loadFromDirectory() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Loads a compilation database from a build directory.
  ///
  /// Looks at the specified 'BuildDirectory' and creates a compilation database
  /// that allows to query compile commands for source files in the
  /// corresponding source tree.
  ///
  /// Returns NULL and sets ErrorMessage if we were not able to build up a
  /// compilation database for the build directory.
  ///
  /// FIXME: Currently only supports JSON compilation databases, which
  /// are named 'compile_commands.json' in the given directory. Extend this
  /// for other build types (like ninja build files).)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_loadFromDirectory
#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_loadFromDirectory
    handle.def_static("loadFromDirectory", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_autoDetectFromSource() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Tries to detect a compilation database location and load it.
  ///
  /// Looks for a compilation database in all parent paths of file 'SourceFile'
  /// by calling loadFromDirectory.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_autoDetectFromSource
#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_autoDetectFromSource
    handle.def_static("autoDetectFromSource", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_autoDetectFromDirectory() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Tries to detect a compilation database location and load it.
  ///
  /// Looks for a compilation database in directory 'SourceDir' and all
  /// its parent paths by calling loadFromDirectory.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_autoDetectFromDirectory
#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_autoDetectFromDirectory
    handle.def_static("autoDetectFromDirectory", None,
                      _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCompileCommands() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns all compile commands in which the specified file was
  /// compiled.
  ///
  /// This includes compile commands that span multiple source files.
  /// For example, consider a project with the following compilations:
  /// $ clang++ -o test a.cc b.cc t.cc
  /// $ clang++ -o production a.cc b.cc -DPRODUCTION
  /// A compilation database representing the project would return both command
  /// lines for a.cc and b.cc and only the first command line for t.cc.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_getCompileCommands
    handle.def(
        "getCompileCommands",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::CompilationDatabase,
                                    std::vector<clang::tooling::CompileCommand>,
                                    llvm::StringRef>::const_type>(
            &clang::tooling::CompilationDatabase::getCompileCommands),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAllFiles() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the list of all files available in the compilation database.
  ///
  /// By default, returns nothing. Implementations should override this if they
  /// can enumerate their source files.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_getAllFiles
    handle.def("getAllFiles",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::CompilationDatabase,
                   std::vector<std::basic_string<char>>>::const_type>(
                   &clang::tooling::CompilationDatabase::getAllFiles),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAllCompileCommands() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns all compile commands for all the files in the compilation
  /// database.
  ///
  /// FIXME: Add a layer in Tooling that provides an interface to run a tool
  /// over all files in a compilation database. Not all build systems have the
  /// ability to provide a feasible implementation for \c getAllCompileCommands.
  ///
  /// By default, this is implemented in terms of getAllFiles() and
  /// getCompileCommands(). Subclasses may override this for efficiency.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabase_getAllCompileCommands
    handle.def("getAllCompileCommands",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::CompilationDatabase,
                   std::vector<clang::tooling::CompileCommand>>::const_type>(
                   &clang::tooling::CompilationDatabase::getAllCompileCommands),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_CompilationDatabase(EntityScope parent_h)
      : handle{parent_h, "CompilationDatabase", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Interface for compilation databases.
///
/// A compilation database allows the user to retrieve compile command lines
/// for the files in a project.
///
/// Many implementations are enumerable, allowing all command lines to be
/// retrieved. These can be used to run clang tools over a subset of the files
/// in a project.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_CompilationDatabase(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_loadFromDirectory();
    AddMethod_autoDetectFromSource();
    AddMethod_autoDetectFromDirectory();
    AddMethod_getCompileCommands();
    AddMethod_getAllFiles();
    AddMethod_getAllCompileCommands();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::CompilationDatabase>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_CompilationDatabase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_CompilationDatabase

using Entity_clang_tooling_CompilationDatabase =
    Bind_clang_tooling_CompilationDatabase<>;

#else

struct Entity_clang_tooling_CompilationDatabase
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_CompilationDatabase(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_CompilationDatabase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_CompilationDatabase

template <class = void>
class PyTrampCompilationDatabasePlugin
    : public clang::tooling::CompilationDatabasePlugin {
public:
  using _PB11_WR_BaseT = clang::tooling::CompilationDatabasePlugin;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasePluginstd_unique_ptr6CompilationDatabase9_9StringRef__std_string___
  std::unique_ptr<clang::tooling::CompilationDatabase>
  loadFromDirectory(llvm::StringRef Directory,
                    std::basic_string<char> &ErrorMessage) override {
    using _PB11_WR_RET_TYPE =
        std::unique_ptr<clang::tooling::CompilationDatabase>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::CompilationDatabasePlugin;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           loadFromDirectory, Directory, ErrorMessage);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_CompilationDatabasePluginstd_unique_ptr6CompilationDatabase9_9StringRef__std_string___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::CompilationDatabasePlugin,
                               PyTrampCompilationDatabasePlugin<>>>
struct Bind_clang_tooling_CompilationDatabasePlugin : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_loadFromDirectory() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Loads a compilation database from a build directory.
  ///
  /// \see CompilationDatabase::loadFromDirectory().)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabasePlugin_loadFromDirectory
#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompilationDatabasePlugin_loadFromDirectory
    handle.def("loadFromDirectory", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_CompilationDatabasePlugin(EntityScope parent_h)
      : handle{parent_h, "CompilationDatabasePlugin", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Interface for compilation database plugins.
///
/// A compilation database plugin allows the user to register custom compilation
/// databases that are picked up as compilation database if the corresponding
/// library is linked in. To register a plugin, declare a static variable like:
///
/// \code
/// static CompilationDatabasePluginRegistry::Add<MyDatabasePlugin>
/// X("my-compilation-database", "Reads my own compilation database");
/// \endcode)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_CompilationDatabasePlugin(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_loadFromDirectory();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::CompilationDatabasePlugin>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_CompilationDatabasePlugin"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_CompilationDatabasePlugin

using Entity_clang_tooling_CompilationDatabasePlugin =
    Bind_clang_tooling_CompilationDatabasePlugin<>;

#else

struct Entity_clang_tooling_CompilationDatabasePlugin
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_CompilationDatabasePlugin(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_CompilationDatabasePlugin"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_CompilationDatabasePlugin

template <class Pybind11T = pybind11::class_<clang::tooling::CompileCommand>>
struct Bind_clang_tooling_CompileCommand : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Specifies the working directory and command of a compilation.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompileCommand_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Specifies the working directory and command of a compilation.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CompileCommand_Ctor1
    handle.def(pybind11::init<const llvm::Twine &, const llvm::Twine &,
                              std::vector<std::basic_string<char>>,
                              const llvm::Twine &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_CompileCommand(EntityScope parent_h)
      : handle{parent_h, "CompileCommand", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Specifies the working directory and command of a compilation.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_CompileCommand(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddCtor0();
    AddCtor1();
    handle.def_readwrite(
        "Directory", &clang::tooling::CompileCommand::Directory,
        R"_pb11_weaver(/// The working directory the command was executed from.)_pb11_weaver");
    handle.def_readwrite(
        "Filename", &clang::tooling::CompileCommand::Filename,
        R"_pb11_weaver(/// The source file associated with the command.)_pb11_weaver");
    handle.def_readwrite(
        "Output", &clang::tooling::CompileCommand::Output,
        R"_pb11_weaver(/// The output file associated with the command.)_pb11_weaver");
    handle.def_readwrite(
        "Heuristic", &clang::tooling::CompileCommand::Heuristic,
        R"_pb11_weaver(/// If this compile command was guessed rather than read from an authoritative
  /// source, a short human-readable explanation.
  /// e.g. "inferred from foo/bar.h".)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_CompileCommand"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_CompileCommand

using Entity_clang_tooling_CompileCommand = Bind_clang_tooling_CompileCommand<>;

#else

struct Entity_clang_tooling_CompileCommand
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_CompileCommand(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_CompileCommand"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_CompileCommand

template <class Pybind11T = pybind11::class_<clang::tooling::Diagnostic>>
struct Bind_clang_tooling_Diagnostic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents the diagnostic with the level of severity and possible
/// fixes to be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Diagnostic_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents the diagnostic with the level of severity and possible
/// fixes to be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Diagnostic_Ctor1
    handle.def(
        pybind11::init<llvm::StringRef, clang::tooling::Diagnostic::Level,
                       llvm::StringRef>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor2() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents the diagnostic with the level of severity and possible
/// fixes to be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Diagnostic_Ctor2
    handle.def(
        pybind11::init<
            llvm::StringRef, const clang::tooling::DiagnosticMessage &,
            const llvm::SmallVector<clang::tooling::DiagnosticMessage, 1> &,
            clang::tooling::Diagnostic::Level, llvm::StringRef>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_Diagnostic(EntityScope parent_h)
      : handle{
            parent_h, "Diagnostic", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Represents the diagnostic with the level of severity and possible
/// fixes to be applied.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_Diagnostic(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddCtor0();
    AddCtor1();
    AddCtor2();
    handle.def_readwrite(
        "DiagnosticName", &clang::tooling::Diagnostic::DiagnosticName,
        R"_pb11_weaver(/// Name identifying the Diagnostic.)_pb11_weaver");
    handle.def_readwrite(
        "DiagLevel", &clang::tooling::Diagnostic::DiagLevel,
        R"_pb11_weaver(/// Diagnostic level. Can indicate either an error or a warning.)_pb11_weaver");
    handle.def_readwrite(
        "BuildDirectory", &clang::tooling::Diagnostic::BuildDirectory,
        R"_pb11_weaver(/// A build directory of the diagnostic source file.
  ///
  /// It's an absolute path which is `directory` field of the source file in
  /// compilation database. If users don't specify the compilation database
  /// directory, it is the current directory where clang-tidy runs.
  ///
  /// Note: it is empty in unittest.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_Diagnostic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_Diagnostic

using Entity_clang_tooling_Diagnostic = Bind_clang_tooling_Diagnostic<>;

#else

struct Entity_clang_tooling_Diagnostic
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_Diagnostic(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_Diagnostic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_Diagnostic

template <class Pybind11T = pybind11::enum_<clang::tooling::Diagnostic::Level>>
struct Bind_clang_tooling_Diagnostic_Level : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_Diagnostic_Level(EntityScope parent_h)
      : handle{parent_h, "Level", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_Diagnostic_Level(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Remark", clang::tooling::Diagnostic::Level::Remark);
    handle.value("Warning", clang::tooling::Diagnostic::Level::Warning);
    handle.value("Error", clang::tooling::Diagnostic::Level::Error);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_Diagnostic_Level"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_Diagnostic_Level

using Entity_clang_tooling_Diagnostic_Level =
    Bind_clang_tooling_Diagnostic_Level<>;

#else

struct Entity_clang_tooling_Diagnostic_Level
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_Diagnostic_Level(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_Diagnostic_Level"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_Diagnostic_Level

template <class Pybind11T = pybind11::class_<clang::tooling::DiagnosticMessage>>
struct Bind_clang_tooling_DiagnosticMessage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents the diagnostic message with the error message associated
/// and the information on the location of the problem.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_DiagnosticMessage_Ctor0
    handle.def(pybind11::init<llvm::StringRef>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents the diagnostic message with the error message associated
/// and the information on the location of the problem.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_DiagnosticMessage_Ctor1
    handle.def(pybind11::init<llvm::StringRef, const clang::SourceManager &,
                              clang::SourceLocation>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_DiagnosticMessage(EntityScope parent_h)
      : handle{
            parent_h, "DiagnosticMessage", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Represents the diagnostic message with the error message associated
/// and the information on the location of the problem.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_DiagnosticMessage(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddCtor0();
    AddCtor1();
    handle.def_readwrite("Message",
                         &clang::tooling::DiagnosticMessage::Message);
    handle.def_readwrite("FilePath",
                         &clang::tooling::DiagnosticMessage::FilePath);
    handle.def_readwrite("FileOffset",
                         &clang::tooling::DiagnosticMessage::FileOffset);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_DiagnosticMessage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_DiagnosticMessage

using Entity_clang_tooling_DiagnosticMessage =
    Bind_clang_tooling_DiagnosticMessage<>;

#else

struct Entity_clang_tooling_DiagnosticMessage
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_DiagnosticMessage(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_DiagnosticMessage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_DiagnosticMessage

template <class = void>
class PyTrampExecutionContext : public clang::tooling::ExecutionContext {
public:
  using _PB11_WR_BaseT = clang::tooling::ExecutionContext;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ExecutionContextstd_string_9_
  std::basic_string<char> getRevision() override {
    using _PB11_WR_RET_TYPE = std::basic_string<char>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ExecutionContext;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getRevision,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ExecutionContextstd_string_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ExecutionContextstd_string_9_
  std::basic_string<char> getCorpus() override {
    using _PB11_WR_RET_TYPE = std::basic_string<char>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ExecutionContext;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getCorpus,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ExecutionContextstd_string_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ExecutionContextstd_string_9_
  std::basic_string<char> getCurrentCompilationUnit() override {
    using _PB11_WR_RET_TYPE = std::basic_string<char>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ExecutionContext;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCurrentCompilationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ExecutionContextstd_string_9_
};

template <class Pybind11T = pybind11::class_<clang::tooling::ExecutionContext,
                                             PyTrampExecutionContext<>>>
struct Bind_clang_tooling_ExecutionContext : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_reportResult() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a KV pair to the result container of this execution.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExecutionContext_reportResult
    handle.def(
        "reportResult",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ExecutionContext, void,
                                    llvm::StringRef, llvm::StringRef>::type>(
            &clang::tooling::ExecutionContext::reportResult),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRevision() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the source control system's revision number if applicable.
  // Otherwise returns an empty string.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExecutionContext_getRevision
    handle.def(
        "getRevision",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::ExecutionContext,
                                            std::basic_string<char>>::type>(
            &clang::tooling::ExecutionContext::getRevision),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCorpus() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the corpus being analyzed, e.g. "llvm" for the LLVM codebase, if
  // applicable.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExecutionContext_getCorpus
    handle.def(
        "getCorpus",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::ExecutionContext,
                                            std::basic_string<char>>::type>(
            &clang::tooling::ExecutionContext::getCorpus),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCurrentCompilationUnit() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the currently processed compilation unit if available.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExecutionContext_getCurrentCompilationUnit
    handle.def(
        "getCurrentCompilationUnit",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::ExecutionContext,
                                            std::basic_string<char>>::type>(
            &clang::tooling::ExecutionContext::getCurrentCompilationUnit),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The context of an execution, including the information about
/// compilation and results.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExecutionContext_Ctor0
    handle.def(pybind11::init<clang::tooling::ToolResults *>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ExecutionContext(EntityScope parent_h)
      : handle{
            parent_h, "ExecutionContext", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// The context of an execution, including the information about
/// compilation and results.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ExecutionContext(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_reportResult();
    AddMethod_getRevision();
    AddMethod_getCorpus();
    AddMethod_getCurrentCompilationUnit();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ExecutionContext"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ExecutionContext

using Entity_clang_tooling_ExecutionContext =
    Bind_clang_tooling_ExecutionContext<>;

#else

struct Entity_clang_tooling_ExecutionContext
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ExecutionContext(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ExecutionContext"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ExecutionContext

template <class Pybind11T =
              pybind11::class_<clang::tooling::ExtractionSemicolonPolicy>>
struct Bind_clang_tooling_ExtractionSemicolonPolicy : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_isNeededInExtractedFunction() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExtractionSemicolonPolicy_isNeededInExtractedFunction
    handle.def(
        "isNeededInExtractedFunction",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ExtractionSemicolonPolicy, bool>::const_type>(
            &clang::tooling::ExtractionSemicolonPolicy::
                isNeededInExtractedFunction));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isNeededInOriginalFunction() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExtractionSemicolonPolicy_isNeededInOriginalFunction
    handle.def(
        "isNeededInOriginalFunction",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ExtractionSemicolonPolicy, bool>::const_type>(
            &clang::tooling::ExtractionSemicolonPolicy::
                isNeededInOriginalFunction));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_compute() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the semicolon insertion policy that is needed for extraction of
  /// the given statement from the given source range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExtractionSemicolonPolicy_compute
    handle.def_static(
        "compute",
        [](clang::tooling::ExtractionSemicolonPolicy &self,
           pybind11_weaver::WrappedPtrT<const clang::Stmt *> S,
           clang::SourceRange &ExtractedRange, const clang::SourceManager &SM,
           const clang::LangOptions &LangOpts) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, clang::tooling::ExtractionSemicolonPolicy(
                            const clang::Stmt *, clang::SourceRange &,
                            const clang::SourceManager &,
                            const clang::LangOptions &)>::type>(
                  &clang::tooling::ExtractionSemicolonPolicy::compute),
              (S)->Cptr(), ExtractedRange, SM, LangOpts);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ExtractionSemicolonPolicy(EntityScope parent_h)
      : handle{parent_h, "ExtractionSemicolonPolicy", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Determines which semicolons should be inserted during extraction.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ExtractionSemicolonPolicy(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_isNeededInExtractedFunction();
    AddMethod_isNeededInOriginalFunction();
    AddMethod_compute();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::ExtractionSemicolonPolicy>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ExtractionSemicolonPolicy"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ExtractionSemicolonPolicy

using Entity_clang_tooling_ExtractionSemicolonPolicy =
    Bind_clang_tooling_ExtractionSemicolonPolicy<>;

#else

struct Entity_clang_tooling_ExtractionSemicolonPolicy
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ExtractionSemicolonPolicy(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ExtractionSemicolonPolicy"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ExtractionSemicolonPolicy

template <class Pybind11T = pybind11::class_<clang::tooling::FileByteRange>>
struct Bind_clang_tooling_FileByteRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents a range within a specific source file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FileByteRange_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents a range within a specific source file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FileByteRange_Ctor1
    handle.def(
        pybind11::init<const clang::SourceManager &, clang::CharSourceRange>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_FileByteRange(EntityScope parent_h)
      : handle{parent_h, "FileByteRange", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Represents a range within a specific source file.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_FileByteRange(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddCtor0();
    AddCtor1();
    handle.def_readwrite("FilePath", &clang::tooling::FileByteRange::FilePath);
    handle.def_readwrite("FileOffset",
                         &clang::tooling::FileByteRange::FileOffset);
    handle.def_readwrite("Length", &clang::tooling::FileByteRange::Length);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_FileByteRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_FileByteRange

using Entity_clang_tooling_FileByteRange = Bind_clang_tooling_FileByteRange<>;

#else

struct Entity_clang_tooling_FileByteRange
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_FileByteRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_FileByteRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_FileByteRange

template <class Pybind11T = pybind11::class_<clang::tooling::FileMatchTrie>>
struct Bind_clang_tooling_FileMatchTrie : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_insert() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Insert a new absolute path. Relative paths are ignored.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FileMatchTrie_insert
    handle.def(
        "insert",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::FileMatchTrie, void,
                                            llvm::StringRef>::type>(
            &clang::tooling::FileMatchTrie::insert),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findEquivalent() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Finds the corresponding file in this trie.
  ///
  /// Returns file name stored in this trie that is equivalent to 'FileName'
  /// according to 'Comparator', if it can be uniquely identified. If there
  /// are no matches an empty \c StringRef is returned. If there are ambiguous
  /// matches, an empty \c StringRef is returned and a corresponding message
  /// written to 'Error'.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FileMatchTrie_findEquivalent
    handle.def(
        "findEquivalent",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::FileMatchTrie,
                                            llvm::StringRef, llvm::StringRef,
                                            llvm::raw_ostream &>::const_type>(
            &clang::tooling::FileMatchTrie::findEquivalent),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A trie to efficiently match against the entries of the compilation
/// database in order of matching suffix length.
///
/// When a clang tool is supposed to operate on a specific file, we have to
/// find the corresponding file in the compilation database. Although entries
/// in the compilation database are keyed by filename, a simple string match
/// is insufficient because of symlinks. Commonly, a project hierarchy looks
/// like this:
///   /<project-root>/src/<path>/<somefile>.cc      (used as input for the tool)
///   /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB)
///
/// Furthermore, there might be symlinks inside the source folder or inside the
/// database, so that the same source file is translated with different build
/// options.
///
/// For a given input file, the \c FileMatchTrie finds its entries in order
/// of matching suffix length. For each suffix length, there might be one or
/// more entries in the database. For each of those entries, it calls
/// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might
/// be zero or more entries with the same matching suffix length that are
/// equivalent to the input file. Three cases are distinguished:
/// 0  equivalent files: Continue with the next suffix length.
/// 1  equivalent file:  Best match found, return it.
/// >1 equivalent files: Match is ambiguous, return error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FileMatchTrie_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A trie to efficiently match against the entries of the compilation
/// database in order of matching suffix length.
///
/// When a clang tool is supposed to operate on a specific file, we have to
/// find the corresponding file in the compilation database. Although entries
/// in the compilation database are keyed by filename, a simple string match
/// is insufficient because of symlinks. Commonly, a project hierarchy looks
/// like this:
///   /<project-root>/src/<path>/<somefile>.cc      (used as input for the tool)
///   /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB)
///
/// Furthermore, there might be symlinks inside the source folder or inside the
/// database, so that the same source file is translated with different build
/// options.
///
/// For a given input file, the \c FileMatchTrie finds its entries in order
/// of matching suffix length. For each suffix length, there might be one or
/// more entries in the database. For each of those entries, it calls
/// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might
/// be zero or more entries with the same matching suffix length that are
/// equivalent to the input file. Three cases are distinguished:
/// 0  equivalent files: Continue with the next suffix length.
/// 1  equivalent file:  Best match found, return it.
/// >1 equivalent files: Match is ambiguous, return error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FileMatchTrie_Ctor1
    handle.def(pybind11::init<clang::tooling::PathComparator *>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_FileMatchTrie(EntityScope parent_h)
      : handle{
            parent_h, "FileMatchTrie", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A trie to efficiently match against the entries of the compilation
/// database in order of matching suffix length.
///
/// When a clang tool is supposed to operate on a specific file, we have to
/// find the corresponding file in the compilation database. Although entries
/// in the compilation database are keyed by filename, a simple string match
/// is insufficient because of symlinks. Commonly, a project hierarchy looks
/// like this:
///   /<project-root>/src/<path>/<somefile>.cc      (used as input for the tool)
///   /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB)
///
/// Furthermore, there might be symlinks inside the source folder or inside the
/// database, so that the same source file is translated with different build
/// options.
///
/// For a given input file, the \c FileMatchTrie finds its entries in order
/// of matching suffix length. For each suffix length, there might be one or
/// more entries in the database. For each of those entries, it calls
/// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might
/// be zero or more entries with the same matching suffix length that are
/// equivalent to the input file. Three cases are distinguished:
/// 0  equivalent files: Continue with the next suffix length.
/// 1  equivalent file:  Best match found, return it.
/// >1 equivalent files: Match is ambiguous, return error.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_FileMatchTrie(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_insert();
    AddMethod_findEquivalent();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_FileMatchTrie"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_FileMatchTrie

using Entity_clang_tooling_FileMatchTrie = Bind_clang_tooling_FileMatchTrie<>;

#else

struct Entity_clang_tooling_FileMatchTrie
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_FileMatchTrie(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_FileMatchTrie"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_FileMatchTrie

template <class = void>
class PyTrampFixedCompilationDatabase1
    : public clang::tooling::FixedCompilationDatabase {
public:
  using _PB11_WR_BaseT = clang::tooling::FixedCompilationDatabase;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_FixedCompilationDatabasestd_vector6std_string9_9__const
  std::vector<std::basic_string<char>> getAllFiles() const override {
    using _PB11_WR_RET_TYPE = std::vector<std::basic_string<char>>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::FixedCompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getAllFiles,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_FixedCompilationDatabasestd_vector6std_string9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_FixedCompilationDatabasestd_vector6CompileCommand9_9__const
  std::vector<clang::tooling::CompileCommand>
  getAllCompileCommands() const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::FixedCompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getAllCompileCommands,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_FixedCompilationDatabasestd_vector6CompileCommand9_9__const
};

template <class = void>
class PyTrampFixedCompilationDatabase
    : public PyTrampFixedCompilationDatabase1<> {
public:
  using _PB11_WR_BaseT = PyTrampFixedCompilationDatabase1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_FixedCompilationDatabasestd_vector6CompileCommand9_9StringRef__const
  std::vector<clang::tooling::CompileCommand>
  getCompileCommands(llvm::StringRef FilePath) const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::FixedCompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCompileCommands, FilePath);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_FixedCompilationDatabasestd_vector6CompileCommand9_9StringRef__const
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::FixedCompilationDatabase,
                               PyTrampFixedCompilationDatabase<>,
                               clang::tooling::CompilationDatabase>>
struct Bind_clang_tooling_FixedCompilationDatabase : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_loadFromCommandLine() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Creates a FixedCompilationDatabase from the arguments after "--".
  ///
  /// Parses the given command line for "--". If "--" is found, the rest of
  /// the arguments will make up the command line in the returned
  /// FixedCompilationDatabase.
  /// The arguments after "--" must not include positional parameters or the
  /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase
  /// when a CompileCommand is requested. The argv[0] of the returned command
  /// line will be "clang-tool".
  ///
  /// Returns NULL in case "--" is not found.
  ///
  /// The argument list is meant to be compatible with normal llvm command line
  /// parsing in main methods.
  /// int main(int argc, char **argv) {
  ///   std::unique_ptr<FixedCompilationDatabase> Compilations(
  ///     FixedCompilationDatabase::loadFromCommandLine(argc, argv));
  ///   cl::ParseCommandLineOptions(argc, argv);
  ///   ...
  /// }
  ///
  /// \param Argc The number of command line arguments - will be changed to
  /// the number of arguments before "--", if "--" was found in the argument
  /// list.
  /// \param Argv Points to the command line arguments.
  /// \param ErrorMsg Contains error text if the function returns null pointer.
  /// \param Directory The base directory used in the FixedCompilationDatabase.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_loadFromCommandLine
#ifndef PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_loadFromCommandLine
    handle.def_static("loadFromCommandLine", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_loadFromFile() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Reads flags from the given file, one-per-line.
  /// Returns nullptr and sets ErrorMessage if we can't read the file.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_loadFromFile
#ifndef PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_loadFromFile
    handle.def_static("loadFromFile", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_loadFromBuffer() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Reads flags from the given buffer, one-per-line.
  /// Directory is the command CWD, typically the parent of compile_flags.txt.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_loadFromBuffer
#ifndef PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_loadFromBuffer
    handle.def_static("loadFromBuffer", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCompileCommands() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the given compile command.
  ///
  /// Will always return a vector with one entry that contains the directory
  /// and command line specified at construction with "clang-tool" as argv[0]
  /// and 'FilePath' as positional argument.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_getCompileCommands
    handle.def(
        "getCompileCommands",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::FixedCompilationDatabase,
                                    std::vector<clang::tooling::CompileCommand>,
                                    llvm::StringRef>::const_type>(
            &clang::tooling::FixedCompilationDatabase::getCompileCommands),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A compilation database that returns a single compile command line.
///
/// Useful when we want a tool to behave more like a compiler invocation.
/// This compilation database is not enumerable: getAllFiles() returns {}.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FixedCompilationDatabase_Ctor0
    handle.def(pybind11::init<const llvm::Twine &,
                              llvm::ArrayRef<std::basic_string<char>>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_FixedCompilationDatabase(EntityScope parent_h)
      : handle{parent_h, "FixedCompilationDatabase", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A compilation database that returns a single compile command line.
///
/// Useful when we want a tool to behave more like a compiler invocation.
/// This compilation database is not enumerable: getAllFiles() returns {}.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_FixedCompilationDatabase(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_loadFromCommandLine();
    AddMethod_loadFromFile();
    AddMethod_loadFromBuffer();
    AddMethod_getCompileCommands();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_FixedCompilationDatabase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_FixedCompilationDatabase

using Entity_clang_tooling_FixedCompilationDatabase =
    Bind_clang_tooling_FixedCompilationDatabase<>;

#else

struct Entity_clang_tooling_FixedCompilationDatabase
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_FixedCompilationDatabase(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_tooling_FixedCompilationDatabase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_FixedCompilationDatabase

template <class Pybind11T = pybind11::class_<clang::tooling::HeaderIncludes>>
struct Bind_clang_tooling_HeaderIncludes : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_insert() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Inserts an #include or #import directive of \p Header into the code.
  /// If \p IsAngled is true, \p Header will be quoted with <> in the directive;
  /// otherwise, it will be quoted with "".
  ///
  /// When searching for points to insert new header, this ignores #include's
  /// after the #include block(s) in the beginning of a file to avoid inserting
  /// headers into code sections where new #include's should not be added by
  /// default. These code sections include:
  ///   - raw string literals (containing #include).
  ///   - #if blocks.
  ///   - Special #include's among declarations (e.g. functions).
  ///
  /// Returns a replacement that inserts the new header into a suitable #include
  /// block of the same category. This respects the order of the existing
  /// #includes in the block; if the existing #includes are not already sorted,
  /// this will simply insert the #include in front of the first #include of the
  /// same category in the code that should be sorted after \p IncludeName. If
  /// \p IncludeName already exists (with exactly the same spelling), this
  /// returns std::nullopt.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_HeaderIncludes_insert
    handle.def("insert",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::HeaderIncludes,
                   std::optional<clang::tooling::Replacement>, llvm::StringRef,
                   bool, clang::tooling::IncludeDirective>::const_type>(
                   &clang::tooling::HeaderIncludes::insert),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_remove() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Removes all existing #includes and #imports of \p Header quoted with <> if
  /// \p IsAngled is true or "" if \p IsAngled is false.
  /// This doesn't resolve the header file path; it only deletes #includes and
  /// #imports with exactly the same spelling.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_HeaderIncludes_remove
    handle.def(
        "remove",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::HeaderIncludes,
                                            clang::tooling::Replacements,
                                            llvm::StringRef, bool>::const_type>(
            &clang::tooling::HeaderIncludes::remove),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Generates replacements for inserting or deleting #include directives in a
/// file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_HeaderIncludes_Ctor0
    handle.def(pybind11::init<llvm::StringRef, llvm::StringRef,
                              const clang::tooling::IncludeStyle &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_HeaderIncludes(EntityScope parent_h)
      : handle{
            parent_h, "HeaderIncludes", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Generates replacements for inserting or deleting #include directives in a
/// file.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_HeaderIncludes(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_insert();
    AddMethod_remove();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_HeaderIncludes"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_HeaderIncludes

using Entity_clang_tooling_HeaderIncludes = Bind_clang_tooling_HeaderIncludes<>;

#else

struct Entity_clang_tooling_HeaderIncludes
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_HeaderIncludes(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_HeaderIncludes"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_HeaderIncludes

template <class Pybind11T =
              pybind11::class_<clang::tooling::IncludeCategoryManager>>
struct Bind_clang_tooling_IncludeCategoryManager : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getIncludePriority() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the priority of the category which \p IncludeName belongs to.
  /// If \p CheckMainHeader is true and \p IncludeName is a main header, returns
  /// 0. Otherwise, returns the priority of the matching category or INT_MAX.
  /// NOTE: this API is not thread-safe!)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_IncludeCategoryManager_getIncludePriority
    handle.def(
        "getIncludePriority",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::IncludeCategoryManager, int,
                                    llvm::StringRef, bool>::const_type>(
            &clang::tooling::IncludeCategoryManager::getIncludePriority),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSortIncludePriority() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_IncludeCategoryManager_getSortIncludePriority
    handle.def(
        "getSortIncludePriority",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::IncludeCategoryManager, int,
                                    llvm::StringRef, bool>::const_type>(
            &clang::tooling::IncludeCategoryManager::getSortIncludePriority));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// This class manages priorities of C++ #include categories and calculates
/// priorities for headers.
/// FIXME(ioeric): move this class into implementation file when clang-format's
/// include sorting functions are also moved here.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_IncludeCategoryManager_Ctor0
    handle.def(
        pybind11::init<const clang::tooling::IncludeStyle &, llvm::StringRef>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_IncludeCategoryManager(EntityScope parent_h)
      : handle{
            parent_h, "IncludeCategoryManager", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// This class manages priorities of C++ #include categories and calculates
/// priorities for headers.
/// FIXME(ioeric): move this class into implementation file when clang-format's
/// include sorting functions are also moved here.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_IncludeCategoryManager(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getIncludePriority();
    AddMethod_getSortIncludePriority();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_IncludeCategoryManager"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeCategoryManager

using Entity_clang_tooling_IncludeCategoryManager =
    Bind_clang_tooling_IncludeCategoryManager<>;

#else

struct Entity_clang_tooling_IncludeCategoryManager
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_IncludeCategoryManager(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_IncludeCategoryManager"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeCategoryManager

template <class Pybind11T = pybind11::enum_<clang::tooling::IncludeDirective>>
struct Bind_clang_tooling_IncludeDirective : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_IncludeDirective(EntityScope parent_h)
      : handle{parent_h, "IncludeDirective", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_IncludeDirective(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Include", clang::tooling::IncludeDirective::Include);
    handle.value("Import", clang::tooling::IncludeDirective::Import);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_IncludeDirective"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeDirective

using Entity_clang_tooling_IncludeDirective =
    Bind_clang_tooling_IncludeDirective<>;

#else

struct Entity_clang_tooling_IncludeDirective
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_IncludeDirective(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_IncludeDirective"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeDirective

template <class Pybind11T = pybind11::class_<clang::tooling::IncludeStyle>>
struct Bind_clang_tooling_IncludeStyle : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_IncludeStyle(EntityScope parent_h)
      : handle{parent_h, "IncludeStyle", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Style for sorting and grouping C++ #include directives.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_IncludeStyle(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::IncludeStyle>(handle);
    handle.def_readwrite(
        "IncludeBlocks", &clang::tooling::IncludeStyle::IncludeBlocks,
        R"_pb11_weaver(/// Dependent on the value, multiple ``#include`` blocks can be sorted
  /// as one and divided based on category.
  /// \version 6)_pb11_weaver");
    handle.def_readwrite(
        "IncludeIsMainRegex", &clang::tooling::IncludeStyle::IncludeIsMainRegex,
        R"_pb11_weaver(/// Specify a regular expression of suffixes that are allowed in the
  /// file-to-main-include mapping.
  ///
  /// When guessing whether a #include is the "main" include (to assign
  /// category 0, see above), use this regex of allowed suffixes to the header
  /// stem. A partial match is done, so that:
  /// - "" means "arbitrary suffix"
  /// - "$" means "no suffix"
  ///
  /// For example, if configured to "(_test)?$", then a header a.h would be seen
  /// as the "main" include in both a.cc and a_test.cc.
  /// \version 3.9)_pb11_weaver");
    handle.def_readwrite(
        "IncludeIsMainSourceRegex",
        &clang::tooling::IncludeStyle::IncludeIsMainSourceRegex,
        R"_pb11_weaver(/// Specify a regular expression for files being formatted
  /// that are allowed to be considered "main" in the
  /// file-to-main-include mapping.
  ///
  /// By default, clang-format considers files as "main" only when they end
  /// with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``
  /// extensions.
  /// For these files a guessing of "main" include takes place
  /// (to assign category 0, see above). This config option allows for
  /// additional suffixes and extensions for files to be considered as "main".
  ///
  /// For example, if this option is configured to ``(Impl\.hpp)$``,
  /// then a file ``ClassImpl.hpp`` is considered "main" (in addition to
  /// ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and "main
  /// include file" logic will be executed (with *IncludeIsMainRegex* setting
  /// also being respected in later phase). Without this option set,
  /// ``ClassImpl.hpp`` would not have the main include file put on top
  /// before any other include.
  /// \version 10)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_IncludeStyle"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeStyle

using Entity_clang_tooling_IncludeStyle = Bind_clang_tooling_IncludeStyle<>;

#else

struct Entity_clang_tooling_IncludeStyle
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_IncludeStyle(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_IncludeStyle"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeStyle

template <class Pybind11T =
              pybind11::enum_<clang::tooling::IncludeStyle::IncludeBlocksStyle>>
struct Bind_clang_tooling_IncludeStyle_IncludeBlocksStyle : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_IncludeStyle_IncludeBlocksStyle(
      EntityScope parent_h)
      : handle{parent_h, "IncludeBlocksStyle", pybind11::arithmetic(),
               R"_pb11_weaver(/// Styles for sorting multiple ``#include`` blocks.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_IncludeStyle_IncludeBlocksStyle(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("IBS_Preserve",
                 clang::tooling::IncludeStyle::IncludeBlocksStyle::IBS_Preserve,
                 R"_pb11_weaver(/// Sort each ``#include`` block separately.
    /// \code
    ///    #include "b.h"               into      #include "b.h"
    ///
    ///    #include <lib/main.h>                  #include "a.h"
    ///    #include "a.h"                         #include <lib/main.h>
    /// \endcode)_pb11_weaver");
    handle.value(
        "IBS_Merge",
        clang::tooling::IncludeStyle::IncludeBlocksStyle::IBS_Merge,
        R"_pb11_weaver(/// Merge multiple ``#include`` blocks together and sort as one.
    /// \code
    ///    #include "b.h"               into      #include "a.h"
    ///                                           #include "b.h"
    ///    #include <lib/main.h>                  #include <lib/main.h>
    ///    #include "a.h"
    /// \endcode)_pb11_weaver");
    handle.value(
        "IBS_Regroup",
        clang::tooling::IncludeStyle::IncludeBlocksStyle::IBS_Regroup,
        R"_pb11_weaver(/// Merge multiple ``#include`` blocks together and sort as one.
    /// Then split into groups based on category priority. See
    /// ``IncludeCategories``.
    /// \code
    ///    #include "b.h"               into      #include "a.h"
    ///                                           #include "b.h"
    ///    #include <lib/main.h>
    ///    #include "a.h"                         #include <lib/main.h>
    /// \endcode)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_IncludeStyle_IncludeBlocksStyle";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeStyle_IncludeBlocksStyle

using Entity_clang_tooling_IncludeStyle_IncludeBlocksStyle =
    Bind_clang_tooling_IncludeStyle_IncludeBlocksStyle<>;

#else

struct Entity_clang_tooling_IncludeStyle_IncludeBlocksStyle
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_IncludeStyle_IncludeBlocksStyle(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_IncludeStyle_IncludeBlocksStyle";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeStyle_IncludeBlocksStyle

template <class Pybind11T =
              pybind11::class_<clang::tooling::IncludeStyle::IncludeCategory>>
struct Bind_clang_tooling_IncludeStyle_IncludeCategory : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_IncludeStyle_IncludeCategory(EntityScope parent_h)
      : handle{parent_h, "IncludeCategory", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// See documentation of ``IncludeCategories``.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_IncludeStyle_IncludeCategory(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::IncludeStyle::IncludeCategory>(handle);
    handle.def_readwrite(
        "Regex", &clang::tooling::IncludeStyle::IncludeCategory::Regex,
        R"_pb11_weaver(/// The regular expression that this category matches.)_pb11_weaver");
    handle.def_readwrite(
        "Priority", &clang::tooling::IncludeStyle::IncludeCategory::Priority,
        R"_pb11_weaver(/// The priority to assign to this category.)_pb11_weaver");
    handle.def_readwrite(
        "SortPriority",
        &clang::tooling::IncludeStyle::IncludeCategory::SortPriority,
        R"_pb11_weaver(/// The custom priority to sort before grouping.)_pb11_weaver");
    handle.def_readwrite(
        "RegexIsCaseSensitive",
        &clang::tooling::IncludeStyle::IncludeCategory::RegexIsCaseSensitive,
        R"_pb11_weaver(/// If the regular expression is case sensitive.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_IncludeStyle_IncludeCategory";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeStyle_IncludeCategory

using Entity_clang_tooling_IncludeStyle_IncludeCategory =
    Bind_clang_tooling_IncludeStyle_IncludeCategory<>;

#else

struct Entity_clang_tooling_IncludeStyle_IncludeCategory
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_IncludeStyle_IncludeCategory(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_IncludeStyle_IncludeCategory";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_IncludeStyle_IncludeCategory

template <class Pybind11T =
              pybind11::enum_<clang::tooling::JSONCommandLineSyntax>>
struct Bind_clang_tooling_JSONCommandLineSyntax : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_JSONCommandLineSyntax(EntityScope parent_h)
      : handle{parent_h, "JSONCommandLineSyntax", pybind11::arithmetic(),
               R"_pb11_weaver(/// A JSON based compilation database.
///
/// JSON compilation database files must contain a list of JSON objects which
/// provide the command lines in the attributes 'directory', 'command',
/// 'arguments' and 'file':
/// [
///   { "directory": "<working directory of the compile>",
///     "command": "<compile command line>",
///     "file": "<path to source file>"
///   },
///   { "directory": "<working directory of the compile>",
///     "arguments": ["<raw>", "<command>" "<line>" "<parameters>"],
///     "file": "<path to source file>"
///   },
///   ...
/// ]
/// Each object entry defines one compile action. The specified file is
/// considered to be the main source file for the translation unit.
///
/// 'command' is a full command line that will be unescaped.
///
/// 'arguments' is a list of command line arguments that will not be unescaped.
///
/// JSON compilation databases can for example be generated in CMake projects
/// by setting the flag -DCMAKE_EXPORT_COMPILE_COMMANDS.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_JSONCommandLineSyntax(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Windows", clang::tooling::JSONCommandLineSyntax::Windows);
    handle.value("Gnu", clang::tooling::JSONCommandLineSyntax::Gnu);
    handle.value("AutoDetect",
                 clang::tooling::JSONCommandLineSyntax::AutoDetect);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_JSONCommandLineSyntax"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_JSONCommandLineSyntax

using Entity_clang_tooling_JSONCommandLineSyntax =
    Bind_clang_tooling_JSONCommandLineSyntax<>;

#else

struct Entity_clang_tooling_JSONCommandLineSyntax
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_JSONCommandLineSyntax(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_JSONCommandLineSyntax"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_JSONCommandLineSyntax

template <class = void>
class PyTrampJSONCompilationDatabase
    : public clang::tooling::JSONCompilationDatabase {
public:
  using _PB11_WR_BaseT = clang::tooling::JSONCompilationDatabase;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_JSONCompilationDatabasestd_vector6CompileCommand9_9StringRef__const
  std::vector<clang::tooling::CompileCommand>
  getCompileCommands(llvm::StringRef FilePath) const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::JSONCompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCompileCommands, FilePath);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_JSONCompilationDatabasestd_vector6CompileCommand9_9StringRef__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_JSONCompilationDatabasestd_vector6std_string9_9__const
  std::vector<std::basic_string<char>> getAllFiles() const override {
    using _PB11_WR_RET_TYPE = std::vector<std::basic_string<char>>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::JSONCompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getAllFiles,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_JSONCompilationDatabasestd_vector6std_string9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_JSONCompilationDatabasestd_vector6CompileCommand9_9__const
  std::vector<clang::tooling::CompileCommand>
  getAllCompileCommands() const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::JSONCompilationDatabase;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getAllCompileCommands,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_JSONCompilationDatabasestd_vector6CompileCommand9_9__const
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::JSONCompilationDatabase,
                               PyTrampJSONCompilationDatabase<>,
                               clang::tooling::CompilationDatabase>>
struct Bind_clang_tooling_JSONCompilationDatabase : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_loadFromFile() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Loads a JSON compilation database from the specified file.
  ///
  /// Returns NULL and sets ErrorMessage if the database could not be
  /// loaded from the given file.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_loadFromFile
#ifndef PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_loadFromFile
    handle.def_static("loadFromFile", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_loadFromBuffer() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Loads a JSON compilation database from a data buffer.
  ///
  /// Returns NULL and sets ErrorMessage if the database could not be loaded.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_loadFromBuffer
#ifndef PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_loadFromBuffer
    handle.def_static("loadFromBuffer", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCompileCommands() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns all compile commands in which the specified file was
  /// compiled.
  ///
  /// FIXME: Currently FilePath must be an absolute path inside the
  /// source directory which does not have symlinks resolved.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_getCompileCommands
    handle.def(
        "getCompileCommands",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::JSONCompilationDatabase,
                                    std::vector<clang::tooling::CompileCommand>,
                                    llvm::StringRef>::const_type>(
            &clang::tooling::JSONCompilationDatabase::getCompileCommands),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAllFiles() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the list of all files available in the compilation database.
  ///
  /// These are the 'file' entries of the JSON objects.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_getAllFiles
    handle.def("getAllFiles",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::JSONCompilationDatabase,
                   std::vector<std::basic_string<char>>>::const_type>(
                   &clang::tooling::JSONCompilationDatabase::getAllFiles),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAllCompileCommands() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns all compile commands for all the files in the compilation
  /// database.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_JSONCompilationDatabase_getAllCompileCommands
    handle.def(
        "getAllCompileCommands",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::JSONCompilationDatabase,
            std::vector<clang::tooling::CompileCommand>>::const_type>(
            &clang::tooling::JSONCompilationDatabase::getAllCompileCommands),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_JSONCompilationDatabase(EntityScope parent_h)
      : handle{parent_h, "JSONCompilationDatabase", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_JSONCompilationDatabase(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_loadFromFile();
    AddMethod_loadFromBuffer();
    AddMethod_getCompileCommands();
    AddMethod_getAllFiles();
    AddMethod_getAllCompileCommands();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::JSONCompilationDatabase>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_JSONCompilationDatabase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_JSONCompilationDatabase

using Entity_clang_tooling_JSONCompilationDatabase =
    Bind_clang_tooling_JSONCompilationDatabase<>;

#else

struct Entity_clang_tooling_JSONCompilationDatabase
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_JSONCompilationDatabase(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_JSONCompilationDatabase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_JSONCompilationDatabase

template <class Pybind11T = pybind11::class_<clang::tooling::LocationCall>>
struct Bind_clang_tooling_LocationCall : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_on() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCall_on
    handle.def("on", static_cast<pybind11_weaver::FnPtrT<
                         clang::tooling::LocationCall,
                         clang::tooling::LocationCall *>::const_type>(
                         &clang::tooling::LocationCall::on));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_name() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCall_name
    handle.def(
        "name",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::LocationCall,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::LocationCall::name));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_returnsPointer() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCall_returnsPointer
    handle.def("returnsPointer",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::LocationCall,
                                                   bool>::const_type>(
                   &clang::tooling::LocationCall::returnsPointer));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isCast() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCall_isCast
    handle.def("isCast",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::LocationCall,
                                                   bool>::const_type>(
                   &clang::tooling::LocationCall::isCast));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCall_Ctor0
    handle.def(
        pybind11::init<llvm::IntrusiveRefCntPtr<clang::tooling::LocationCall>,
                       std::basic_string<char>,
                       clang::tooling::LocationCall::LocationCallFlags>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_LocationCall(EntityScope parent_h)
      : handle{parent_h, "LocationCall", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_LocationCall(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_on();
    AddMethod_name();
    AddMethod_returnsPointer();
    AddMethod_isCast();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_LocationCall"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_LocationCall

using Entity_clang_tooling_LocationCall = Bind_clang_tooling_LocationCall<>;

#else

struct Entity_clang_tooling_LocationCall
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_LocationCall(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_LocationCall"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_LocationCall

template <class Pybind11T =
              pybind11::enum_<clang::tooling::LocationCall::LocationCallFlags>>
struct Bind_clang_tooling_LocationCall_LocationCallFlags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_LocationCall_LocationCallFlags(
      EntityScope parent_h)
      : handle{parent_h, "LocationCallFlags", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_LocationCall_LocationCallFlags(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("NoFlags",
                 clang::tooling::LocationCall::LocationCallFlags::NoFlags);
    handle.value(
        "ReturnsPointer",
        clang::tooling::LocationCall::LocationCallFlags::ReturnsPointer);
    handle.value("IsCast",
                 clang::tooling::LocationCall::LocationCallFlags::IsCast);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_LocationCall_LocationCallFlags";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_LocationCall_LocationCallFlags

using Entity_clang_tooling_LocationCall_LocationCallFlags =
    Bind_clang_tooling_LocationCall_LocationCallFlags<>;

#else

struct Entity_clang_tooling_LocationCall_LocationCallFlags
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_LocationCall_LocationCallFlags(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_LocationCall_LocationCallFlags";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_LocationCall_LocationCallFlags

template <class Pybind11T =
              pybind11::class_<clang::tooling::LocationCallFormatterCpp>>
struct Bind_clang_tooling_LocationCallFormatterCpp : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_print() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCallFormatterCpp_print
    handle.def_static("print",
                      static_cast<pybind11_weaver::FnPtrT<
                          void, void(const clang::tooling::LocationCall &,
                                     llvm::raw_ostream &)>::type>(
                          &clang::tooling::LocationCallFormatterCpp::print));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_format() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_LocationCallFormatterCpp_format
    handle.def_static(
        "format", static_cast<pybind11_weaver::FnPtrT<
                      void, std::basic_string<char>(
                                const clang::tooling::LocationCall &)>::type>(
                      &clang::tooling::LocationCallFormatterCpp::format));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_LocationCallFormatterCpp(EntityScope parent_h)
      : handle{parent_h, "LocationCallFormatterCpp", pybind11::dynamic_attr()} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_LocationCallFormatterCpp(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_print();
    AddMethod_format();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::LocationCallFormatterCpp>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_LocationCallFormatterCpp"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_LocationCallFormatterCpp

using Entity_clang_tooling_LocationCallFormatterCpp =
    Bind_clang_tooling_LocationCallFormatterCpp<>;

#else

struct Entity_clang_tooling_LocationCallFormatterCpp
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_LocationCallFormatterCpp(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_tooling_LocationCallFormatterCpp"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_LocationCallFormatterCpp

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_NodeIntrospection : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_NodeIntrospection(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "NodeIntrospection")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_NodeIntrospection(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_NodeIntrospection"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_NodeIntrospection

using Entity_clang_tooling_NodeIntrospection =
    Bind_clang_tooling_NodeIntrospection<>;

#else

struct Entity_clang_tooling_NodeIntrospection
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_NodeIntrospection(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_NodeIntrospection"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_NodeIntrospection

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations5 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations5_AddFunction
    handle.def("GetLocations",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::NodeLocationAccessors(
                             const clang::CXXBaseSpecifier *)>::type>(
                   &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations5(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations5(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations5"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations5

using Entity_GetLocations5 = Bind_GetLocations5<>;

#else

struct Entity_GetLocations5 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations5(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations5"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations5

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations2_AddFunction
    handle.def("GetLocations",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::NodeLocationAccessors(
                             const clang::CXXCtorInitializer *)>::type>(
                   &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations2(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations2

using Entity_GetLocations2 = Bind_GetLocations2<>;

#else

struct Entity_GetLocations2 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations2(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations2

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations1_AddFunction
    handle.def("GetLocations",
               [](pybind11_weaver::WrappedPtrT<const clang::Decl *> Object) {
                 return std::invoke(
                     static_cast<pybind11_weaver::FnPtrT<
                         void, clang::tooling::NodeLocationAccessors(
                                   const clang::Decl *)>::type>(
                         &clang::tooling::NodeIntrospection::GetLocations),
                     (Object)->Cptr());
               });
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations1

using Entity_GetLocations1 = Bind_GetLocations1<>;

#else

struct Entity_GetLocations1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations1(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations1

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations7 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations7_AddFunction
    handle.def("GetLocations",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::NodeLocationAccessors(
                             const clang::DeclarationNameInfo &)>::type>(
                   &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations7(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations7(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations7"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations7

using Entity_GetLocations7 = Bind_GetLocations7<>;

#else

struct Entity_GetLocations7 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations7(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations7"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations7

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations8 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations8_AddFunction
    handle.def("GetLocations",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::NodeLocationAccessors(
                             const clang::DynTypedNode &)>::type>(
                   &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations8(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations8(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations8"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations8

using Entity_GetLocations8 = Bind_GetLocations8<>;

#else

struct Entity_GetLocations8 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations8(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations8"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations8

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations3 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations3_AddFunction
    handle.def("GetLocations",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::NodeLocationAccessors(
                             const clang::NestedNameSpecifierLoc &)>::type>(
                   &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations3(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations3(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations3"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations3

using Entity_GetLocations3 = Bind_GetLocations3<>;

#else

struct Entity_GetLocations3 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations3(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations3"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations3

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations_AddFunction
    handle.def("GetLocations",
               [](pybind11_weaver::WrappedPtrT<const clang::Stmt *> Object) {
                 return std::invoke(
                     static_cast<pybind11_weaver::FnPtrT<
                         void, clang::tooling::NodeLocationAccessors(
                                   const clang::Stmt *)>::type>(
                         &clang::tooling::NodeIntrospection::GetLocations),
                     (Object)->Cptr());
               });
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations

using Entity_GetLocations = Bind_GetLocations<>;

#else

struct Entity_GetLocations : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations4 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations4_AddFunction
    handle.def("GetLocations",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::tooling::NodeLocationAccessors(
                             const clang::TemplateArgumentLoc &)>::type>(
                   &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations4(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations4(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations4"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations4

using Entity_GetLocations4 = Bind_GetLocations4<>;

#else

struct Entity_GetLocations4 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations4(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations4"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations4

template <class Pybind11T = pybind11::module_ &>
struct Bind_GetLocations6 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_GetLocations6_AddFunction
    handle.def(
        "GetLocations",
        static_cast<
            pybind11_weaver::FnPtrT<void, clang::tooling::NodeLocationAccessors(
                                              const clang::TypeLoc &)>::type>(
            &clang::tooling::NodeIntrospection::GetLocations));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_GetLocations6(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_GetLocations6(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "GetLocations6"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_GetLocations6

using Entity_GetLocations6 = Bind_GetLocations6<>;

#else

struct Entity_GetLocations6 : public pybind11_weaver::DisabledEntity {
  explicit Entity_GetLocations6(EntityScope parent_h) {}
  static const char *Key() { return "GetLocations6"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_GetLocations6

template <class Pybind11T = pybind11::module_ &>
struct Bind_hasIntrospectionSupport : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_hasIntrospectionSupport_AddFunction
    handle.def(
        "hasIntrospectionSupport",
        static_cast<pybind11_weaver::FnPtrT<void, bool()>::type>(
            &clang::tooling::NodeIntrospection::hasIntrospectionSupport));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_hasIntrospectionSupport(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_hasIntrospectionSupport(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "hasIntrospectionSupport"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_hasIntrospectionSupport

using Entity_hasIntrospectionSupport = Bind_hasIntrospectionSupport<>;

#else

struct Entity_hasIntrospectionSupport : public pybind11_weaver::DisabledEntity {
  explicit Entity_hasIntrospectionSupport(EntityScope parent_h) {}
  static const char *Key() { return "hasIntrospectionSupport"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_hasIntrospectionSupport

template <class Pybind11T =
              pybind11::class_<clang::tooling::NodeLocationAccessors>>
struct Bind_clang_tooling_NodeLocationAccessors : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_NodeLocationAccessors(EntityScope parent_h)
      : handle{parent_h, "NodeLocationAccessors", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_NodeLocationAccessors(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::NodeLocationAccessors>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_NodeLocationAccessors"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_NodeLocationAccessors

using Entity_clang_tooling_NodeLocationAccessors =
    Bind_clang_tooling_NodeLocationAccessors<>;

#else

struct Entity_clang_tooling_NodeLocationAccessors
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_NodeLocationAccessors(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_NodeLocationAccessors"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_NodeLocationAccessors

template <class Pybind11T = pybind11::enum_<clang::tooling::PLTClass>>
struct Bind_clang_tooling_PLTClass : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_PLTClass(EntityScope parent_h)
      : handle{
            parent_h, "PLTClass", pybind11::arithmetic(),
            R"_pb11_weaver(/// Specifies how to classify pointer-like types -- like values or like pointers
/// -- with regard to generating member-access syntax.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_PLTClass(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Value", clang::tooling::PLTClass::Value);
    handle.value("Pointer", clang::tooling::PLTClass::Pointer);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_PLTClass"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_PLTClass

using Entity_clang_tooling_PLTClass = Bind_clang_tooling_PLTClass<>;

#else

struct Entity_clang_tooling_PLTClass : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_PLTClass(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_PLTClass"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_PLTClass

template <class = void>
class PyTrampPathComparator : public clang::tooling::PathComparator {
public:
  using _PB11_WR_BaseT = clang::tooling::PathComparator;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_PathComparatorbool_9StringRef__StringRef__const
  bool equivalent(llvm::StringRef FileA, llvm::StringRef FileB) const override {
    using _PB11_WR_RET_TYPE = bool;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::PathComparator;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           equivalent, FileA, FileB);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_PathComparatorbool_9StringRef__StringRef__const
};

template <class Pybind11T = pybind11::class_<clang::tooling::PathComparator,
                                             PyTrampPathComparator<>>>
struct Bind_clang_tooling_PathComparator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_equivalent() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_PathComparator_equivalent
    handle.def("equivalent", static_cast<pybind11_weaver::FnPtrT<
                                 clang::tooling::PathComparator, bool,
                                 llvm::StringRef, llvm::StringRef>::const_type>(
                                 &clang::tooling::PathComparator::equivalent));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_PathComparator(EntityScope parent_h)
      : handle{parent_h, "PathComparator", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_PathComparator(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_equivalent();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::PathComparator>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_PathComparator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_PathComparator

using Entity_clang_tooling_PathComparator = Bind_clang_tooling_PathComparator<>;

#else

struct Entity_clang_tooling_PathComparator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_PathComparator(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_PathComparator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_PathComparator

template <class Pybind11T =
              pybind11::class_<clang::tooling::QualifiedRenamingAction>>
struct Bind_clang_tooling_QualifiedRenamingAction : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_newASTConsumer() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_QualifiedRenamingAction_newASTConsumer
#ifndef PB11_WEAVER_DISABLE_clang_tooling_QualifiedRenamingAction_newASTConsumer
    handle.def("newASTConsumer", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Rename all symbols identified by the given USRs.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_QualifiedRenamingAction_Ctor0
    handle.def(pybind11::init<
                   const std::vector<std::basic_string<char>> &,
                   const std::vector<std::vector<std::basic_string<char>>> &,
                   std::map<std::basic_string<char>,
                            clang::tooling::Replacements> &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_QualifiedRenamingAction(EntityScope parent_h)
      : handle{parent_h, "QualifiedRenamingAction", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Rename all symbols identified by the given USRs.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_QualifiedRenamingAction(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_newASTConsumer();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_QualifiedRenamingAction"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_QualifiedRenamingAction

using Entity_clang_tooling_QualifiedRenamingAction =
    Bind_clang_tooling_QualifiedRenamingAction<>;

#else

struct Entity_clang_tooling_QualifiedRenamingAction
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_QualifiedRenamingAction(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_QualifiedRenamingAction"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_QualifiedRenamingAction

template <class Pybind11T = pybind11::class_<clang::tooling::Range>>
struct Bind_clang_tooling_Range : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getOffset() {

    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/// Accessors.
  /// @{)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Range_getOffset
    handle.def("getOffset",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Range,
                                                   unsigned int>::const_type>(
                   &clang::tooling::Range::getOffset),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLength() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Range_getLength
    handle.def("getLength",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Range,
                                                   unsigned int>::const_type>(
                   &clang::tooling::Range::getLength));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_overlapsWith() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \name Range Predicates
  /// @{
  /// Whether this range overlaps with \p RHS or not.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Range_overlapsWith
    handle.def(
        "overlapsWith",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::Range, bool,
                                            clang::tooling::Range>::const_type>(
            &clang::tooling::Range::overlapsWith),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_contains() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Whether this range contains \p RHS or not.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Range_contains
    handle.def(
        "contains",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::Range, bool,
                                            clang::tooling::Range>::const_type>(
            &clang::tooling::Range::contains),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A source range independent of the \c SourceManager.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Range_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A source range independent of the \c SourceManager.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Range_Ctor1
    handle.def(pybind11::init<unsigned int, unsigned int>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_Range(EntityScope parent_h)
      : handle{parent_h, "Range", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A source range independent of the \c SourceManager.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_Range(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getOffset();
    AddMethod_getLength();
    AddMethod_overlapsWith();
    AddMethod_contains();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_Range"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_Range

using Entity_clang_tooling_Range = Bind_clang_tooling_Range<>;

#else

struct Entity_clang_tooling_Range : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_Range(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_Range"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_Range

template <class = void>
class PyTrampRefactoringAction : public clang::tooling::RefactoringAction {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringAction;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionStringRef_9__const
  llvm::StringRef getCommand() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringAction;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getCommand,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionStringRef_9__const
  llvm::StringRef getDescription() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringAction;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getDescription,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionStringRef_9__const
};

template <class Pybind11T = pybind11::class_<clang::tooling::RefactoringAction,
                                             PyTrampRefactoringAction<>>>
struct Bind_clang_tooling_RefactoringAction : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getCommand() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the name of the subcommand that's used by clang-refactor for this
  /// action.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringAction_getCommand
    handle.def(
        "getCommand",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::RefactoringAction,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::RefactoringAction::getCommand),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDescription() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringAction_getDescription
    handle.def(
        "getDescription",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::RefactoringAction,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::RefactoringAction::getDescription));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_createActiveActionRules() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_RefactoringAction_createActiveActionRules
#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringAction_createActiveActionRules
    handle.def("createActiveActionRules", None);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringAction(EntityScope parent_h)
      : handle{
            parent_h, "RefactoringAction", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A refactoring action is a class that defines a set of related refactoring
/// action rules. These rules get grouped under a common umbrella - a single
/// clang-refactor subcommand.
///
/// A subclass of \c RefactoringAction is responsible for creating the set of
/// grouped refactoring action rules that represent one refactoring operation.
/// Although the rules in one action may have a number of different
/// implementations, they should strive to produce a similar result. It should
/// be easy for users to identify which refactoring action produced the result
/// regardless of which refactoring action rule was used.
///
/// The distinction between actions and rules enables the creation of action
/// that uses very different rules, for example:
///   - local vs global: a refactoring operation like
///     "add missing switch cases" can be applied to one switch when it's
///     selected in an editor, or to all switches in a project when an enum
///     constant is added to an enum.
///   - tool vs editor: some refactoring operation can be initiated in the
///     editor when a declaration is selected, or in a tool when the name of
///     the declaration is passed using a command-line argument.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringAction(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getCommand();
    AddMethod_getDescription();
    AddMethod_createActiveActionRules();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::RefactoringAction>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringAction"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringAction

using Entity_clang_tooling_RefactoringAction =
    Bind_clang_tooling_RefactoringAction<>;

#else

struct Entity_clang_tooling_RefactoringAction
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringAction(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringAction"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringAction

template <class = void>
class PyTrampRefactoringActionRuleBase
    : public clang::tooling::RefactoringActionRuleBase {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringActionRuleBase;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRuleBasevoid_9RefactoringResultConsumer____RefactoringRuleContext___
  void invoke(clang::tooling::RefactoringResultConsumer &Consumer,
              clang::tooling::RefactoringRuleContext &Context) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringActionRuleBase;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, invoke,
                           Consumer, Context);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRuleBasevoid_9RefactoringResultConsumer____RefactoringRuleContext___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringActionRuleBase,
                               PyTrampRefactoringActionRuleBase<>>>
struct Bind_clang_tooling_RefactoringActionRuleBase : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_invoke() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Initiates and performs a specific refactoring action.
  ///
  /// The specific rule will invoke an appropriate \c handle method on a
  /// consumer to propagate the result of the refactoring action.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringActionRuleBase_invoke
    handle.def("invoke",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringActionRuleBase, void,
                   clang::tooling::RefactoringResultConsumer &,
                   clang::tooling::RefactoringRuleContext &>::type>(
                   &clang::tooling::RefactoringActionRuleBase::invoke),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringActionRuleBase(EntityScope parent_h)
      : handle{
            parent_h, "RefactoringActionRuleBase", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A common refactoring action rule interface that defines the 'invoke'
/// function that performs the refactoring operation (either fully or
/// partially).)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringActionRuleBase(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_invoke();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::RefactoringActionRuleBase>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringActionRuleBase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringActionRuleBase

using Entity_clang_tooling_RefactoringActionRuleBase =
    Bind_clang_tooling_RefactoringActionRuleBase<>;

#else

struct Entity_clang_tooling_RefactoringActionRuleBase
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringActionRuleBase(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringActionRuleBase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringActionRuleBase

template <class Pybind11T = pybind11::class_<
              clang::tooling::RefactoringActionRuleRequirement>>
struct Bind_clang_tooling_RefactoringActionRuleRequirement : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_RefactoringActionRuleRequirement(
      EntityScope parent_h)
      : handle{
            parent_h, "RefactoringActionRuleRequirement",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A refactoring action rule requirement determines when a refactoring action
/// rule can be invoked. The rule can be invoked only when all of the
/// requirements are satisfied.
///
/// Subclasses must implement the
/// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.
/// \c T is used to determine the return type that is passed to the
/// refactoring rule's constructor.
/// For example, the \c SourceRangeSelectionRequirement subclass defines
/// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'
/// function. When this function returns a non-error value, the resulting
/// source range is passed to the specific refactoring action rule
/// constructor (provided all other requirements are satisfied).)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringActionRuleRequirement(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::RefactoringActionRuleRequirement>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_RefactoringActionRuleRequirement";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringActionRuleRequirement

using Entity_clang_tooling_RefactoringActionRuleRequirement =
    Bind_clang_tooling_RefactoringActionRuleRequirement<>;

#else

struct Entity_clang_tooling_RefactoringActionRuleRequirement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringActionRuleRequirement(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_RefactoringActionRuleRequirement";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringActionRuleRequirement

template <class = void>
class PyTrampRefactoringCallback1 : public clang::tooling::RefactoringCallback {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringCallback;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackvoid_9_
  void onStartOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringCallback;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onStartOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackvoid_9_
  void onEndOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringCallback;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onEndOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackStringRef_9__const
  llvm::StringRef getID() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringCallback;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getID,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackstd_optional6TraversalKind9_9__const
  std::optional<clang::TraversalKind> getCheckTraversalKind() const override {
    using _PB11_WR_RET_TYPE = std::optional<clang::TraversalKind>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringCallback;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCheckTraversalKind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackstd_optional6TraversalKind9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackvoid_9const_MatchResult___
  void
  run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringCallback;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, run,
                           Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringCallbackvoid_9const_MatchResult___
};

template <class = void>
class PyTrampRefactoringCallback : public PyTrampRefactoringCallback1<> {
public:
  using _PB11_WR_BaseT = PyTrampRefactoringCallback1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringCallback,
                               PyTrampRefactoringCallback<>>>
struct Bind_clang_tooling_RefactoringCallback : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getReplacements() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringCallback_getReplacements
    handle.def(
        "getReplacements",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringCallback,
                                    clang::tooling::Replacements &>::type>(
            &clang::tooling::RefactoringCallback::getReplacements));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Base class for RefactoringCallbacks.
///
/// Collects \c tooling::Replacements while running.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringCallback_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringCallback(EntityScope parent_h)
      : handle{parent_h, "RefactoringCallback", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Base class for RefactoringCallbacks.
///
/// Collects \c tooling::Replacements while running.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringCallback(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getReplacements();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringCallback"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringCallback

using Entity_clang_tooling_RefactoringCallback =
    Bind_clang_tooling_RefactoringCallback<>;

#else

struct Entity_clang_tooling_RefactoringCallback
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringCallback(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringCallback"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringCallback

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringDescriptor>>
struct Bind_clang_tooling_RefactoringDescriptor : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_RefactoringDescriptor(EntityScope parent_h)
      : handle{parent_h, "RefactoringDescriptor", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringDescriptor(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::RefactoringDescriptor>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringDescriptor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringDescriptor

using Entity_clang_tooling_RefactoringDescriptor =
    Bind_clang_tooling_RefactoringDescriptor<>;

#else

struct Entity_clang_tooling_RefactoringDescriptor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringDescriptor(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringDescriptor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringDescriptor

template <class = void>
class PyTrampRefactoringOption : public clang::tooling::RefactoringOption {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringOption;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionStringRef_9__const
  llvm::StringRef getName() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringOption;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getName,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionStringRef_9__const
  llvm::StringRef getDescription() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringOption;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getDescription,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionbool_9__const
  bool isRequired() const override {
    using _PB11_WR_RET_TYPE = bool;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringOption;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           isRequired,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionbool_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionvoid_9RefactoringOptionVisitor___
  void
  passToVisitor(clang::tooling::RefactoringOptionVisitor &Visitor) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringOption;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           passToVisitor, Visitor);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionvoid_9RefactoringOptionVisitor___
};

template <class Pybind11T = pybind11::class_<clang::tooling::RefactoringOption,
                                             PyTrampRefactoringOption<>>>
struct Bind_clang_tooling_RefactoringOption : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getName() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the name of the refactoring option.
  ///
  /// Each refactoring option must have a unique name.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringOption_getName
    handle.def(
        "getName",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::RefactoringOption,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::RefactoringOption::getName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDescription() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringOption_getDescription
    handle.def(
        "getDescription",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::RefactoringOption,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::RefactoringOption::getDescription));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isRequired() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// True when this option must be specified before invoking the refactoring
  /// action.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringOption_isRequired
    handle.def(
        "isRequired",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::RefactoringOption,
                                            bool>::const_type>(
            &clang::tooling::RefactoringOption::isRequired),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_passToVisitor() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Invokes the \c visit method in the option consumer that's appropriate
  /// for the option's value type.
  ///
  /// For example, if the option stores a string value, this method will
  /// invoke the \c visit method with a reference to an std::string value.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringOption_passToVisitor
    handle.def("passToVisitor",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringOption, void,
                   clang::tooling::RefactoringOptionVisitor &>::type>(
                   &clang::tooling::RefactoringOption::passToVisitor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringOption(EntityScope parent_h)
      : handle{
            parent_h, "RefactoringOption", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A refactoring option is an interface that describes a value that
/// has an impact on the outcome of a refactoring.
///
/// Refactoring options can be specified using command-line arguments when
/// the clang-refactor tool is used.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringOption(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getName();
    AddMethod_getDescription();
    AddMethod_isRequired();
    AddMethod_passToVisitor();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::RefactoringOption>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringOption"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringOption

using Entity_clang_tooling_RefactoringOption =
    Bind_clang_tooling_RefactoringOption<>;

#else

struct Entity_clang_tooling_RefactoringOption
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringOption(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringOption"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringOption

template <class = void>
class PyTrampRefactoringOptionVisitor
    : public clang::tooling::RefactoringOptionVisitor {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringOptionVisitor;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionVisitorvoid_9const_RefactoringOption____std_optional6std_string9___
  void visit(const clang::tooling::RefactoringOption &Opt,
             std::optional<std::basic_string<char>> &Value) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringOptionVisitor;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, visit,
                           Opt, Value);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionVisitorvoid_9const_RefactoringOption____std_optional6std_string9___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringOptionVisitor,
                               PyTrampRefactoringOptionVisitor<>>>
struct Bind_clang_tooling_RefactoringOptionVisitor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_visit() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringOptionVisitor_visit
    handle.def("visit", static_cast<pybind11_weaver::FnPtrT<
                            clang::tooling::RefactoringOptionVisitor, void,
                            const clang::tooling::RefactoringOption &,
                            std::optional<std::basic_string<char>> &>::type>(
                            &clang::tooling::RefactoringOptionVisitor::visit));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringOptionVisitor(EntityScope parent_h)
      : handle{
            parent_h, "RefactoringOptionVisitor", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An interface that declares functions that handle different refactoring
/// option types.
///
/// A valid refactoring option type must have a corresponding \c visit
/// declaration in this interface.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringOptionVisitor(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_visit();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::RefactoringOptionVisitor>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringOptionVisitor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringOptionVisitor

using Entity_clang_tooling_RefactoringOptionVisitor =
    Bind_clang_tooling_RefactoringOptionVisitor<>;

#else

struct Entity_clang_tooling_RefactoringOptionVisitor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringOptionVisitor(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_tooling_RefactoringOptionVisitor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringOptionVisitor

template <class = void>
class PyTrampRefactoringOptionsRequirement
    : public clang::tooling::RefactoringOptionsRequirement {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringOptionsRequirement;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionsRequirementArrayRef6std_shared_ptr6RefactoringOption99_9__const
  llvm::ArrayRef<std::shared_ptr<clang::tooling::RefactoringOption>>
  getRefactoringOptions() const override {
    using _PB11_WR_RET_TYPE =
        llvm::ArrayRef<std::shared_ptr<clang::tooling::RefactoringOption>>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::RefactoringOptionsRequirement;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getRefactoringOptions,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringOptionsRequirementArrayRef6std_shared_ptr6RefactoringOption99_9__const
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::RefactoringOptionsRequirement,
              PyTrampRefactoringOptionsRequirement<>,
              clang::tooling::RefactoringActionRuleRequirement>>
struct Bind_clang_tooling_RefactoringOptionsRequirement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getRefactoringOptions() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the set of refactoring options that are used when evaluating this
  /// requirement.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringOptionsRequirement_getRefactoringOptions
    handle.def("getRefactoringOptions",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringOptionsRequirement,
                   llvm::ArrayRef<std::shared_ptr<
                       clang::tooling::RefactoringOption>>>::const_type>(
                   &clang::tooling::RefactoringOptionsRequirement::
                       getRefactoringOptions),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringOptionsRequirement(
      EntityScope parent_h)
      : handle{parent_h, "RefactoringOptionsRequirement",
               pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A base class for any requirement that requires some refactoring options.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringOptionsRequirement(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getRefactoringOptions();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::RefactoringOptionsRequirement>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_RefactoringOptionsRequirement";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringOptionsRequirement

using Entity_clang_tooling_RefactoringOptionsRequirement =
    Bind_clang_tooling_RefactoringOptionsRequirement<>;

#else

struct Entity_clang_tooling_RefactoringOptionsRequirement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringOptionsRequirement(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_RefactoringOptionsRequirement";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringOptionsRequirement

template <class = void>
class PyTrampRefactoringResultConsumer
    : public clang::tooling::RefactoringResultConsumer {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringResultConsumer;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringResultConsumervoid_9AtomicChanges_
  void handle(
      std::vector<clang::tooling::AtomicChange> SourceReplacements) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringResultConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, handle,
                      SourceReplacements);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringResultConsumervoid_9AtomicChanges_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringResultConsumervoid_9SymbolOccurrences_
  void
  handle(std::vector<clang::tooling::SymbolOccurrence> Occurrences) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringResultConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, handle,
                      Occurrences);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringResultConsumervoid_9SymbolOccurrences_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringResultConsumervoid_9llvm_Error_
  void handleError(llvm::Error Err) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringResultConsumer;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           handleError, Err);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringResultConsumervoid_9llvm_Error_
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringResultConsumer,
                               PyTrampRefactoringResultConsumer<>>>
struct Bind_clang_tooling_RefactoringResultConsumer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_handleError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Handles an initiation or an invication error. An initiation error typically
  /// has a \c DiagnosticError payload that describes why initiation failed.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringResultConsumer_handleError
    handle.def(
        "handleError",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringResultConsumer,
                                    void, llvm::Error>::type>(
            &clang::tooling::RefactoringResultConsumer::handleError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handle() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Handles the source replacements that are produced by a refactoring action.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringResultConsumer_handle
    handle.def("handle",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringResultConsumer, void,
                   std::vector<clang::tooling::AtomicChange>>::type>(
                   &clang::tooling::RefactoringResultConsumer::handle),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handle1() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Handles the symbol occurrences that are found by an interactive
  /// refactoring action.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringResultConsumer_handle1
    handle.def("handle",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringResultConsumer, void,
                   std::vector<clang::tooling::SymbolOccurrence>>::type>(
                   &clang::tooling::RefactoringResultConsumer::handle),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringResultConsumer(EntityScope parent_h)
      : handle{parent_h, "RefactoringResultConsumer", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An abstract interface that consumes the various refactoring results that can
/// be produced by refactoring actions.
///
/// A valid refactoring result must be handled by a \c handle method.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringResultConsumer(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_handleError();
    AddMethod_handle();
    AddMethod_handle1();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::RefactoringResultConsumer>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringResultConsumer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringResultConsumer

using Entity_clang_tooling_RefactoringResultConsumer =
    Bind_clang_tooling_RefactoringResultConsumer<>;

#else

struct Entity_clang_tooling_RefactoringResultConsumer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringResultConsumer(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringResultConsumer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringResultConsumer

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringRuleContext>>
struct Bind_clang_tooling_RefactoringRuleContext : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getSources() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_getSources
    handle.def(
        "getSources",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringRuleContext,
                                    const clang::SourceManager &>::const_type>(
            &clang::tooling::RefactoringRuleContext::getSources));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSelectionRange() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the current source selection range as set by the
  /// refactoring engine. Can be invalid.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_getSelectionRange
    handle.def(
        "getSelectionRange",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringRuleContext,
                                    clang::SourceRange>::const_type>(
            &clang::tooling::RefactoringRuleContext::getSelectionRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setSelectionRange() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_setSelectionRange
    handle.def(
        "setSelectionRange",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringRuleContext,
                                    void, clang::SourceRange>::type>(
            &clang::tooling::RefactoringRuleContext::setSelectionRange));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_hasASTContext() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_hasASTContext
    handle.def("hasASTContext",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringRuleContext, bool>::const_type>(
                   &clang::tooling::RefactoringRuleContext::hasASTContext));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getASTContext() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_getASTContext
    handle.def(
        "getASTContext",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringRuleContext,
                                    clang::ASTContext &>::const_type>(
            &clang::tooling::RefactoringRuleContext::getASTContext));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setASTContext() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_setASTContext
    handle.def(
        "setASTContext",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringRuleContext,
                                    void, clang::ASTContext &>::type>(
            &clang::tooling::RefactoringRuleContext::setASTContext));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_createDiagnosticError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Creates an llvm::Error value that contains a diagnostic.
  ///
  /// The errors should not outlive the context.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_createDiagnosticError
    handle.def(
        "createDiagnosticError",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::RefactoringRuleContext, llvm::Error,
            clang::SourceLocation, unsigned int>::type>(
            &clang::tooling::RefactoringRuleContext::createDiagnosticError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_createDiagnosticError1() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_createDiagnosticError1
    handle.def(
        "createDiagnosticError",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::RefactoringRuleContext,
                                    llvm::Error, unsigned int>::type>(
            &clang::tooling::RefactoringRuleContext::createDiagnosticError));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setASTSelection() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_setASTSelection
#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_setASTSelection
    handle.def("setASTSelection", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The refactoring rule context stores all of the inputs that might be needed
/// by a refactoring action rule. It can create the specialized
/// \c ASTRefactoringOperation or \c PreprocessorRefactoringOperation values
/// that can be used by the refactoring action rules.
///
/// The following inputs are stored by the operation:
///
///   - SourceManager: a reference to a valid source manager.
///
///   - SelectionRange: an optional source selection ranges that can be used
///     to represent a selection in an editor.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringRuleContext_Ctor0
    handle.def(pybind11::init<const clang::SourceManager &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringRuleContext(EntityScope parent_h)
      : handle{
            parent_h, "RefactoringRuleContext", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// The refactoring rule context stores all of the inputs that might be needed
/// by a refactoring action rule. It can create the specialized
/// \c ASTRefactoringOperation or \c PreprocessorRefactoringOperation values
/// that can be used by the refactoring action rules.
///
/// The following inputs are stored by the operation:
///
///   - SourceManager: a reference to a valid source manager.
///
///   - SelectionRange: an optional source selection ranges that can be used
///     to represent a selection in an editor.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringRuleContext(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getSources();
    AddMethod_getSelectionRange();
    AddMethod_setSelectionRange();
    AddMethod_hasASTContext();
    AddMethod_getASTContext();
    AddMethod_setASTContext();
    AddMethod_createDiagnosticError();
    AddMethod_createDiagnosticError1();
    AddMethod_setASTSelection();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringRuleContext"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringRuleContext

using Entity_clang_tooling_RefactoringRuleContext =
    Bind_clang_tooling_RefactoringRuleContext<>;

#else

struct Entity_clang_tooling_RefactoringRuleContext
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringRuleContext(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringRuleContext"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringRuleContext

template <class Pybind11T = pybind11::class_<clang::tooling::RefactoringTool,
                                             clang::tooling::ClangTool>>
struct Bind_clang_tooling_RefactoringTool : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getReplacements() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the file path to replacements map to which replacements
  /// should be added during the run of the tool.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringTool_getReplacements
    handle.def(
        "getReplacements",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::RefactoringTool,
            std::map<std::basic_string<char>, clang::tooling::Replacements>
                &>::type>(&clang::tooling::RefactoringTool::getReplacements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_runAndSave() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Call run(), apply all generated replacements, and immediately save
  /// the results to disk.
  ///
  /// \returns 0 upon success. Non-zero upon failure.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringTool_runAndSave
    handle.def("runAndSave",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::RefactoringTool, int,
                   clang::tooling::FrontendActionFactory *>::type>(
                   &clang::tooling::RefactoringTool::runAndSave),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_applyAllReplacements() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Apply all stored replacements to the given Rewriter.
  ///
  /// FileToReplaces will be deduplicated with `groupReplacementsByFile` before
  /// application.
  ///
  /// Replacement applications happen independently of the success of other
  /// applications.
  ///
  /// \returns true if all replacements apply. false otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringTool_applyAllReplacements
    handle.def(
        "applyAllReplacements",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::RefactoringTool,
                                            bool, clang::Rewriter &>::type>(
            &clang::tooling::RefactoringTool::applyAllReplacements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A tool to run refactorings.
///
/// This is a refactoring specific version of \see ClangTool. FrontendActions
/// passed to run() and runAndSave() should add replacements to
/// getReplacements().)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringTool_Ctor0
    handle.def(pybind11::init<const clang::tooling::CompilationDatabase &,
                              llvm::ArrayRef<std::basic_string<char>>,
                              std::shared_ptr<clang::PCHContainerOperations>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringTool(EntityScope parent_h)
      : handle{parent_h, "RefactoringTool", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A tool to run refactorings.
///
/// This is a refactoring specific version of \see ClangTool. FrontendActions
/// passed to run() and runAndSave() should add replacements to
/// getReplacements().)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringTool(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getReplacements();
    AddMethod_runAndSave();
    AddMethod_applyAllReplacements();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringTool"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringTool

using Entity_clang_tooling_RefactoringTool =
    Bind_clang_tooling_RefactoringTool<>;

#else

struct Entity_clang_tooling_RefactoringTool
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringTool(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringTool"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringTool

template <class Pybind11T = pybind11::class_<clang::tooling::RenamingAction>>
struct Bind_clang_tooling_RenamingAction : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_newASTConsumer() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_RenamingAction_newASTConsumer
#ifndef PB11_WEAVER_DISABLE_clang_tooling_RenamingAction_newASTConsumer
    handle.def("newASTConsumer", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RenamingAction_Ctor0
    handle.def(
        pybind11::init<
            const std::vector<std::basic_string<char>> &,
            const std::vector<std::basic_string<char>> &,
            const std::vector<std::vector<std::basic_string<char>>> &,
            std::map<std::basic_string<char>, clang::tooling::Replacements> &,
            bool>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RenamingAction(EntityScope parent_h)
      : handle{parent_h, "RenamingAction", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RenamingAction(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_newASTConsumer();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RenamingAction"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RenamingAction

using Entity_clang_tooling_RenamingAction = Bind_clang_tooling_RenamingAction<>;

#else

struct Entity_clang_tooling_RenamingAction
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RenamingAction(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RenamingAction"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RenamingAction

template <class = void>
class PyTrampReplaceIfStmtWithItsBody2
    : public clang::tooling::ReplaceIfStmtWithItsBody {
public:
  using _PB11_WR_BaseT = clang::tooling::ReplaceIfStmtWithItsBody;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyvoid_9_
  void onStartOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceIfStmtWithItsBody;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onStartOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyvoid_9_
  void onEndOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceIfStmtWithItsBody;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onEndOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyStringRef_9__const
  llvm::StringRef getID() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceIfStmtWithItsBody;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getID,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodystd_optional6TraversalKind9_9__const
  std::optional<clang::TraversalKind> getCheckTraversalKind() const override {
    using _PB11_WR_RET_TYPE = std::optional<clang::TraversalKind>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceIfStmtWithItsBody;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCheckTraversalKind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodystd_optional6TraversalKind9_9__const
};

template <class = void>
class PyTrampReplaceIfStmtWithItsBody1
    : public PyTrampReplaceIfStmtWithItsBody2<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceIfStmtWithItsBody2<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;
};

template <class = void>
class PyTrampReplaceIfStmtWithItsBody
    : public PyTrampReplaceIfStmtWithItsBody1<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceIfStmtWithItsBody1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyvoid_9const_ast_matchers_MatchFinder_MatchResult___
  void
  run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceIfStmtWithItsBody;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, run, Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceIfStmtWithItsBodyvoid_9const_ast_matchers_MatchFinder_MatchResult___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::ReplaceIfStmtWithItsBody,
                               PyTrampReplaceIfStmtWithItsBody<>,
                               clang::tooling::RefactoringCallback>>
struct Bind_clang_tooling_ReplaceIfStmtWithItsBody : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceIfStmtWithItsBody_run
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ReplaceIfStmtWithItsBody, void,
            const clang::ast_matchers::MatchFinder::MatchResult &>::type>(
            &clang::tooling::ReplaceIfStmtWithItsBody::run));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Replace an if-statement bound to \c Id with the outdented text of its
/// body, choosing the consequent or the alternative based on whether
/// \c PickTrueBranch is true.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceIfStmtWithItsBody_Ctor0
    handle.def(pybind11::init<llvm::StringRef, bool>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ReplaceIfStmtWithItsBody(EntityScope parent_h)
      : handle{
            parent_h, "ReplaceIfStmtWithItsBody", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Replace an if-statement bound to \c Id with the outdented text of its
/// body, choosing the consequent or the alternative based on whether
/// \c PickTrueBranch is true.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ReplaceIfStmtWithItsBody(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_run();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ReplaceIfStmtWithItsBody"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceIfStmtWithItsBody

using Entity_clang_tooling_ReplaceIfStmtWithItsBody =
    Bind_clang_tooling_ReplaceIfStmtWithItsBody<>;

#else

struct Entity_clang_tooling_ReplaceIfStmtWithItsBody
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ReplaceIfStmtWithItsBody(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_tooling_ReplaceIfStmtWithItsBody"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceIfStmtWithItsBody

template <class = void>
class PyTrampReplaceNodeWithTemplate2
    : public clang::tooling::ReplaceNodeWithTemplate {
public:
  using _PB11_WR_BaseT = clang::tooling::ReplaceNodeWithTemplate;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatevoid_9_
  void onStartOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceNodeWithTemplate;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onStartOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatevoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatevoid_9_
  void onEndOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceNodeWithTemplate;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onEndOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatevoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplateStringRef_9__const
  llvm::StringRef getID() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceNodeWithTemplate;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getID,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplateStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatestd_optional6TraversalKind9_9__const
  std::optional<clang::TraversalKind> getCheckTraversalKind() const override {
    using _PB11_WR_RET_TYPE = std::optional<clang::TraversalKind>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceNodeWithTemplate;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCheckTraversalKind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatestd_optional6TraversalKind9_9__const
};

template <class = void>
class PyTrampReplaceNodeWithTemplate1
    : public PyTrampReplaceNodeWithTemplate2<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceNodeWithTemplate2<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;
};

template <class = void>
class PyTrampReplaceNodeWithTemplate
    : public PyTrampReplaceNodeWithTemplate1<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceNodeWithTemplate1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatevoid_9const_ast_matchers_MatchFinder_MatchResult___
  void
  run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceNodeWithTemplate;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, run, Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceNodeWithTemplatevoid_9const_ast_matchers_MatchFinder_MatchResult___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::ReplaceNodeWithTemplate,
                               PyTrampReplaceNodeWithTemplate<>,
                               clang::tooling::RefactoringCallback>>
struct Bind_clang_tooling_ReplaceNodeWithTemplate : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_create() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_ReplaceNodeWithTemplate_create
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceNodeWithTemplate_create
    handle.def_static("create", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceNodeWithTemplate_run
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ReplaceNodeWithTemplate, void,
            const clang::ast_matchers::MatchFinder::MatchResult &>::type>(
            &clang::tooling::ReplaceNodeWithTemplate::run));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ReplaceNodeWithTemplate(EntityScope parent_h)
      : handle{
            parent_h, "ReplaceNodeWithTemplate", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Replace the text of an AST node bound to \c FromId with the result of
/// evaluating the template in \c ToTemplate.
///
/// Expressions of the form ${NodeName} in \c ToTemplate will be
/// replaced by the text of the node bound to ${NodeName}. The string
/// "$$" will be replaced by "$".)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ReplaceNodeWithTemplate(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_create();
    AddMethod_run();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ReplaceNodeWithTemplate>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ReplaceNodeWithTemplate"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceNodeWithTemplate

using Entity_clang_tooling_ReplaceNodeWithTemplate =
    Bind_clang_tooling_ReplaceNodeWithTemplate<>;

#else

struct Entity_clang_tooling_ReplaceNodeWithTemplate
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ReplaceNodeWithTemplate(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ReplaceNodeWithTemplate"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceNodeWithTemplate

template <class = void>
class PyTrampReplaceStmtWithStmt2 : public clang::tooling::ReplaceStmtWithStmt {
public:
  using _PB11_WR_BaseT = clang::tooling::ReplaceStmtWithStmt;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtvoid_9_
  void onStartOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithStmt;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onStartOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtvoid_9_
  void onEndOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithStmt;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onEndOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtStringRef_9__const
  llvm::StringRef getID() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithStmt;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getID,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtstd_optional6TraversalKind9_9__const
  std::optional<clang::TraversalKind> getCheckTraversalKind() const override {
    using _PB11_WR_RET_TYPE = std::optional<clang::TraversalKind>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithStmt;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCheckTraversalKind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtstd_optional6TraversalKind9_9__const
};

template <class = void>
class PyTrampReplaceStmtWithStmt1 : public PyTrampReplaceStmtWithStmt2<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceStmtWithStmt2<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;
};

template <class = void>
class PyTrampReplaceStmtWithStmt : public PyTrampReplaceStmtWithStmt1<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceStmtWithStmt1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtvoid_9const_ast_matchers_MatchFinder_MatchResult___
  void
  run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithStmt;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, run, Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithStmtvoid_9const_ast_matchers_MatchFinder_MatchResult___
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::ReplaceStmtWithStmt, PyTrampReplaceStmtWithStmt<>,
              clang::tooling::RefactoringCallback>>
struct Bind_clang_tooling_ReplaceStmtWithStmt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceStmtWithStmt_run
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ReplaceStmtWithStmt, void,
            const clang::ast_matchers::MatchFinder::MatchResult &>::type>(
            &clang::tooling::ReplaceStmtWithStmt::run));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Replace the text of the statement bound to \c FromId with the text of
/// the statement bound to \c ToId.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceStmtWithStmt_Ctor0
    handle.def(pybind11::init<llvm::StringRef, llvm::StringRef>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ReplaceStmtWithStmt(EntityScope parent_h)
      : handle{
            parent_h, "ReplaceStmtWithStmt", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Replace the text of the statement bound to \c FromId with the text of
/// the statement bound to \c ToId.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ReplaceStmtWithStmt(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_run();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ReplaceStmtWithStmt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceStmtWithStmt

using Entity_clang_tooling_ReplaceStmtWithStmt =
    Bind_clang_tooling_ReplaceStmtWithStmt<>;

#else

struct Entity_clang_tooling_ReplaceStmtWithStmt
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ReplaceStmtWithStmt(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ReplaceStmtWithStmt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceStmtWithStmt

template <class = void>
class PyTrampReplaceStmtWithText2 : public clang::tooling::ReplaceStmtWithText {
public:
  using _PB11_WR_BaseT = clang::tooling::ReplaceStmtWithText;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextvoid_9_
  void onStartOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithText;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onStartOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextvoid_9_
  void onEndOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithText;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onEndOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextvoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextStringRef_9__const
  llvm::StringRef getID() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithText;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getID,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextstd_optional6TraversalKind9_9__const
  std::optional<clang::TraversalKind> getCheckTraversalKind() const override {
    using _PB11_WR_RET_TYPE = std::optional<clang::TraversalKind>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithText;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCheckTraversalKind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextstd_optional6TraversalKind9_9__const
};

template <class = void>
class PyTrampReplaceStmtWithText1 : public PyTrampReplaceStmtWithText2<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceStmtWithText2<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;
};

template <class = void>
class PyTrampReplaceStmtWithText : public PyTrampReplaceStmtWithText1<> {
public:
  using _PB11_WR_BaseT = PyTrampReplaceStmtWithText1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextvoid_9const_ast_matchers_MatchFinder_MatchResult___
  void
  run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplaceStmtWithText;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, run, Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplaceStmtWithTextvoid_9const_ast_matchers_MatchFinder_MatchResult___
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::ReplaceStmtWithText, PyTrampReplaceStmtWithText<>,
              clang::tooling::RefactoringCallback>>
struct Bind_clang_tooling_ReplaceStmtWithText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceStmtWithText_run
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ReplaceStmtWithText, void,
            const clang::ast_matchers::MatchFinder::MatchResult &>::type>(
            &clang::tooling::ReplaceStmtWithText::run));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Replace the text of the statement bound to \c FromId with the text in
/// \c ToText.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplaceStmtWithText_Ctor0
    handle.def(pybind11::init<llvm::StringRef, llvm::StringRef>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ReplaceStmtWithText(EntityScope parent_h)
      : handle{
            parent_h, "ReplaceStmtWithText", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Replace the text of the statement bound to \c FromId with the text in
/// \c ToText.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ReplaceStmtWithText(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_run();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ReplaceStmtWithText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceStmtWithText

using Entity_clang_tooling_ReplaceStmtWithText =
    Bind_clang_tooling_ReplaceStmtWithText<>;

#else

struct Entity_clang_tooling_ReplaceStmtWithText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ReplaceStmtWithText(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ReplaceStmtWithText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplaceStmtWithText

template <class Pybind11T = pybind11::class_<clang::tooling::Replacement>>
struct Bind_clang_tooling_Replacement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_isApplicable() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns whether this replacement can be applied to a file.
  ///
  /// Only replacements that are in a valid file can be applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_isApplicable
    handle.def("isApplicable",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacement,
                                                   bool>::const_type>(
                   &clang::tooling::Replacement::isApplicable),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFilePath() {

    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/// Accessors.
  /// @{)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_getFilePath
    handle.def(
        "getFilePath",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacement,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::Replacement::getFilePath),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOffset() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_getOffset
    handle.def("getOffset",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacement,
                                                   unsigned int>::const_type>(
                   &clang::tooling::Replacement::getOffset));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getLength() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_getLength
    handle.def("getLength",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacement,
                                                   unsigned int>::const_type>(
                   &clang::tooling::Replacement::getLength));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getReplacementText() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_getReplacementText
    handle.def(
        "getReplacementText",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacement,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::Replacement::getReplacementText));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_apply() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Applies the replacement on the Rewriter.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_apply
    handle.def(
        "apply",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacement, bool,
                                            clang::Rewriter &>::const_type>(
            &clang::tooling::Replacement::apply),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_toString() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a human readable string representation.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_toString
    handle.def(
        "toString",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::Replacement, std::basic_string<char>>::const_type>(
            &clang::tooling::Replacement::toString),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A text replacement.
///
/// Represents a SourceManager independent replacement of a range of text in a
/// specific file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A text replacement.
///
/// Represents a SourceManager independent replacement of a range of text in a
/// specific file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_Ctor1
    handle.def(pybind11::init<llvm::StringRef, unsigned int, unsigned int,
                              llvm::StringRef>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor2() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A text replacement.
///
/// Represents a SourceManager independent replacement of a range of text in a
/// specific file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_Ctor2
    handle.def(
        pybind11::init<const clang::SourceManager &, clang::SourceLocation,
                       unsigned int, llvm::StringRef>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor3() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A text replacement.
///
/// Represents a SourceManager independent replacement of a range of text in a
/// specific file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacement_Ctor3
    handle.def(pybind11::init<const clang::SourceManager &,
                              const clang::CharSourceRange &, llvm::StringRef,
                              const clang::LangOptions &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_Replacement(EntityScope parent_h)
      : handle{parent_h, "Replacement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A text replacement.
///
/// Represents a SourceManager independent replacement of a range of text in a
/// specific file.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_Replacement(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_isApplicable();
    AddMethod_getFilePath();
    AddMethod_getOffset();
    AddMethod_getLength();
    AddMethod_getReplacementText();
    AddMethod_apply();
    AddMethod_toString();
    AddCtor0();
    AddCtor1();
    AddCtor2();
    AddCtor3();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_Replacement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_Replacement

using Entity_clang_tooling_Replacement = Bind_clang_tooling_Replacement<>;

#else

struct Entity_clang_tooling_Replacement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_Replacement(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_Replacement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_Replacement

template <class = void>
class PyTrampReplacementError : public clang::tooling::ReplacementError {
public:
  using _PB11_WR_BaseT = clang::tooling::ReplacementError;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplacementErrorstd_string_9__const
  std::basic_string<char> message() const override {
    using _PB11_WR_RET_TYPE = std::basic_string<char>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplacementError;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, message,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplacementErrorstd_string_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplacementErrorvoid_9raw_ostream____const
  void log(llvm::raw_ostream &OS) const override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ReplacementError;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, log, OS);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ReplacementErrorvoid_9raw_ostream____const
};

template <class Pybind11T = pybind11::class_<clang::tooling::ReplacementError,
                                             PyTrampReplacementError<>>>
struct Bind_clang_tooling_ReplacementError : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_message() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_message
    handle.def(
        "message",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ReplacementError,
                                    std::basic_string<char>>::const_type>(
            &clang::tooling::ReplacementError::message));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_log() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_log
    handle.def(
        "log",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ReplacementError, void,
                                    llvm::raw_ostream &>::const_type>(
            &clang::tooling::ReplacementError::log));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_get() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_get
    handle.def("get", static_cast<pybind11_weaver::FnPtrT<
                          clang::tooling::ReplacementError,
                          clang::tooling::replacement_error>::const_type>(
                          &clang::tooling::ReplacementError::get));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNewReplacement() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_getNewReplacement
    handle.def(
        "getNewReplacement",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ReplacementError,
            const std::optional<clang::tooling::Replacement> &>::const_type>(
            &clang::tooling::ReplacementError::getNewReplacement));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getExistingReplacement() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_getExistingReplacement
    handle.def(
        "getExistingReplacement",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ReplacementError,
            const std::optional<clang::tooling::Replacement> &>::const_type>(
            &clang::tooling::ReplacementError::getExistingReplacement));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Carries extra error information in replacement-related llvm::Error,
/// e.g. fail applying replacements and replacements conflict.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_Ctor0
    handle.def(pybind11::init<clang::tooling::replacement_error>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Carries extra error information in replacement-related llvm::Error,
/// e.g. fail applying replacements and replacements conflict.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_Ctor1
    handle.def(pybind11::init<clang::tooling::replacement_error,
                              clang::tooling::Replacement>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor2() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Carries extra error information in replacement-related llvm::Error,
/// e.g. fail applying replacements and replacements conflict.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ReplacementError_Ctor2
    handle.def(pybind11::init<clang::tooling::replacement_error,
                              clang::tooling::Replacement,
                              clang::tooling::Replacement>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ReplacementError(EntityScope parent_h)
      : handle{
            parent_h, "ReplacementError", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Carries extra error information in replacement-related llvm::Error,
/// e.g. fail applying replacements and replacements conflict.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ReplacementError(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_message();
    AddMethod_log();
    AddMethod_get();
    AddMethod_getNewReplacement();
    AddMethod_getExistingReplacement();
    AddCtor0();
    AddCtor1();
    AddCtor2();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ReplacementError"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplacementError

using Entity_clang_tooling_ReplacementError =
    Bind_clang_tooling_ReplacementError<>;

#else

struct Entity_clang_tooling_ReplacementError
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ReplacementError(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ReplacementError"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ReplacementError

template <class Pybind11T = pybind11::class_<clang::tooling::Replacements>>
struct Bind_clang_tooling_Replacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_add() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a new replacement \p R to the current set of replacements.
  /// \p R must have the same file path as all existing replacements.
  /// Returns `success` if the replacement is successfully inserted; otherwise,
  /// it returns an llvm::Error, i.e. there is a conflict between R and the
  /// existing replacements (i.e. they are order-dependent) or R's file path is
  /// different from the filepath of existing replacements. Callers must
  /// explicitly check the Error returned, and the returned error can be
  /// converted to a string message with `llvm::toString()`. This prevents users
  /// from adding order-dependent replacements. To control the order in which
  /// order-dependent replacements are applied, use merge({R}) with R referring
  /// to the changed code after applying all existing replacements.
  /// Two replacements A and B are considered order-independent if applying them
  /// in either order produces the same result. Note that the range of the
  /// replacement that is applied later still refers to the original code.
  /// These include (but not restricted to) replacements that:
  ///   - don't overlap (being directly adjacent is fine) and
  ///   - are overlapping deletions.
  ///   - are insertions at the same offset and applying them in either order
  ///     has the same effect, i.e. X + Y = Y + X when inserting X and Y
  ///     respectively.
  ///   - are identical replacements, i.e. applying the same replacement twice
  ///     is equivalent to applying it once.
  /// Examples:
  /// 1. Replacement A(0, 0, "a") and B(0, 0, "aa") are order-independent since
  ///    applying them in either order gives replacement (0, 0, "aaa").
  ///    However, A(0, 0, "a") and B(0, 0, "b") are order-dependent since
  ///    applying A first gives (0, 0, "ab") while applying B first gives (B, A,
  ///    "ba").
  /// 2. Replacement A(0, 2, "123") and B(0, 2, "123") are order-independent
  ///    since applying them in either order gives (0, 2, "123").
  /// 3. Replacement A(0, 3, "123") and B(2, 3, "321") are order-independent
  ///    since either order gives (0, 5, "12321").
  /// 4. Replacement A(0, 3, "ab") and B(0, 3, "ab") are order-independent since
  ///    applying the same replacement twice is equivalent to applying it once.
  /// Replacements with offset UINT_MAX are special - we do not detect conflicts
  /// for such replacements since users may add them intentionally as a special
  /// category of replacements.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_add
    handle.def(
        "add",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::Replacements, llvm::Error,
                                    const clang::tooling::Replacement &>::type>(
            &clang::tooling::Replacements::add),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_merge() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Merges \p Replaces into the current replacements. \p Replaces
  /// refers to code after applying the current replacements.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_merge
    handle.def("merge",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::Replacements, clang::tooling::Replacements,
                   const clang::tooling::Replacements &>::const_type>(
                   &clang::tooling::Replacements::merge),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAffectedRanges() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the affected ranges in the changed code.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_getAffectedRanges
    handle.def("getAffectedRanges",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::Replacements,
                   std::vector<clang::tooling::Range>>::const_type>(
                   &clang::tooling::Replacements::getAffectedRanges),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getShiftedCodePosition() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Returns the new offset in the code after replacements being applied.
  // Note that if there is an insertion at Offset in the current replacements,
  // \p Offset will be shifted to Offset + Length in inserted text.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_getShiftedCodePosition
    handle.def(
        "getShiftedCodePosition",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::Replacements, unsigned int,
                                    unsigned int>::const_type>(
            &clang::tooling::Replacements::getShiftedCodePosition),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_size() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_size
    handle.def("size",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacements,
                                                   unsigned int>::const_type>(
                   &clang::tooling::Replacements::size));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_clear() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_clear
    handle.def(
        "clear",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::Replacements, void>::type>(
            &clang::tooling::Replacements::clear));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_empty() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_empty
    handle.def("empty",
               static_cast<pybind11_weaver::FnPtrT<clang::tooling::Replacements,
                                                   bool>::const_type>(
                   &clang::tooling::Replacements::empty));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_begin() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_begin
    handle.def(
        "begin",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::Replacements,
            std::_Rb_tree_const_iterator<clang::tooling::Replacement>>::
                        const_type>(&clang::tooling::Replacements::begin));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_end() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_end
    handle.def("end",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::Replacements,
                   std::_Rb_tree_const_iterator<clang::tooling::Replacement>>::
                               const_type>(&clang::tooling::Replacements::end));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_rbegin() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_rbegin
    handle.def("rbegin", static_cast<pybind11_weaver::FnPtrT<
                             clang::tooling::Replacements,
                             std::reverse_iterator<std::_Rb_tree_const_iterator<
                                 clang::tooling::Replacement>>>::const_type>(
                             &clang::tooling::Replacements::rbegin));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_rend() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_rend
    handle.def("rend", static_cast<pybind11_weaver::FnPtrT<
                           clang::tooling::Replacements,
                           std::reverse_iterator<std::_Rb_tree_const_iterator<
                               clang::tooling::Replacement>>>::const_type>(
                           &clang::tooling::Replacements::rend));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Maintains a set of replacements that are conflict-free.
/// Two replacements are considered conflicts if they overlap or have the same
/// offset (i.e. order-dependent).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Maintains a set of replacements that are conflict-free.
/// Two replacements are considered conflicts if they overlap or have the same
/// offset (i.e. order-dependent).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Replacements_Ctor1
    handle.def(pybind11::init<const clang::tooling::Replacement &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_Replacements(EntityScope parent_h)
      : handle{
            parent_h, "Replacements", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Maintains a set of replacements that are conflict-free.
/// Two replacements are considered conflicts if they overlap or have the same
/// offset (i.e. order-dependent).)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_Replacements(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_add();
    AddMethod_merge();
    AddMethod_getAffectedRanges();
    AddMethod_getShiftedCodePosition();
    AddMethod_size();
    AddMethod_clear();
    AddMethod_empty();
    AddMethod_begin();
    AddMethod_end();
    AddMethod_rbegin();
    AddMethod_rend();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_Replacements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_Replacements

using Entity_clang_tooling_Replacements = Bind_clang_tooling_Replacements<>;

#else

struct Entity_clang_tooling_Replacements
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_Replacements(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_Replacements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_Replacements

template <class Pybind11T = pybind11::class_<clang::tooling::SelectedASTNode>>
struct Bind_clang_tooling_SelectedASTNode : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_dump() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SelectedASTNode_dump
    handle.def(
        "dump",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::SelectedASTNode, void,
                                    llvm::raw_ostream &>::const_type>(
            &clang::tooling::SelectedASTNode::dump));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Represents a selected AST node.
///
/// AST selection is represented using a tree of \c SelectedASTNode. The tree
/// follows the top-down shape of the actual AST. Each selected node has
/// a selection kind. The kind might be none as the node itself might not
/// actually be selected, e.g. a statement in macro whose child is in a macro
/// argument.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SelectedASTNode_Ctor0
    handle.def(pybind11::init<const clang::DynTypedNode &,
                              clang::tooling::SourceSelectionKind>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_SelectedASTNode(EntityScope parent_h)
      : handle{parent_h, "SelectedASTNode", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Represents a selected AST node.
///
/// AST selection is represented using a tree of \c SelectedASTNode. The tree
/// follows the top-down shape of the actual AST. Each selected node has
/// a selection kind. The kind might be none as the node itself might not
/// actually be selected, e.g. a statement in macro whose child is in a macro
/// argument.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SelectedASTNode(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_dump();
    AddCtor0();
    handle.def_readwrite("SelectionKind",
                         &clang::tooling::SelectedASTNode::SelectionKind);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_SelectedASTNode"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SelectedASTNode

using Entity_clang_tooling_SelectedASTNode =
    Bind_clang_tooling_SelectedASTNode<>;

#else

struct Entity_clang_tooling_SelectedASTNode
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SelectedASTNode(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_SelectedASTNode"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SelectedASTNode

template <class Pybind11T =
              pybind11::class_<clang::tooling::SourceChangeRefactoringRule,
                               clang::tooling::RefactoringActionRuleBase>>
struct Bind_clang_tooling_SourceChangeRefactoringRule : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_invoke() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SourceChangeRefactoringRule_invoke
    handle.def("invoke",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::SourceChangeRefactoringRule, void,
                   clang::tooling::RefactoringResultConsumer &,
                   clang::tooling::RefactoringRuleContext &>::type>(
                   &clang::tooling::SourceChangeRefactoringRule::invoke));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_SourceChangeRefactoringRule(EntityScope parent_h)
      : handle{
            parent_h, "SourceChangeRefactoringRule", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A type of refactoring action rule that produces source replacements in the
/// form of atomic changes.
///
/// This action rule is typically used for local refactorings that replace
/// source in a single AST unit.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SourceChangeRefactoringRule(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_invoke();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::SourceChangeRefactoringRule>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_SourceChangeRefactoringRule";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceChangeRefactoringRule

using Entity_clang_tooling_SourceChangeRefactoringRule =
    Bind_clang_tooling_SourceChangeRefactoringRule<>;

#else

struct Entity_clang_tooling_SourceChangeRefactoringRule
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SourceChangeRefactoringRule(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_SourceChangeRefactoringRule";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceChangeRefactoringRule

template <class = void>
class PyTrampSourceFileCallbacks : public clang::tooling::SourceFileCallbacks {
public:
  using _PB11_WR_BaseT = clang::tooling::SourceFileCallbacks;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_SourceFileCallbacksbool_9CompilerInstance___
  bool handleBeginSource(clang::CompilerInstance &CI) override {
    using _PB11_WR_RET_TYPE = bool;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::SourceFileCallbacks;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleBeginSource, CI);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_SourceFileCallbacksbool_9CompilerInstance___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_SourceFileCallbacksvoid_9_
  void handleEndSource() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::SourceFileCallbacks;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleEndSource,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_SourceFileCallbacksvoid_9_
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::SourceFileCallbacks,
                               PyTrampSourceFileCallbacks<>>>
struct Bind_clang_tooling_SourceFileCallbacks : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_handleBeginSource() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Called before a source file is processed by a FrontEndAction.
  /// \see clang::FrontendAction::BeginSourceFileAction)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SourceFileCallbacks_handleBeginSource
    handle.def(
        "handleBeginSource",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::SourceFileCallbacks, bool,
                                    clang::CompilerInstance &>::type>(
            &clang::tooling::SourceFileCallbacks::handleBeginSource),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleEndSource() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Called after a source file is processed by a FrontendAction.
  /// \see clang::FrontendAction::EndSourceFileAction)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SourceFileCallbacks_handleEndSource
    handle.def(
        "handleEndSource",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::SourceFileCallbacks,
                                            void>::type>(
            &clang::tooling::SourceFileCallbacks::handleEndSource),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_SourceFileCallbacks(EntityScope parent_h)
      : handle{
            parent_h, "SourceFileCallbacks", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Callbacks called before and after each source file processed by a
/// FrontendAction created by the FrontedActionFactory returned by \c
/// newFrontendActionFactory.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SourceFileCallbacks(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_handleBeginSource();
    AddMethod_handleEndSource();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::SourceFileCallbacks>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_SourceFileCallbacks"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceFileCallbacks

using Entity_clang_tooling_SourceFileCallbacks =
    Bind_clang_tooling_SourceFileCallbacks<>;

#else

struct Entity_clang_tooling_SourceFileCallbacks
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SourceFileCallbacks(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_SourceFileCallbacks"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceFileCallbacks

template <class Pybind11T =
              pybind11::enum_<clang::tooling::SourceSelectionKind>>
struct Bind_clang_tooling_SourceSelectionKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_SourceSelectionKind(EntityScope parent_h)
      : handle{parent_h, "SourceSelectionKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SourceSelectionKind(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("None", clang::tooling::SourceSelectionKind::None,
                 R"_pb11_weaver(/// A node that's not selected.)_pb11_weaver");
    handle.value(
        "ContainsSelection",
        clang::tooling::SourceSelectionKind::ContainsSelection,
        R"_pb11_weaver(/// A node that's considered to be selected because the whole selection range
  /// is inside of its source range.)_pb11_weaver");
    handle.value(
        "ContainsSelectionStart",
        clang::tooling::SourceSelectionKind::ContainsSelectionStart,
        R"_pb11_weaver(/// A node that's considered to be selected because the start of the selection
  /// range is inside its source range.)_pb11_weaver");
    handle.value(
        "ContainsSelectionEnd",
        clang::tooling::SourceSelectionKind::ContainsSelectionEnd,
        R"_pb11_weaver(/// A node that's considered to be selected because the end of the selection
  /// range is inside its source range.)_pb11_weaver");
    handle.value(
        "InsideSelection", clang::tooling::SourceSelectionKind::InsideSelection,
        R"_pb11_weaver(/// A node that's considered to be selected because the node is entirely in
  /// the selection range.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_SourceSelectionKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceSelectionKind

using Entity_clang_tooling_SourceSelectionKind =
    Bind_clang_tooling_SourceSelectionKind<>;

#else

struct Entity_clang_tooling_SourceSelectionKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SourceSelectionKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_SourceSelectionKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceSelectionKind

template <class Pybind11T = pybind11::class_<
              clang::tooling::SourceSelectionRequirement,
              clang::tooling::RefactoringActionRuleRequirement>>
struct Bind_clang_tooling_SourceSelectionRequirement : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_SourceSelectionRequirement(EntityScope parent_h)
      : handle{parent_h, "SourceSelectionRequirement", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A base class for any requirement that expects some part of the source to be
/// selected in an editor (or the refactoring tool with the -selection option).)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SourceSelectionRequirement(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::SourceSelectionRequirement>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_SourceSelectionRequirement";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceSelectionRequirement

using Entity_clang_tooling_SourceSelectionRequirement =
    Bind_clang_tooling_SourceSelectionRequirement<>;

#else

struct Entity_clang_tooling_SourceSelectionRequirement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SourceSelectionRequirement(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_SourceSelectionRequirement";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceSelectionRequirement

template <class Pybind11T = pybind11::class_<clang::tooling::SymbolName>>
struct Bind_clang_tooling_SymbolName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getNamePieces() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SymbolName_getNamePieces
    handle.def("getNamePieces",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::SymbolName,
                   llvm::ArrayRef<std::basic_string<char>>>::const_type>(
                   &clang::tooling::SymbolName::getNamePieces));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A name of a symbol.
///
/// Symbol's name can be composed of multiple strings. For example, Objective-C
/// methods can contain multiple argument labels:
///
/// \code
/// - (void) myMethodNamePiece: (int)x anotherNamePieces:(int)y;
/// //       ^~ string 0 ~~~~~         ^~ string 1 ~~~~~
/// \endcode)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SymbolName_Ctor0
    handle.def(pybind11::init<llvm::StringRef>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_SymbolName(EntityScope parent_h)
      : handle{parent_h, "SymbolName", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A name of a symbol.
///
/// Symbol's name can be composed of multiple strings. For example, Objective-C
/// methods can contain multiple argument labels:
///
/// \code
/// - (void) myMethodNamePiece: (int)x anotherNamePieces:(int)y;
/// //       ^~ string 0 ~~~~~         ^~ string 1 ~~~~~
/// \endcode)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SymbolName(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getNamePieces();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_SymbolName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SymbolName

using Entity_clang_tooling_SymbolName = Bind_clang_tooling_SymbolName<>;

#else

struct Entity_clang_tooling_SymbolName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SymbolName(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_SymbolName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SymbolName

template <class Pybind11T = pybind11::class_<clang::tooling::SymbolOccurrence>>
struct Bind_clang_tooling_SymbolOccurrence : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getKind() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SymbolOccurrence_getKind
    handle.def(
        "getKind",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::SymbolOccurrence,
            clang::tooling::SymbolOccurrence::OccurrenceKind>::const_type>(
            &clang::tooling::SymbolOccurrence::getKind));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getNameRanges() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SymbolOccurrence_getNameRanges
    handle.def("getNameRanges",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::SymbolOccurrence,
                   llvm::ArrayRef<clang::SourceRange>>::const_type>(
                   &clang::tooling::SymbolOccurrence::getNameRanges));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An occurrence of a symbol in the source.
///
/// Occurrences can have difference kinds, that describe whether this occurrence
/// is an exact semantic match, or whether this is a weaker textual match that's
/// not guaranteed to represent the exact declaration.
///
/// A single occurrence of a symbol can span more than one source range. For
/// example, Objective-C selectors can contain multiple argument labels:
///
/// \code
/// [object selectorPiece1: ... selectorPiece2: ...];
/// //      ^~~ range 0 ~~      ^~~ range 1 ~~
/// \endcode
///
/// We have to replace the text in both range 0 and range 1 when renaming the
/// Objective-C method 'selectorPiece1:selectorPiece2'.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SymbolOccurrence_Ctor0
    handle.def(pybind11::init<const clang::tooling::SymbolName &,
                              clang::tooling::SymbolOccurrence::OccurrenceKind,
                              llvm::ArrayRef<clang::SourceLocation>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_SymbolOccurrence(EntityScope parent_h)
      : handle{parent_h, "SymbolOccurrence", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An occurrence of a symbol in the source.
///
/// Occurrences can have difference kinds, that describe whether this occurrence
/// is an exact semantic match, or whether this is a weaker textual match that's
/// not guaranteed to represent the exact declaration.
///
/// A single occurrence of a symbol can span more than one source range. For
/// example, Objective-C selectors can contain multiple argument labels:
///
/// \code
/// [object selectorPiece1: ... selectorPiece2: ...];
/// //      ^~~ range 0 ~~      ^~~ range 1 ~~
/// \endcode
///
/// We have to replace the text in both range 0 and range 1 when renaming the
/// Objective-C method 'selectorPiece1:selectorPiece2'.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SymbolOccurrence(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getKind();
    AddMethod_getNameRanges();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_SymbolOccurrence"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SymbolOccurrence

using Entity_clang_tooling_SymbolOccurrence =
    Bind_clang_tooling_SymbolOccurrence<>;

#else

struct Entity_clang_tooling_SymbolOccurrence
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SymbolOccurrence(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_SymbolOccurrence"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SymbolOccurrence

template <class Pybind11T =
              pybind11::enum_<clang::tooling::SymbolOccurrence::OccurrenceKind>>
struct Bind_clang_tooling_SymbolOccurrence_OccurrenceKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_SymbolOccurrence_OccurrenceKind(
      EntityScope parent_h)
      : handle{parent_h, "OccurrenceKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SymbolOccurrence_OccurrenceKind(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "MatchingSymbol",
        clang::tooling::SymbolOccurrence::OccurrenceKind::MatchingSymbol,
        R"_pb11_weaver(/// This occurrence is an exact match and can be renamed automatically.
    ///
    /// Note:
    /// Symbol occurrences in macro arguments that expand to different
    /// declarations get marked as exact matches, and thus the renaming engine
    /// will rename them e.g.:
    ///
    /// \code
    ///   #define MACRO(x) x + ns::x
    ///   int foo(int var) {
    ///     return MACRO(var); // var is renamed automatically here when
    ///                        // either var or ns::var is renamed.
    ///   };
    /// \endcode
    ///
    /// The user will have to fix their code manually after performing such a
    /// rename.
    /// FIXME: The rename verifier should notify user about this issue.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_SymbolOccurrence_OccurrenceKind";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SymbolOccurrence_OccurrenceKind

using Entity_clang_tooling_SymbolOccurrence_OccurrenceKind =
    Bind_clang_tooling_SymbolOccurrence_OccurrenceKind<>;

#else

struct Entity_clang_tooling_SymbolOccurrence_OccurrenceKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SymbolOccurrence_OccurrenceKind(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_SymbolOccurrence_OccurrenceKind";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SymbolOccurrence_OccurrenceKind

template <class = void>
class PyTrampToolAction : public clang::tooling::ToolAction {
public:
  using _PB11_WR_BaseT = clang::tooling::ToolAction;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolActionbool_9std_shared_ptr6CompilerInvocation9__FileManager____std_shared_ptr6PCHContainerOperations9__DiagnosticConsumer___
  bool
  runInvocation(std::shared_ptr<clang::CompilerInvocation> Invocation,
                clang::FileManager *Files,
                std::shared_ptr<clang::PCHContainerOperations> PCHContainerOps,
                clang::DiagnosticConsumer *DiagConsumer) override {
    using _PB11_WR_RET_TYPE = bool;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolAction;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           runInvocation, Invocation, Files, PCHContainerOps,
                           DiagConsumer);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolActionbool_9std_shared_ptr6CompilerInvocation9__FileManager____std_shared_ptr6PCHContainerOperations9__DiagnosticConsumer___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::ToolAction, PyTrampToolAction<>>>
struct Bind_clang_tooling_ToolAction : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_runInvocation() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Perform an action for an invocation.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolAction_runInvocation
    handle.def(
        "runInvocation",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ToolAction, bool,
            std::shared_ptr<clang::CompilerInvocation>, clang::FileManager *,
            std::shared_ptr<clang::PCHContainerOperations>,
            clang::DiagnosticConsumer *>::type>(
            &clang::tooling::ToolAction::runInvocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ToolAction(EntityScope parent_h)
      : handle{
            parent_h, "ToolAction", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Interface to process a clang::CompilerInvocation.
///
/// If your tool is based on FrontendAction, you should be deriving from
/// FrontendActionFactory instead.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ToolAction(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_runInvocation();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ToolAction>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ToolAction"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolAction

using Entity_clang_tooling_ToolAction = Bind_clang_tooling_ToolAction<>;

#else

struct Entity_clang_tooling_ToolAction
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ToolAction(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ToolAction"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolAction

template <class = void>
class PyTrampToolExecutor : public clang::tooling::ToolExecutor {
public:
  using _PB11_WR_BaseT = clang::tooling::ToolExecutor;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorStringRef_9__const
  llvm::StringRef getExecutorName() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolExecutor;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getExecutorName,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorllvm_Error_9llvm_ArrayRef6std_pair6std_unique_ptr6FrontendActionFactory9__ArgumentsAdjuster99_
  llvm::Error execute(
      llvm::ArrayRef<std::pair<
          std::unique_ptr<clang::tooling::FrontendActionFactory>,
          std::function<std::vector<std::basic_string<char>>(
              const std::vector<std::basic_string<char>> &, llvm::StringRef)>>>
          Actions) override {
    using _PB11_WR_RET_TYPE = llvm::Error;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolExecutor;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, execute,
                           Actions);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorllvm_Error_9llvm_ArrayRef6std_pair6std_unique_ptr6FrontendActionFactory9__ArgumentsAdjuster99_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorExecutionContext__9_
  clang::tooling::ExecutionContext *getExecutionContext() override {
    using _PB11_WR_RET_TYPE = clang::tooling::ExecutionContext *;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolExecutor;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getExecutionContext,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorExecutionContext__9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorToolResults__9_
  clang::tooling::ToolResults *getToolResults() override {
    using _PB11_WR_RET_TYPE = clang::tooling::ToolResults *;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolExecutor;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           getToolResults,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorToolResults__9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorvoid_9StringRef__StringRef_
  void mapVirtualFile(llvm::StringRef FilePath,
                      llvm::StringRef Content) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolExecutor;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           mapVirtualFile, FilePath, Content);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorvoid_9StringRef__StringRef_
};

template <class Pybind11T = pybind11::class_<clang::tooling::ToolExecutor,
                                             PyTrampToolExecutor<>>>
struct Bind_clang_tooling_ToolExecutor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getExecutorName() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the name of a specific executor.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_getExecutorName
    handle.def(
        "getExecutorName",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::ToolExecutor,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::ToolExecutor::getExecutorName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_execute() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Executes each action with a corresponding arguments adjuster.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_execute
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_execute
    handle.def("execute", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_execute1() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Convenient functions for the above `execute`.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_execute1
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_execute1
    handle.def("execute", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_execute2() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Executes an action with an argument adjuster.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_execute2
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_execute2
    handle.def("execute", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getExecutionContext() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a reference to the execution context.
  ///
  /// This should be passed to tool callbacks, and tool callbacks should report
  /// results via the returned context.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_getExecutionContext
    handle.def(
        "getExecutionContext",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ToolExecutor,
                                    clang::tooling::ExecutionContext *>::type>(
            &clang::tooling::ToolExecutor::getExecutionContext),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getToolResults() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a reference to the result container.
  ///
  /// NOTE: This should only be used after the execution finishes. Tool
  /// callbacks should report results via `ExecutionContext` instead.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_getToolResults
    handle.def(
        "getToolResults",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ToolExecutor, clang::tooling::ToolResults *>::type>(
            &clang::tooling::ToolExecutor::getToolResults),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_mapVirtualFile() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Map a virtual file to be used while running the tool.
  ///
  /// \param FilePath The path at which the content will be mapped.
  /// \param Content A buffer of the file's content.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutor_mapVirtualFile
    handle.def(
        "mapVirtualFile",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ToolExecutor, void,
                                    llvm::StringRef, llvm::StringRef>::type>(
            &clang::tooling::ToolExecutor::mapVirtualFile),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ToolExecutor(EntityScope parent_h)
      : handle{
            parent_h, "ToolExecutor", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Interface for executing clang frontend actions.
///
/// This can be extended to support running tool actions in different
/// execution mode, e.g. on a specific set of TUs or many TUs in parallel.
///
///  New executors can be registered as ToolExecutorPlugins via the
///  `ToolExecutorPluginRegistry`. CLI tools can use
///  `createExecutorFromCommandLineArgs` to create a specific registered
///  executor according to the command-line arguments.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ToolExecutor(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getExecutorName();
    AddMethod_execute();
    AddMethod_execute1();
    AddMethod_execute2();
    AddMethod_getExecutionContext();
    AddMethod_getToolResults();
    AddMethod_mapVirtualFile();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ToolExecutor>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ToolExecutor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolExecutor

using Entity_clang_tooling_ToolExecutor = Bind_clang_tooling_ToolExecutor<>;

#else

struct Entity_clang_tooling_ToolExecutor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ToolExecutor(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ToolExecutor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolExecutor

template <class = void>
class PyTrampToolExecutorPlugin : public clang::tooling::ToolExecutorPlugin {
public:
  using _PB11_WR_BaseT = clang::tooling::ToolExecutorPlugin;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorPluginllvm_Expected6std_unique_ptr6ToolExecutor99_9CommonOptionsParser___
  llvm::Expected<std::unique_ptr<clang::tooling::ToolExecutor>>
  create(clang::tooling::CommonOptionsParser &OptionsParser) override {
    using _PB11_WR_RET_TYPE =
        llvm::Expected<std::unique_ptr<clang::tooling::ToolExecutor>>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolExecutorPlugin;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, create,
                           OptionsParser);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolExecutorPluginllvm_Expected6std_unique_ptr6ToolExecutor99_9CommonOptionsParser___
};

template <class Pybind11T = pybind11::class_<clang::tooling::ToolExecutorPlugin,
                                             PyTrampToolExecutorPlugin<>>>
struct Bind_clang_tooling_ToolExecutorPlugin : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_create() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Create an `ToolExecutor`.
  ///
  /// `OptionsParser` can be consumed (e.g. moved) if the creation succeeds.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_ToolExecutorPlugin_create
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolExecutorPlugin_create
    handle.def("create", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ToolExecutorPlugin(EntityScope parent_h)
      : handle{parent_h, "ToolExecutorPlugin", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Interface for factories that create specific executors. This is also
/// used as a plugin to be registered into ToolExecutorPluginRegistry.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ToolExecutorPlugin(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_create();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ToolExecutorPlugin>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ToolExecutorPlugin"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolExecutorPlugin

using Entity_clang_tooling_ToolExecutorPlugin =
    Bind_clang_tooling_ToolExecutorPlugin<>;

#else

struct Entity_clang_tooling_ToolExecutorPlugin
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ToolExecutorPlugin(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ToolExecutorPlugin"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolExecutorPlugin

template <class Pybind11T = pybind11::class_<clang::tooling::ToolInvocation>>
struct Bind_clang_tooling_ToolInvocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_setDiagnosticConsumer() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Set a \c DiagnosticConsumer to use during driver command-line parsing and
  /// the action invocation itself.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolInvocation_setDiagnosticConsumer
    handle.def("setDiagnosticConsumer",
               static_cast<
                   pybind11_weaver::FnPtrT<clang::tooling::ToolInvocation, void,
                                           clang::DiagnosticConsumer *>::type>(
                   &clang::tooling::ToolInvocation::setDiagnosticConsumer),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setDiagnosticOptions() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Set a \c DiagnosticOptions to use during driver command-line parsing.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolInvocation_setDiagnosticOptions
    handle.def("setDiagnosticOptions",
               static_cast<
                   pybind11_weaver::FnPtrT<clang::tooling::ToolInvocation, void,
                                           clang::DiagnosticOptions *>::type>(
                   &clang::tooling::ToolInvocation::setDiagnosticOptions),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Run the clang invocation.
  ///
  /// \returns True if there were no errors during execution.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolInvocation_run
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::ToolInvocation,
                                            bool>::type>(
            &clang::tooling::ToolInvocation::run),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Utility to run a FrontendAction in a single clang invocation.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_ToolInvocation_Ctor0
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolInvocation_Ctor0
    handle.def(pybind11::init<std::vector<std::basic_string<char>>,
                              std::unique_ptr<clang::FrontendAction>,
                              clang::FileManager *,
                              std::shared_ptr<clang::PCHContainerOperations>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Utility to run a FrontendAction in a single clang invocation.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolInvocation_Ctor1
    handle.def(
        pybind11::init<std::vector<std::basic_string<char>>,
                       clang::tooling::ToolAction *, clang::FileManager *,
                       std::shared_ptr<clang::PCHContainerOperations>>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ToolInvocation(EntityScope parent_h)
      : handle{parent_h, "ToolInvocation", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Utility to run a FrontendAction in a single clang invocation.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ToolInvocation(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_setDiagnosticConsumer();
    AddMethod_setDiagnosticOptions();
    AddMethod_run();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ToolInvocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolInvocation

using Entity_clang_tooling_ToolInvocation = Bind_clang_tooling_ToolInvocation<>;

#else

struct Entity_clang_tooling_ToolInvocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ToolInvocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ToolInvocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolInvocation

template <class = void>
class PyTrampToolResults : public clang::tooling::ToolResults {
public:
  using _PB11_WR_BaseT = clang::tooling::ToolResults;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolResultsvoid_9StringRef__StringRef_
  void addResult(llvm::StringRef Key, llvm::StringRef Value) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolResults;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           addResult, Key, Value);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolResultsvoid_9StringRef__StringRef_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolResultsstd_vector6std_pair6llvm_StringRef__llvm_StringRef99_9_
  std::vector<std::pair<llvm::StringRef, llvm::StringRef>>
  AllKVResults() override {
    using _PB11_WR_RET_TYPE =
        std::vector<std::pair<llvm::StringRef, llvm::StringRef>>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolResults;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           AllKVResults,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolResultsstd_vector6std_pair6llvm_StringRef__llvm_StringRef99_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolResultsvoid_9llvm_function_ref6void_9StringRef__StringRef_9_
  void forEachResult(llvm::function_ref<void(llvm::StringRef, llvm::StringRef)>
                         Callback) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::ToolResults;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           forEachResult, Callback);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ToolResultsvoid_9llvm_function_ref6void_9StringRef__StringRef_9_
};

template <class Pybind11T = pybind11::class_<clang::tooling::ToolResults,
                                             PyTrampToolResults<>>>
struct Bind_clang_tooling_ToolResults : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_addResult() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolResults_addResult
    handle.def(
        "addResult",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::ToolResults, void,
                                    llvm::StringRef, llvm::StringRef>::type>(
            &clang::tooling::ToolResults::addResult));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_AllKVResults() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolResults_AllKVResults
    handle.def(
        "AllKVResults",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ToolResults,
            std::vector<std::pair<llvm::StringRef, llvm::StringRef>>>::type>(
            &clang::tooling::ToolResults::AllKVResults));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_forEachResult() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ToolResults_forEachResult
    handle.def(
        "forEachResult",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ToolResults, void,
            llvm::function_ref<void(llvm::StringRef, llvm::StringRef)>>::type>(
            &clang::tooling::ToolResults::forEachResult));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ToolResults(EntityScope parent_h)
      : handle{parent_h, "ToolResults", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An abstraction for the result of a tool execution. For example, the
/// underlying result can be in-memory or on-disk.
///
/// Results should be string key-value pairs. For example, a refactoring tool
/// can use source location as key and a replacement in YAML format as value.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ToolResults(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_addResult();
    AddMethod_AllKVResults();
    AddMethod_forEachResult();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ToolResults>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ToolResults"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolResults

using Entity_clang_tooling_ToolResults = Bind_clang_tooling_ToolResults<>;

#else

struct Entity_clang_tooling_ToolResults
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ToolResults(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ToolResults"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ToolResults

template <class = void>
class PyTrampTransformer1 : public clang::tooling::Transformer {
public:
  using _PB11_WR_BaseT = clang::tooling::Transformer;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformervoid_9_
  void onStartOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::Transformer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onStartOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformervoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformervoid_9_
  void onEndOfTranslationUnit() override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::Transformer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      onEndOfTranslationUnit,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformervoid_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_TransformerStringRef_9__const
  llvm::StringRef getID() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::Transformer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getID,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_TransformerStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformerstd_optional6TraversalKind9_9__const
  std::optional<clang::TraversalKind> getCheckTraversalKind() const override {
    using _PB11_WR_RET_TYPE = std::optional<clang::TraversalKind>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::Transformer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCheckTraversalKind,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformerstd_optional6TraversalKind9_9__const
};

template <class = void>
class PyTrampTransformer : public PyTrampTransformer1<> {
public:
  using _PB11_WR_BaseT = PyTrampTransformer1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformervoid_9const_ast_matchers_MatchFinder_MatchResult___
  void
  run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::Transformer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, run, Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_Transformervoid_9const_ast_matchers_MatchFinder_MatchResult___
};

template <class Pybind11T = pybind11::class_<clang::tooling::Transformer,
                                             PyTrampTransformer<>>>
struct Bind_clang_tooling_Transformer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_registerMatchers() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// N.B. Passes `this` pointer to `MatchFinder`.  So, this object should not
  /// be moved after this call.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Transformer_registerMatchers
    handle.def(
        "registerMatchers",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::Transformer, void,
                                    clang::ast_matchers::MatchFinder *>::type>(
            &clang::tooling::Transformer::registerMatchers),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_run() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Not called directly by users -- called by the framework, via base class
  /// pointer.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Transformer_run
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::Transformer, void,
            const clang::ast_matchers::MatchFinder::MatchResult &>::type>(
            &clang::tooling::Transformer::run),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Handles the matcher and callback registration for a single `RewriteRule`, as
/// defined by the arguments of the constructor.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_Transformer_Ctor0
    handle.def(pybind11::init<
                   clang::transformer::RewriteRuleWith<void>,
                   std::function<void(llvm::Expected<llvm::MutableArrayRef<
                                          clang::tooling::AtomicChange>>)>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_Transformer(EntityScope parent_h)
      : handle{
            parent_h, "Transformer", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Handles the matcher and callback registration for a single `RewriteRule`, as
/// defined by the arguments of the constructor.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_Transformer(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_registerMatchers();
    AddMethod_run();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_Transformer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_Transformer

using Entity_clang_tooling_Transformer = Bind_clang_tooling_Transformer<>;

#else

struct Entity_clang_tooling_Transformer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_Transformer(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_Transformer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_Transformer

template <class Pybind11T =
              pybind11::class_<clang::tooling::TransformerResult<void>>>
struct Bind_clang_tooling_TransformerResult6void9 : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = void;

  explicit Bind_clang_tooling_TransformerResult6void9(EntityScope parent_h)
      : handle{parent_h, "TransformerResult6void9", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_TransformerResult6void9(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::TransformerResult<void>>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_TransformerResult6void9"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_TransformerResult6void9

using Entity_clang_tooling_TransformerResult6void9 =
    Bind_clang_tooling_TransformerResult6void9<>;

#else

struct Entity_clang_tooling_TransformerResult6void9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_TransformerResult6void9(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_TransformerResult6void9"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_TransformerResult6void9

template <class Pybind11T =
              pybind11::class_<clang::tooling::TranslationUnitDiagnostics>>
struct Bind_clang_tooling_TranslationUnitDiagnostics : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_TranslationUnitDiagnostics(EntityScope parent_h)
      : handle{parent_h, "TranslationUnitDiagnostics", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Collection of Diagnostics generated from a single translation unit.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_TranslationUnitDiagnostics(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::TranslationUnitDiagnostics>(handle);
    handle.def_readwrite(
        "MainSourceFile",
        &clang::tooling::TranslationUnitDiagnostics::MainSourceFile,
        R"_pb11_weaver(/// Name of the main source for the translation unit.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_TranslationUnitDiagnostics";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_TranslationUnitDiagnostics

using Entity_clang_tooling_TranslationUnitDiagnostics =
    Bind_clang_tooling_TranslationUnitDiagnostics<>;

#else

struct Entity_clang_tooling_TranslationUnitDiagnostics
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_TranslationUnitDiagnostics(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_TranslationUnitDiagnostics";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_TranslationUnitDiagnostics

template <class Pybind11T =
              pybind11::class_<clang::tooling::TranslationUnitReplacements>>
struct Bind_clang_tooling_TranslationUnitReplacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_TranslationUnitReplacements(EntityScope parent_h)
      : handle{parent_h, "TranslationUnitReplacements",
               pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Collection of Replacements generated from a single translation unit.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_TranslationUnitReplacements(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::TranslationUnitReplacements>(handle);
    handle.def_readwrite(
        "MainSourceFile",
        &clang::tooling::TranslationUnitReplacements::MainSourceFile,
        R"_pb11_weaver(/// Name of the main source for the translation unit.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_TranslationUnitReplacements";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_TranslationUnitReplacements

using Entity_clang_tooling_TranslationUnitReplacements =
    Bind_clang_tooling_TranslationUnitReplacements<>;

#else

struct Entity_clang_tooling_TranslationUnitReplacements
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_TranslationUnitReplacements(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_TranslationUnitReplacements";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_TranslationUnitReplacements

template <class Pybind11T = pybind11::class_<clang::tooling::USRFindingAction>>
struct Bind_clang_tooling_USRFindingAction : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_newASTConsumer() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_USRFindingAction_newASTConsumer
#ifndef PB11_WEAVER_DISABLE_clang_tooling_USRFindingAction_newASTConsumer
    handle.def("newASTConsumer", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getUSRSpellings() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_USRFindingAction_getUSRSpellings
    handle.def("getUSRSpellings",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::USRFindingAction,
                   llvm::ArrayRef<std::basic_string<char>>>::type>(
                   &clang::tooling::USRFindingAction::getUSRSpellings));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getUSRList() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_USRFindingAction_getUSRList
    handle.def("getUSRList",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::USRFindingAction,
                   llvm::ArrayRef<std::vector<std::basic_string<char>>>>::type>(
                   &clang::tooling::USRFindingAction::getUSRList));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_errorOccurred() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_USRFindingAction_errorOccurred
    handle.def(
        "errorOccurred",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::USRFindingAction,
                                            bool>::type>(
            &clang::tooling::USRFindingAction::errorOccurred));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_USRFindingAction_Ctor0
    handle.def(pybind11::init<llvm::ArrayRef<unsigned int>,
                              llvm::ArrayRef<std::basic_string<char>>, bool>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_USRFindingAction(EntityScope parent_h)
      : handle{parent_h, "USRFindingAction", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_USRFindingAction(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_newASTConsumer();
    AddMethod_getUSRSpellings();
    AddMethod_getUSRList();
    AddMethod_errorOccurred();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_USRFindingAction"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_USRFindingAction

using Entity_clang_tooling_USRFindingAction =
    Bind_clang_tooling_USRFindingAction<>;

#else

struct Entity_clang_tooling_USRFindingAction
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_USRFindingAction(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_USRFindingAction"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_USRFindingAction

template <class Pybind11T = pybind11::module_ &>
struct Bind_addExpandedResponseFiles : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Helper function that expands response files in command line.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_addExpandedResponseFiles_AddFunction
    handle.def(
        "addExpandedResponseFiles",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(std::vector<std::basic_string<char>> &, llvm::StringRef,
                       void (*)(llvm::StringRef, llvm::StringSaver &,
                                llvm::SmallVectorImpl<const char *> &, bool),
                       llvm::vfs::FileSystem &)>::type>(
            &clang::tooling::addExpandedResponseFiles),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_addExpandedResponseFiles(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_addExpandedResponseFiles(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "addExpandedResponseFiles"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_addExpandedResponseFiles

using Entity_addExpandedResponseFiles = Bind_addExpandedResponseFiles<>;

#else

struct Entity_addExpandedResponseFiles
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_addExpandedResponseFiles(EntityScope parent_h) {}
  static const char *Key() { return "addExpandedResponseFiles"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_addExpandedResponseFiles

template <class Pybind11T = pybind11::module_ &>
struct Bind_addTargetAndModeForProgramName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Changes CommandLine to contain implicit flags that would have been
/// defined had the compiler driver been invoked through the path InvokedAs.
///
/// For example, when called with \c InvokedAs set to `i686-linux-android-g++`,
/// the arguments '-target', 'i686-linux-android`, `--driver-mode=g++` will
/// be inserted after the first argument in \c CommandLine.
///
/// This function will not add new `-target` or `--driver-mode` flags if they
/// are already present in `CommandLine` (even if they have different settings
/// than would have been inserted).
///
/// \pre `llvm::InitializeAllTargets()` has been called.
///
/// \param CommandLine the command line used to invoke the compiler driver or
/// Clang tool, including the path to the executable as \c CommandLine[0].
/// \param InvokedAs the path to the driver used to infer implicit flags.
///
/// \note This will not set \c CommandLine[0] to \c InvokedAs. The tooling
/// infrastructure expects that CommandLine[0] is a tool path relative to which
/// the builtin headers can be found.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_addTargetAndModeForProgramName_AddFunction
    handle.def("addTargetAndModeForProgramName",
               static_cast<pybind11_weaver::FnPtrT<
                   void, void(std::vector<std::basic_string<char>> &,
                              llvm::StringRef)>::type>(
                   &clang::tooling::addTargetAndModeForProgramName),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_addTargetAndModeForProgramName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_addTargetAndModeForProgramName(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "addTargetAndModeForProgramName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_addTargetAndModeForProgramName

using Entity_addTargetAndModeForProgramName =
    Bind_addTargetAndModeForProgramName<>;

#else

struct Entity_addTargetAndModeForProgramName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_addTargetAndModeForProgramName(EntityScope parent_h) {}
  static const char *Key() { return "addTargetAndModeForProgramName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_addTargetAndModeForProgramName

template <class Pybind11T = pybind11::module_ &>
struct Bind_applyAllReplacements1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Applies all replacements in \p Replaces to \p Code.
///
/// This completely ignores the path stored in each replacement. If all
/// replacements are applied successfully, this returns the code with
/// replacements applied; otherwise, an llvm::Error carrying llvm::StringError
/// is returned (the Error message can be converted to string using
/// `llvm::toString()` and 'std::error_code` in the `Error` should be ignored).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_applyAllReplacements1_AddFunction
    handle.def("applyAllReplacements",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::Expected<std::basic_string<char>>(
                             llvm::StringRef,
                             const clang::tooling::Replacements &)>::type>(
                   &clang::tooling::applyAllReplacements),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_applyAllReplacements1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_applyAllReplacements1(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "applyAllReplacements1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_applyAllReplacements1

using Entity_applyAllReplacements1 = Bind_applyAllReplacements1<>;

#else

struct Entity_applyAllReplacements1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_applyAllReplacements1(EntityScope parent_h) {}
  static const char *Key() { return "applyAllReplacements1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_applyAllReplacements1

template <class Pybind11T = pybind11::module_ &>
struct Bind_applyAllReplacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Apply all replacements in \p Replaces to the Rewriter \p Rewrite.
///
/// Replacement applications happen independently of the success of
/// other applications.
///
/// \returns true if all replacements apply. false otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_applyAllReplacements_AddFunction
    handle.def("applyAllReplacements",
               static_cast<pybind11_weaver::FnPtrT<
                   void, bool(const clang::tooling::Replacements &,
                              clang::Rewriter &)>::type>(
                   &clang::tooling::applyAllReplacements),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_applyAllReplacements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_applyAllReplacements(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "applyAllReplacements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_applyAllReplacements

using Entity_applyAllReplacements = Bind_applyAllReplacements<>;

#else

struct Entity_applyAllReplacements : public pybind11_weaver::DisabledEntity {
  explicit Entity_applyAllReplacements(EntityScope parent_h) {}
  static const char *Key() { return "applyAllReplacements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_applyAllReplacements

template <class Pybind11T = pybind11::module_ &>
struct Bind_applyAtomicChanges : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Applies all AtomicChanges in \p Changes to the \p Code.
///
/// This completely ignores the file path in each change and replaces them with
/// \p FilePath, i.e. callers are responsible for ensuring all changes are for
/// the same file.
///
/// \returns The changed code if all changes are applied successfully;
/// otherwise, an llvm::Error carrying llvm::StringError is returned (the Error
/// message can be converted to string with `llvm::toString()` and the
/// error_code should be ignored).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_applyAtomicChanges_AddFunction
    handle.def("applyAtomicChanges",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::Expected<std::basic_string<char>>(
                             llvm::StringRef, llvm::StringRef,
                             llvm::ArrayRef<clang::tooling::AtomicChange>,
                             const clang::tooling::ApplyChangesSpec &)>::type>(
                   &clang::tooling::applyAtomicChanges),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_applyAtomicChanges(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_applyAtomicChanges(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "applyAtomicChanges"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_applyAtomicChanges

using Entity_applyAtomicChanges = Bind_applyAtomicChanges<>;

#else

struct Entity_applyAtomicChanges : public pybind11_weaver::DisabledEntity {
  explicit Entity_applyAtomicChanges(EntityScope parent_h) {}
  static const char *Key() { return "applyAtomicChanges"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_applyAtomicChanges

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildASTFromCode : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds an AST for 'Code'.
///
/// \param Code C++ code.
/// \param FileName The file name which 'Code' will be mapped as.
/// \param PCHContainerOps The PCHContainerOperations for loading and creating
/// clang modules.
///
/// \return The resulting AST or null if an error occurred.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_buildASTFromCode_AddFunction
#ifndef PB11_WEAVER_DISABLE_buildASTFromCode_AddFunction
    handle.def("buildASTFromCode", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildASTFromCode(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildASTFromCode(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildASTFromCode"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildASTFromCode

using Entity_buildASTFromCode = Bind_buildASTFromCode<>;

#else

struct Entity_buildASTFromCode : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildASTFromCode(EntityScope parent_h) {}
  static const char *Key() { return "buildASTFromCode"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildASTFromCode

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildASTFromCodeWithArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds an AST for 'Code' with additional flags.
///
/// \param Code C++ code.
/// \param Args Additional flags to pass on.
/// \param FileName The file name which 'Code' will be mapped as.
/// \param ToolName The name of the binary running the tool. Standard library
///                 header paths will be resolved relative to this.
/// \param PCHContainerOps The PCHContainerOperations for loading and creating
/// clang modules.
///
/// \param Adjuster A function to filter the command line arguments as specified.
///
/// \return The resulting AST or null if an error occurred.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_buildASTFromCodeWithArgs_AddFunction
#ifndef PB11_WEAVER_DISABLE_buildASTFromCodeWithArgs_AddFunction
    handle.def("buildASTFromCodeWithArgs", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildASTFromCodeWithArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildASTFromCodeWithArgs(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildASTFromCodeWithArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildASTFromCodeWithArgs

using Entity_buildASTFromCodeWithArgs = Bind_buildASTFromCodeWithArgs<>;

#else

struct Entity_buildASTFromCodeWithArgs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildASTFromCodeWithArgs(EntityScope parent_h) {}
  static const char *Key() { return "buildASTFromCodeWithArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildASTFromCodeWithArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildAccess : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of
/// implicit `this`) to the end of the given expression. Adds parentheses when
/// needed by the syntax and simplifies when possible. If `PLTypeClass` is
/// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),
/// treats `operator->` and `operator*` like the built-in `->` and `*`
/// operators.
///
///  `x` becomes `x->` or `x.`, depending on `E`'s type
///  `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type
///  `&a` becomes `a.`
///  `*a` becomes `a->`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildAccess_AddFunction
    handle.def("buildAccess",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::optional<std::basic_string<char>>(
                             const clang::Expr &, clang::ASTContext &,
                             clang::tooling::PLTClass)>::type>(
                   &clang::tooling::buildAccess),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildAccess(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildAccess(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildAccess"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildAccess

using Entity_buildAccess = Bind_buildAccess<>;

#else

struct Entity_buildAccess : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildAccess(EntityScope parent_h) {}
  static const char *Key() { return "buildAccess"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildAccess

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildAddressOf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds idiomatic source for taking the address of `E`: prefix with `&` but
/// simplify when it already begins with `*`.  \returns empty string on failure.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildAddressOf_AddFunction
    handle.def(
        "buildAddressOf",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<std::basic_string<char>>(
                      const clang::Expr &, const clang::ASTContext &)>::type>(
            &clang::tooling::buildAddressOf),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildAddressOf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildAddressOf(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildAddressOf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildAddressOf

using Entity_buildAddressOf = Bind_buildAddressOf<>;

#else

struct Entity_buildAddressOf : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildAddressOf(EntityScope parent_h) {}
  static const char *Key() { return "buildAddressOf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildAddressOf

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildArrow : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds an arrow to the end of the given expression, but adds parentheses
/// when needed by the syntax, and simplifies to `.` when possible, e.g.:
///
///  `x` becomes `x->`
///  `&a` becomes `a.`
///  `a+b` becomes `(a+b)->`
///
/// DEPRECATED. Use `buildAccess`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildArrow_AddFunction
    handle.def(
        "buildArrow",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<std::basic_string<char>>(
                      const clang::Expr &, const clang::ASTContext &)>::type>(
            &clang::tooling::buildArrow),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildArrow(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildArrow(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildArrow"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildArrow

using Entity_buildArrow = Bind_buildArrow<>;

#else

struct Entity_buildArrow : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildArrow(EntityScope parent_h) {}
  static const char *Key() { return "buildArrow"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildArrow

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildDereference : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds idiomatic source for the dereferencing of `E`: prefix with `*` but
/// simplify when it already begins with `&`.  \returns empty string on failure.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildDereference_AddFunction
    handle.def(
        "buildDereference",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<std::basic_string<char>>(
                      const clang::Expr &, const clang::ASTContext &)>::type>(
            &clang::tooling::buildDereference),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildDereference(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildDereference(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildDereference"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildDereference

using Entity_buildDereference = Bind_buildDereference<>;

#else

struct Entity_buildDereference : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildDereference(EntityScope parent_h) {}
  static const char *Key() { return "buildDereference"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildDereference

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildDot : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds a dot to the end of the given expression, but adds parentheses when
/// needed by the syntax, and simplifies to `->` when possible, e.g.:
///
///  `x` becomes `x.`
///  `*a` becomes `a->`
///  `a+b` becomes `(a+b).`
///
/// DEPRECATED. Use `buildAccess`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildDot_AddFunction
    handle.def(
        "buildDot",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<std::basic_string<char>>(
                      const clang::Expr &, const clang::ASTContext &)>::type>(
            &clang::tooling::buildDot),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildDot(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildDot(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildDot"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildDot

using Entity_buildDot = Bind_buildDot<>;

#else

struct Entity_buildDot : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildDot(EntityScope parent_h) {}
  static const char *Key() { return "buildDot"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildDot

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildParens : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds source for an expression, adding parens if needed for unambiguous
/// parsing.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildParens_AddFunction
    handle.def(
        "buildParens",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<std::basic_string<char>>(
                      const clang::Expr &, const clang::ASTContext &)>::type>(
            &clang::tooling::buildParens),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildParens(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildParens(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildParens"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildParens

using Entity_buildParens = Bind_buildParens<>;

#else

struct Entity_buildParens : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildParens(EntityScope parent_h) {}
  static const char *Key() { return "buildParens"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildParens

template <class Pybind11T = pybind11::module_ &>
struct Bind_calculateRangesAfterReplacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Calculates the new ranges after \p Replaces are applied. These
/// include both the original \p Ranges and the affected ranges of \p Replaces
/// in the new code.
///
/// \pre Replacements must be for the same file.
///
/// \return The new ranges after \p Replaces are applied. The new ranges will be
/// sorted and non-overlapping.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_calculateRangesAfterReplacements_AddFunction
    handle.def(
        "calculateRangesAfterReplacements",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::vector<clang::tooling::Range>(
                      const clang::tooling::Replacements &,
                      const std::vector<clang::tooling::Range> &)>::type>(
            &clang::tooling::calculateRangesAfterReplacements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_calculateRangesAfterReplacements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_calculateRangesAfterReplacements(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "calculateRangesAfterReplacements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_calculateRangesAfterReplacements

using Entity_calculateRangesAfterReplacements =
    Bind_calculateRangesAfterReplacements<>;

#else

struct Entity_calculateRangesAfterReplacements
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_calculateRangesAfterReplacements(EntityScope parent_h) {}
  static const char *Key() { return "calculateRangesAfterReplacements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_calculateRangesAfterReplacements

template <class Pybind11T = pybind11::module_ &>
struct Bind_codeContainsImports : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// This scans the given source code to see if it contains #import(s).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_codeContainsImports_AddFunction
    handle.def(
        "codeContainsImports",
        static_cast<pybind11_weaver::FnPtrT<void, bool(llvm::StringRef)>::type>(
            &clang::tooling::codeContainsImports),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_codeContainsImports(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_codeContainsImports(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "codeContainsImports"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_codeContainsImports

using Entity_codeContainsImports = Bind_codeContainsImports<>;

#else

struct Entity_codeContainsImports : public pybind11_weaver::DisabledEntity {
  explicit Entity_codeContainsImports(EntityScope parent_h) {}
  static const char *Key() { return "codeContainsImports"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_codeContainsImports

template <class Pybind11T = pybind11::module_ &>
struct Bind_combineAdjusters : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster which adjusts the arguments in sequence
/// with the \p First adjuster and then with the \p Second one.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_combineAdjusters_AddFunction
    handle.def(
        "combineAdjusters",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<std::vector<std::basic_string<char>>(
                const std::vector<std::basic_string<char>> &, llvm::StringRef)>(
                std::function<std::vector<std::basic_string<char>>(
                    const std::vector<std::basic_string<char>> &,
                    llvm::StringRef)>,
                std::function<std::vector<std::basic_string<char>>(
                    const std::vector<std::basic_string<char>> &,
                    llvm::StringRef)>)>::type>(
            &clang::tooling::combineAdjusters),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_combineAdjusters(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_combineAdjusters(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "combineAdjusters"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_combineAdjusters

using Entity_combineAdjusters = Bind_combineAdjusters<>;

#else

struct Entity_combineAdjusters : public pybind11_weaver::DisabledEntity {
  explicit Entity_combineAdjusters(EntityScope parent_h) {}
  static const char *Key() { return "combineAdjusters"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_combineAdjusters

template <class Pybind11T = pybind11::module_ &>
struct Bind_createExecutorFromCommandLineArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// This creates a ToolExecutor that is in the global registry based on
/// commandline arguments.
///
/// This picks the right executor based on the `--executor` option. This parses
/// the commandline arguments with `CommonOptionsParser`, so caller does not
/// need to parse again.
///
/// By default, this creates a `StandaloneToolExecutor` ("standalone") if
/// `--executor` is not provided.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_createExecutorFromCommandLineArgs_AddFunction
#ifndef PB11_WEAVER_DISABLE_createExecutorFromCommandLineArgs_AddFunction
    handle.def("createExecutorFromCommandLineArgs", None,
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createExecutorFromCommandLineArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createExecutorFromCommandLineArgs(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createExecutorFromCommandLineArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createExecutorFromCommandLineArgs

using Entity_createExecutorFromCommandLineArgs =
    Bind_createExecutorFromCommandLineArgs<>;

#else

struct Entity_createExecutorFromCommandLineArgs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_createExecutorFromCommandLineArgs(EntityScope parent_h) {}
  static const char *Key() { return "createExecutorFromCommandLineArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createExecutorFromCommandLineArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_createRefactoringActions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the list of all the available refactoring actions.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_createRefactoringActions_AddFunction
#ifndef PB11_WEAVER_DISABLE_createRefactoringActions_AddFunction
    handle.def("createRefactoringActions", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createRefactoringActions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createRefactoringActions(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createRefactoringActions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createRefactoringActions

using Entity_createRefactoringActions = Bind_createRefactoringActions<>;

#else

struct Entity_createRefactoringActions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_createRefactoringActions(EntityScope parent_h) {}
  static const char *Key() { return "createRefactoringActions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createRefactoringActions

template <class Pybind11T = pybind11::module_ &>
struct Bind_createRenameAtomicChanges : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Create atomic changes for renaming all symbol references which are
/// identified by the USRs set to a given new name.
///
/// \param USRs The set containing USRs of a particular old symbol.
/// \param NewName The new name to replace old symbol name.
/// \param TranslationUnitDecl The translation unit declaration.
///
/// \return Atomic changes for renaming.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_createRenameAtomicChanges_AddFunction
    handle.def(
        "createRenameAtomicChanges",
        [](llvm::ArrayRef<std::basic_string<char>> USRs,
           llvm::StringRef NewName,
           pybind11_weaver::WrappedPtrT<clang::Decl *> TranslationUnitDecl) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, std::vector<clang::tooling::AtomicChange>(
                            llvm::ArrayRef<std::basic_string<char>>,
                            llvm::StringRef, clang::Decl *)>::type>(
                  &clang::tooling::createRenameAtomicChanges),
              USRs, NewName, (TranslationUnitDecl)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createRenameAtomicChanges(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createRenameAtomicChanges(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createRenameAtomicChanges"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createRenameAtomicChanges

using Entity_createRenameAtomicChanges = Bind_createRenameAtomicChanges<>;

#else

struct Entity_createRenameAtomicChanges
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_createRenameAtomicChanges(EntityScope parent_h) {}
  static const char *Key() { return "createRenameAtomicChanges"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createRenameAtomicChanges

template <class Pybind11T = pybind11::module_ &>
struct Bind_createRenameReplacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns source replacements that correspond to the rename of the given
/// symbol occurrences.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_createRenameReplacements_AddFunction
    handle.def(
        "createRenameReplacements",
        static_cast<pybind11_weaver::FnPtrT<
            void, llvm::Expected<std::vector<clang::tooling::AtomicChange>>(
                      const std::vector<clang::tooling::SymbolOccurrence> &,
                      const clang::SourceManager &,
                      const clang::tooling::SymbolName &)>::type>(
            &clang::tooling::createRenameReplacements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createRenameReplacements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createRenameReplacements(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createRenameReplacements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createRenameReplacements

using Entity_createRenameReplacements = Bind_createRenameReplacements<>;

#else

struct Entity_createRenameReplacements
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_createRenameReplacements(EntityScope parent_h) {}
  static const char *Key() { return "createRenameReplacements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createRenameReplacements

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_dependencies : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "dependencies")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies

using Entity_clang_tooling_dependencies = Bind_clang_tooling_dependencies<>;

#else

struct Entity_clang_tooling_dependencies
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::CachedFileContents>>
struct Bind_clang_tooling_dependencies_CachedFileContents : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Contents and directive tokens of a cached file entry. Single instance can
/// be shared between multiple entries.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileContents_Ctor0
#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileContents_Ctor0
    handle.def(pybind11::init<std::unique_ptr<llvm::MemoryBuffer>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_CachedFileContents(
      EntityScope parent_h)
      : handle{
            parent_h, "CachedFileContents", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Contents and directive tokens of a cached file entry. Single instance can
/// be shared between multiple entries.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_CachedFileContents(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddCtor0(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_CachedFileContents";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_CachedFileContents

using Entity_clang_tooling_dependencies_CachedFileContents =
    Bind_clang_tooling_dependencies_CachedFileContents<>;

#else

struct Entity_clang_tooling_dependencies_CachedFileContents
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_CachedFileContents(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_CachedFileContents";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_CachedFileContents

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::CachedFileSystemEntry>>
struct Bind_clang_tooling_dependencies_CachedFileSystemEntry
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_isError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns True if the entry is a filesystem error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_isError
    handle.def(
        "isError",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            bool>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::isError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isDirectory() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns True if the current entry represents a directory.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_isDirectory
    handle.def(
        "isDirectory",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            bool>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::isDirectory),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOriginalContents() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns Original contents of the file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_getOriginalContents
    handle.def("getOriginalContents",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::CachedFileSystemEntry,
                   llvm::StringRef>::const_type>(
                   &clang::tooling::dependencies::CachedFileSystemEntry::
                       getOriginalContents),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDirectiveTokens() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns The scanned preprocessor directive tokens of the file that are
  /// used to speed up preprocessing, if available.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_getDirectiveTokens
    handle.def(
        "getDirectiveTokens",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            std::optional<llvm::ArrayRef<
                clang::dependency_directives_scan::Directive>>>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::
                getDirectiveTokens),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns The error.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_getError
    handle.def(
        "getError",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            std::error_code>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::getError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getStatus() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns The entry status with empty filename.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_getStatus
    handle.def(
        "getStatus",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            llvm::vfs::Status>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::getStatus),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getUniqueID() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns The unique ID of the entry.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_getUniqueID
    handle.def(
        "getUniqueID",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            llvm::sys::fs::UniqueID>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::getUniqueID),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCachedContents() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns The data structure holding both contents and directive tokens.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_getCachedContents
    handle.def(
        "getCachedContents",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::CachedFileSystemEntry,
            clang::tooling::dependencies::CachedFileContents *>::const_type>(
            &clang::tooling::dependencies::CachedFileSystemEntry::
                getCachedContents),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An in-memory representation of a file system entity that is of interest to
/// the dependency scanning filesystem.
///
/// It represents one of the following:
/// - opened file with contents and a stat value,
/// - opened file with contents, directive tokens and a stat value,
/// - directory entry with its stat value,
/// - filesystem error.
///
/// Single instance of this class can be shared across different filenames (e.g.
/// a regular file and a symlink). For this reason the status filename is empty
/// and is only materialized by \c EntryRef that knows the requested filename.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_Ctor0
    handle.def(pybind11::init<llvm::ErrorOr<llvm::vfs::Status>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An in-memory representation of a file system entity that is of interest to
/// the dependency scanning filesystem.
///
/// It represents one of the following:
/// - opened file with contents and a stat value,
/// - opened file with contents, directive tokens and a stat value,
/// - directory entry with its stat value,
/// - filesystem error.
///
/// Single instance of this class can be shared across different filenames (e.g.
/// a regular file and a symlink). For this reason the status filename is empty
/// and is only materialized by \c EntryRef that knows the requested filename.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CachedFileSystemEntry_Ctor1
    handle.def(
        pybind11::init<llvm::ErrorOr<llvm::vfs::Status>,
                       clang::tooling::dependencies::CachedFileContents *>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_CachedFileSystemEntry(
      EntityScope parent_h)
      : handle{parent_h, "CachedFileSystemEntry", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// An in-memory representation of a file system entity that is of interest to
/// the dependency scanning filesystem.
///
/// It represents one of the following:
/// - opened file with contents and a stat value,
/// - opened file with contents, directive tokens and a stat value,
/// - directory entry with its stat value,
/// - filesystem error.
///
/// Single instance of this class can be shared across different filenames (e.g.
/// a regular file and a symlink). For this reason the status filename is empty
/// and is only materialized by \c EntryRef that knows the requested filename.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_CachedFileSystemEntry(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_isError();
    AddMethod_isDirectory();
    AddMethod_getOriginalContents();
    AddMethod_getDirectiveTokens();
    AddMethod_getError();
    AddMethod_getStatus();
    AddMethod_getUniqueID();
    AddMethod_getCachedContents();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_CachedFileSystemEntry";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_CachedFileSystemEntry

using Entity_clang_tooling_dependencies_CachedFileSystemEntry =
    Bind_clang_tooling_dependencies_CachedFileSystemEntry<>;

#else

struct Entity_clang_tooling_dependencies_CachedFileSystemEntry
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_CachedFileSystemEntry(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_CachedFileSystemEntry";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_CachedFileSystemEntry

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::Command>>
struct Bind_clang_tooling_dependencies_Command : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_Command(EntityScope parent_h)
      : handle{
            parent_h, "Command", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A command-line tool invocation that is part of building a TU.
///
/// \see TranslationUnitDeps::Commands.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_Command(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::dependencies::Command>(
        handle);
    handle.def_readwrite("Executable",
                         &clang::tooling::dependencies::Command::Executable);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies_Command"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_Command

using Entity_clang_tooling_dependencies_Command =
    Bind_clang_tooling_dependencies_Command<>;

#else

struct Entity_clang_tooling_dependencies_Command
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_Command(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies_Command"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_Command

template <class = void>
class PyTrampDependencyActionController
    : public clang::tooling::dependencies::DependencyActionController {
public:
  using _PB11_WR_BaseT =
      clang::tooling::dependencies::DependencyActionController;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyActionControllerstd_string_9const_ModuleID____ModuleOutputKind_
  std::basic_string<char> lookupModuleOutput(
      const clang::tooling::dependencies::ModuleID &ID,
      clang::tooling::dependencies::ModuleOutputKind Kind) override {
    using _PB11_WR_RET_TYPE = std::basic_string<char>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyActionController;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           lookupModuleOutput, ID, Kind);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyActionControllerstd_string_9const_ModuleID____ModuleOutputKind_
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::DependencyActionController,
              PyTrampDependencyActionController<>>>
struct Bind_clang_tooling_dependencies_DependencyActionController
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_lookupModuleOutput() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyActionController_lookupModuleOutput
    handle.def("lookupModuleOutput",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyActionController,
                   std::basic_string<char>,
                   const clang::tooling::dependencies::ModuleID &,
                   clang::tooling::dependencies::ModuleOutputKind>::type>(
                   &clang::tooling::dependencies::DependencyActionController::
                       lookupModuleOutput));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyActionController(
      EntityScope parent_h)
      : handle{parent_h, "DependencyActionController", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Dependency scanner callbacks that are used during scanning to influence the
/// behaviour of the scan - for example, to customize the scanned invocations.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyActionController(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_lookupModuleOutput();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::DependencyActionController>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyActionController";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyActionController

using Entity_clang_tooling_dependencies_DependencyActionController =
    Bind_clang_tooling_dependencies_DependencyActionController<>;

#else

struct Entity_clang_tooling_dependencies_DependencyActionController
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyActionController(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyActionController";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyActionController

template <class = void>
class PyTrampDependencyConsumer
    : public clang::tooling::dependencies::DependencyConsumer {
public:
  using _PB11_WR_BaseT = clang::tooling::dependencies::DependencyConsumer;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9std_optional6P1689ModuleInfo9__std_vector6P1689ModuleInfo9_
  void handleProvidedAndRequiredStdCXXModules(
      std::optional<clang::tooling::dependencies::P1689ModuleInfo> Provided,
      std::vector<clang::tooling::dependencies::P1689ModuleInfo> Requires)
      override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleProvidedAndRequiredStdCXXModules, Provided,
                      Requires);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9std_optional6P1689ModuleInfo9__std_vector6P1689ModuleInfo9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9Command_
  void handleBuildCommand(clang::tooling::dependencies::Command Cmd) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleBuildCommand, Cmd);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9Command_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9const_DependencyOutputOptions___
  void handleDependencyOutputOpts(
      const clang::DependencyOutputOptions &Opts) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           handleDependencyOutputOpts, Opts);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9const_DependencyOutputOptions___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9StringRef_
  void handleFileDependency(llvm::StringRef Filename) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           handleFileDependency, Filename);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9StringRef_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9PrebuiltModuleDep_
  void handlePrebuiltModuleDependency(
      clang::tooling::dependencies::PrebuiltModuleDep PMD) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           handlePrebuiltModuleDependency, PMD);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9PrebuiltModuleDep_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9ModuleDeps_
  void
  handleModuleDependency(clang::tooling::dependencies::ModuleDeps MD) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           handleModuleDependency, MD);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9ModuleDeps_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9std_string_
  void handleContextHash(std::basic_string<char> Hash) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyConsumer;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           handleContextHash, Hash);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyConsumervoid_9std_string_
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::DependencyConsumer,
                               PyTrampDependencyConsumer<>>>
struct Bind_clang_tooling_dependencies_DependencyConsumer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_handleProvidedAndRequiredStdCXXModules() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handleProvidedAndRequiredStdCXXModules
    handle.def(
        "handleProvidedAndRequiredStdCXXModules",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyConsumer, void,
            std::optional<clang::tooling::dependencies::P1689ModuleInfo>,
            std::vector<clang::tooling::dependencies::P1689ModuleInfo>>::type>(
            &clang::tooling::dependencies::DependencyConsumer::
                handleProvidedAndRequiredStdCXXModules));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleBuildCommand() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handleBuildCommand
    handle.def("handleBuildCommand",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyConsumer, void,
                   clang::tooling::dependencies::Command>::type>(
                   &clang::tooling::dependencies::DependencyConsumer::
                       handleBuildCommand));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleDependencyOutputOpts() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handleDependencyOutputOpts
    handle.def("handleDependencyOutputOpts",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyConsumer, void,
                   const clang::DependencyOutputOptions &>::type>(
                   &clang::tooling::dependencies::DependencyConsumer::
                       handleDependencyOutputOpts));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleFileDependency() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handleFileDependency
    handle.def("handleFileDependency",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyConsumer, void,
                   llvm::StringRef>::type>(
                   &clang::tooling::dependencies::DependencyConsumer::
                       handleFileDependency));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handlePrebuiltModuleDependency() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handlePrebuiltModuleDependency
    handle.def("handlePrebuiltModuleDependency",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyConsumer, void,
                   clang::tooling::dependencies::PrebuiltModuleDep>::type>(
                   &clang::tooling::dependencies::DependencyConsumer::
                       handlePrebuiltModuleDependency));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleModuleDependency() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handleModuleDependency
    handle.def("handleModuleDependency",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyConsumer, void,
                   clang::tooling::dependencies::ModuleDeps>::type>(
                   &clang::tooling::dependencies::DependencyConsumer::
                       handleModuleDependency));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleContextHash() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyConsumer_handleContextHash
    handle.def("handleContextHash",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyConsumer, void,
                   std::basic_string<char>>::type>(
                   &clang::tooling::dependencies::DependencyConsumer::
                       handleContextHash));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyConsumer(
      EntityScope parent_h)
      : handle{parent_h, "DependencyConsumer", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyConsumer(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_handleProvidedAndRequiredStdCXXModules();
    AddMethod_handleBuildCommand();
    AddMethod_handleDependencyOutputOpts();
    AddMethod_handleFileDependency();
    AddMethod_handlePrebuiltModuleDependency();
    AddMethod_handleModuleDependency();
    AddMethod_handleContextHash();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::DependencyConsumer>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyConsumer";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyConsumer

using Entity_clang_tooling_dependencies_DependencyConsumer =
    Bind_clang_tooling_dependencies_DependencyConsumer<>;

#else

struct Entity_clang_tooling_dependencies_DependencyConsumer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyConsumer(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyConsumer";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyConsumer

template <
    class Pybind11T = pybind11::class_<
        clang::tooling::dependencies::DependencyScanningFilesystemLocalCache>>
struct Bind_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_findEntryByFilename() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry associated with the filename or nullptr if none is found.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache_findEntryByFilename
    handle.def(
        "findEntryByFilename",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::
                DependencyScanningFilesystemLocalCache,
            const clang::tooling::dependencies::CachedFileSystemEntry *,
            llvm::StringRef>::const_type>(
            &clang::tooling::dependencies::
                DependencyScanningFilesystemLocalCache::findEntryByFilename),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_insertEntryForFilename() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Associates the given entry with the filename and returns the given entry
  /// pointer (for convenience).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache_insertEntryForFilename
    handle.def(
        "insertEntryForFilename",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::
                DependencyScanningFilesystemLocalCache,
            const clang::tooling::dependencies::CachedFileSystemEntry &,
            llvm::StringRef,
            const clang::tooling::dependencies::CachedFileSystemEntry &>::type>(
            &clang::tooling::dependencies::
                DependencyScanningFilesystemLocalCache::insertEntryForFilename),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache(
      EntityScope parent_h)
      : handle{
            parent_h, "DependencyScanningFilesystemLocalCache",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// This class is a local cache, that caches the 'stat' and 'open' calls to the
/// underlying real file system.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_findEntryByFilename();
    AddMethod_insertEntryForFilename();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::DependencyScanningFilesystemLocalCache>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningFilesystemLocalCache";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache

using Entity_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache =
    Bind_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache<>;

#else

struct Entity_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningFilesystemLocalCache";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache

template <
    class Pybind11T = pybind11::class_<
        clang::tooling::dependencies::DependencyScanningFilesystemSharedCache>>
struct Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getShardForFilename() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns shard for the given key.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_getShardForFilename
    handle.def(
        "getShardForFilename",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache,
            clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache::CacheShard &,
            llvm::StringRef>::const_type>(
            &clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache::getShardForFilename),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getShardForUID() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_getShardForUID
    handle.def(
        "getShardForUID",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache,
            clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache::CacheShard &,
            llvm::sys::fs::UniqueID>::const_type>(
            &clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache::getShardForUID));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// This class is a shared cache, that caches the 'stat' and 'open' calls to the
/// underlying real file system, and the scanned preprocessor directives of
/// files.
///
/// It is sharded based on the hash of the key to reduce the lock contention for
/// the worker threads.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache(
      EntityScope parent_h)
      : handle{
            parent_h, "DependencyScanningFilesystemSharedCache",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// This class is a shared cache, that caches the 'stat' and 'open' calls to the
/// underlying real file system, and the scanned preprocessor directives of
/// files.
///
/// It is sharded based on the hash of the key to reduce the lock contention for
/// the worker threads.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getShardForFilename();
    AddMethod_getShardForUID();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningFilesystemSharedCache";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache

using Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache =
    Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache<>;

#else

struct Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningFilesystemSharedCache";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::
                  DependencyScanningFilesystemSharedCache::CacheShard>>
struct
    Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_findEntryByFilename() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry associated with the filename or nullptr if none is found.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard_findEntryByFilename
    handle.def("findEntryByFilename",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache::CacheShard,
                   const clang::tooling::dependencies::CachedFileSystemEntry *,
                   llvm::StringRef>::const_type>(
                   &clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache::CacheShard::
                           findEntryByFilename),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_findEntryByUID() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry associated with the unique ID or nullptr if none is found.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard_findEntryByUID
    handle.def("findEntryByUID",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache::CacheShard,
                   const clang::tooling::dependencies::CachedFileSystemEntry *,
                   llvm::sys::fs::UniqueID>::const_type>(
                   &clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache::CacheShard::
                           findEntryByUID),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOrEmplaceEntryForFilename() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry associated with the filename if there is some. Otherwise,
    /// constructs new one with the given status, associates it with the
    /// filename and returns the result.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard_getOrEmplaceEntryForFilename
    handle.def("getOrEmplaceEntryForFilename",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache::CacheShard,
                   const clang::tooling::dependencies::CachedFileSystemEntry &,
                   llvm::StringRef, llvm::ErrorOr<llvm::vfs::Status>>::type>(
                   &clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache::CacheShard::
                           getOrEmplaceEntryForFilename),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOrEmplaceEntryForUID() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry associated with the unique ID if there is some. Otherwise,
    /// constructs new one with the given status and contents, associates it
    /// with the unique ID and returns the result.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard_getOrEmplaceEntryForUID
#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard_getOrEmplaceEntryForUID
    handle.def("getOrEmplaceEntryForUID", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOrInsertEntryForFilename() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry associated with the filename if there is some. Otherwise,
    /// associates the given entry with the filename and returns it.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard_getOrInsertEntryForFilename
    handle.def(
        "getOrInsertEntryForFilename",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache::CacheShard,
            const clang::tooling::dependencies::CachedFileSystemEntry &,
            llvm::StringRef,
            const clang::tooling::dependencies::CachedFileSystemEntry &>::type>(
            &clang::tooling::dependencies::
                DependencyScanningFilesystemSharedCache::CacheShard::
                    getOrInsertEntryForFilename),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard(
      EntityScope parent_h)
      : handle{parent_h, "CacheShard", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_findEntryByFilename();
    AddMethod_findEntryByUID();
    AddMethod_getOrEmplaceEntryForFilename();
    AddMethod_getOrEmplaceEntryForUID();
    AddMethod_getOrInsertEntryForFilename();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::DependencyScanningFilesystemSharedCache::
            CacheShard>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_"
           "CacheShard";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard

using Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard =
    Bind_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard<>;

#else

struct
    Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_"
           "CacheShard";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::DependencyScanningService>>
struct Bind_clang_tooling_dependencies_DependencyScanningService
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getMode() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningService_getMode
    handle.def(
        "getMode",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningService,
            clang::tooling::dependencies::ScanningMode>::const_type>(
            &clang::tooling::dependencies::DependencyScanningService::getMode));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFormat() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningService_getFormat
    handle.def(
        "getFormat",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningService,
            clang::tooling::dependencies::ScanningOutputFormat>::const_type>(
            &clang::tooling::dependencies::DependencyScanningService::
                getFormat));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_canOptimizeArgs() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningService_canOptimizeArgs
    handle.def(
        "canOptimizeArgs",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningService,
            bool>::const_type>(&clang::tooling::dependencies::
                                   DependencyScanningService::canOptimizeArgs));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_shouldEagerLoadModules() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningService_shouldEagerLoadModules
    handle.def("shouldEagerLoadModules",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyScanningService,
                   bool>::const_type>(
                   &clang::tooling::dependencies::DependencyScanningService::
                       shouldEagerLoadModules));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSharedCache() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningService_getSharedCache
    handle.def("getSharedCache",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyScanningService,
                   clang::tooling::dependencies::
                       DependencyScanningFilesystemSharedCache &>::type>(
                   &clang::tooling::dependencies::DependencyScanningService::
                       getSharedCache));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The dependency scanning service contains shared configuration and state that
/// is used by the individual dependency scanning workers.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningService_Ctor0
    handle.def(
        pybind11::init<clang::tooling::dependencies::ScanningMode,
                       clang::tooling::dependencies::ScanningOutputFormat, bool,
                       bool>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningService(
      EntityScope parent_h)
      : handle{
            parent_h, "DependencyScanningService", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// The dependency scanning service contains shared configuration and state that
/// is used by the individual dependency scanning workers.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningService(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getMode();
    AddMethod_getFormat();
    AddMethod_canOptimizeArgs();
    AddMethod_shouldEagerLoadModules();
    AddMethod_getSharedCache();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningService";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningService

using Entity_clang_tooling_dependencies_DependencyScanningService =
    Bind_clang_tooling_dependencies_DependencyScanningService<>;

#else

struct Entity_clang_tooling_dependencies_DependencyScanningService
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningService(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningService";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningService

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::DependencyScanningTool>>
struct Bind_clang_tooling_dependencies_DependencyScanningTool
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getDependencyFile() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Print out the dependency information into a string using the dependency
  /// file format that is specified in the options (-MD is the default) and
  /// return it.
  ///
  /// \returns A \c StringError with the diagnostic output if clang errors
  /// occurred, dependency file contents otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningTool_getDependencyFile
    handle.def("getDependencyFile",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyScanningTool,
                   llvm::Expected<std::basic_string<char>>,
                   const std::vector<std::basic_string<char>> &,
                   llvm::StringRef>::type>(
                   &clang::tooling::dependencies::DependencyScanningTool::
                       getDependencyFile),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getP1689ModuleDependencyFile() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Collect the module dependency in P1689 format for C++20 named modules.
  ///
  /// \param MakeformatOutput The output parameter for dependency information
  /// in make format if the command line requires to generate make-format
  /// dependency information by `-MD -MF <dep_file>`.
  ///
  /// \param MakeformatOutputPath The output parameter for the path to
  /// \param MakeformatOutput.
  ///
  /// \returns A \c StringError with the diagnostic output if clang errors
  /// occurred, P1689 dependency format rules otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningTool_getP1689ModuleDependencyFile
    handle.def("getP1689ModuleDependencyFile",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyScanningTool,
                   llvm::Expected<clang::tooling::dependencies::P1689Rule>,
                   const clang::tooling::CompileCommand &, llvm::StringRef,
                   std::basic_string<char> &, std::basic_string<char> &>::type>(
                   &clang::tooling::dependencies::DependencyScanningTool::
                       getP1689ModuleDependencyFile),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTranslationUnitDependencies() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Given a Clang driver command-line for a translation unit, gather the
  /// modular dependencies and return the information needed for explicit build.
  ///
  /// \param AlreadySeen This stores modules which have previously been
  ///                    reported. Use the same instance for all calls to this
  ///                    function for a single \c DependencyScanningTool in a
  ///                    single build. Use a different one for different tools,
  ///                    and clear it between builds.
  /// \param LookupModuleOutput This function is called to fill in
  ///                           "-fmodule-file=", "-o" and other output
  ///                           arguments for dependencies.
  ///
  /// \returns a \c StringError with the diagnostic output if clang errors
  /// occurred, \c TranslationUnitDeps otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningTool_getTranslationUnitDependencies
    handle.def(
        "getTranslationUnitDependencies",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningTool,
            llvm::Expected<clang::tooling::dependencies::TranslationUnitDeps>,
            const std::vector<std::basic_string<char>> &, llvm::StringRef,
            const llvm::StringSet<> &,
            llvm::function_ref<std::basic_string<char>(
                const clang::tooling::dependencies::ModuleID &,
                clang::tooling::dependencies::ModuleOutputKind)>>::type>(
            &clang::tooling::dependencies::DependencyScanningTool::
                getTranslationUnitDependencies),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getModuleDependencies() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Given a compilation context specified via the Clang driver command-line,
  /// gather modular dependencies of module with the given name, and return the
  /// information needed for explicit build.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningTool_getModuleDependencies
    handle.def(
        "getModuleDependencies",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningTool,
            llvm::Expected<
                std::vector<clang::tooling::dependencies::ModuleDeps>>,
            llvm::StringRef, const std::vector<std::basic_string<char>> &,
            llvm::StringRef, const llvm::StringSet<> &,
            llvm::function_ref<std::basic_string<char>(
                const clang::tooling::dependencies::ModuleID &,
                clang::tooling::dependencies::ModuleOutputKind)>>::type>(
            &clang::tooling::dependencies::DependencyScanningTool::
                getModuleDependencies),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The high-level implementation of the dependency discovery tool that runs on
/// an individual worker thread.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningTool_Ctor0
    handle.def(pybind11::init<
                   clang::tooling::dependencies::DependencyScanningService &,
                   llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningTool(
      EntityScope parent_h)
      : handle{
            parent_h, "DependencyScanningTool", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// The high-level implementation of the dependency discovery tool that runs on
/// an individual worker thread.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningTool(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getDependencyFile();
    AddMethod_getP1689ModuleDependencyFile();
    AddMethod_getTranslationUnitDependencies();
    AddMethod_getModuleDependencies();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningTool";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningTool

using Entity_clang_tooling_dependencies_DependencyScanningTool =
    Bind_clang_tooling_dependencies_DependencyScanningTool<>;

#else

struct Entity_clang_tooling_dependencies_DependencyScanningTool
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningTool(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningTool";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningTool

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::DependencyScanningWorker>>
struct Bind_clang_tooling_dependencies_DependencyScanningWorker
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_computeDependencies() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Run the dependency scanning tool for a given clang driver command-line,
  /// and report the discovered dependencies to the provided consumer. If \p
  /// ModuleName isn't empty, this function reports the dependencies of module
  /// \p ModuleName.
  ///
  /// \returns false if clang errors occurred (with diagnostics reported to
  /// \c DiagConsumer), true otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorker_computeDependencies
    handle.def(
        "computeDependencies",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningWorker, bool,
            llvm::StringRef, const std::vector<std::basic_string<char>> &,
            clang::tooling::dependencies::DependencyConsumer &,
            clang::tooling::dependencies::DependencyActionController &,
            clang::DiagnosticConsumer &, std::optional<llvm::StringRef>>::type>(
            &clang::tooling::dependencies::DependencyScanningWorker::
                computeDependencies),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_computeDependencies1() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \returns A \c StringError with the diagnostic output if clang errors
  /// occurred, success otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorker_computeDependencies1
    handle.def(
        "computeDependencies",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningWorker, llvm::Error,
            llvm::StringRef, const std::vector<std::basic_string<char>> &,
            clang::tooling::dependencies::DependencyConsumer &,
            clang::tooling::dependencies::DependencyActionController &,
            std::optional<llvm::StringRef>>::type>(
            &clang::tooling::dependencies::DependencyScanningWorker::
                computeDependencies),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_shouldEagerLoadModules() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorker_shouldEagerLoadModules
    handle.def("shouldEagerLoadModules",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::DependencyScanningWorker,
                   bool>::const_type>(
                   &clang::tooling::dependencies::DependencyScanningWorker::
                       shouldEagerLoadModules));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An individual dependency scanning worker that is able to run on its own
/// thread.
///
/// The worker computes the dependencies for the input files by preprocessing
/// sources either using a fast mode where the source files are minimized, or
/// using the regular processing run.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorker_Ctor0
    handle.def(pybind11::init<
                   clang::tooling::dependencies::DependencyScanningService &,
                   llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningWorker(
      EntityScope parent_h)
      : handle{
            parent_h, "DependencyScanningWorker", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An individual dependency scanning worker that is able to run on its own
/// thread.
///
/// The worker computes the dependencies for the input files by preprocessing
/// sources either using a fast mode where the source files are minimized, or
/// using the regular processing run.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningWorker(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_computeDependencies();
    AddMethod_computeDependencies1();
    AddMethod_shouldEagerLoadModules();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningWorker";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningWorker

using Entity_clang_tooling_dependencies_DependencyScanningWorker =
    Bind_clang_tooling_dependencies_DependencyScanningWorker<>;

#else

struct Entity_clang_tooling_dependencies_DependencyScanningWorker
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningWorker(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningWorker";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningWorker

template <class = void>
class PyTrampDependencyScanningWorkerFilesystem2
    : public clang::tooling::dependencies::DependencyScanningWorkerFilesystem {
public:
  using _PB11_WR_BaseT =
      clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9SmallVectorImpl6char9____const
  std::error_code
  makeAbsolute(llvm::SmallVectorImpl<char> &Path) const override {
    using _PB11_WR_RET_TYPE = std::error_code;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, makeAbsolute,
                      Path);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9SmallVectorImpl6char9____const
};

template <class = void>
class PyTrampDependencyScanningWorkerFilesystem1
    : public PyTrampDependencyScanningWorkerFilesystem2<> {
public:
  using _PB11_WR_BaseT = PyTrampDependencyScanningWorkerFilesystem2<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemdirectory_iterator_9const_Twine____std_error_code___
  llvm::vfs::directory_iterator dir_begin(const llvm::Twine &Dir,
                                          std::error_code &EC) override {
    using _PB11_WR_RET_TYPE = llvm::vfs::directory_iterator;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, dir_begin,
                      Dir, EC);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemdirectory_iterator_9const_Twine____std_error_code___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemllvm_ErrorOr6std_string9_9__const
  llvm::ErrorOr<std::basic_string<char>>
  getCurrentWorkingDirectory() const override {
    using _PB11_WR_RET_TYPE = llvm::ErrorOr<std::basic_string<char>>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCurrentWorkingDirectory,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemllvm_ErrorOr6std_string9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9const_Twine____SmallVectorImpl6char9____const
  std::error_code
  getRealPath(const llvm::Twine &Path,
              llvm::SmallVectorImpl<char> &Output) const override {
    using _PB11_WR_RET_TYPE = std::error_code;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getRealPath,
                      Path, Output);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9const_Twine____SmallVectorImpl6char9____const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9const_Twine____bool___
  std::error_code isLocal(const llvm::Twine &Path, bool &Result) override {
    using _PB11_WR_RET_TYPE = std::error_code;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, isLocal, Path,
                      Result);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9const_Twine____bool___
};

template <class = void>
class PyTrampDependencyScanningWorkerFilesystem
    : public PyTrampDependencyScanningWorkerFilesystem1<> {
public:
  using _PB11_WR_BaseT = PyTrampDependencyScanningWorkerFilesystem1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemllvm_ErrorOr6llvm_vfs_Status9_9const_Twine___
  llvm::ErrorOr<llvm::vfs::Status> status(const llvm::Twine &Path) override {
    using _PB11_WR_RET_TYPE = llvm::ErrorOr<llvm::vfs::Status>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, status, Path);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemllvm_ErrorOr6llvm_vfs_Status9_9const_Twine___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemllvm_ErrorOr6std_unique_ptr6llvm_vfs_File99_9const_Twine___
  llvm::ErrorOr<std::unique_ptr<llvm::vfs::File>>
  openFileForRead(const llvm::Twine &Path) override {
    using _PB11_WR_RET_TYPE = llvm::ErrorOr<std::unique_ptr<llvm::vfs::File>>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      openFileForRead, Path);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemllvm_ErrorOr6std_unique_ptr6llvm_vfs_File99_9const_Twine___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9const_Twine___
  std::error_code setCurrentWorkingDirectory(const llvm::Twine &Path) override {
    using _PB11_WR_RET_TYPE = std::error_code;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::DependencyScanningWorkerFilesystem;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      setCurrentWorkingDirectory, Path);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_DependencyScanningWorkerFilesystemstd_error_code_9const_Twine___
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::DependencyScanningWorkerFilesystem,
              PyTrampDependencyScanningWorkerFilesystem<>>>
struct Bind_clang_tooling_dependencies_DependencyScanningWorkerFilesystem
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_status() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorkerFilesystem_status
    handle.def(
        "status",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningWorkerFilesystem,
            llvm::ErrorOr<llvm::vfs::Status>, const llvm::Twine &>::type>(
            &clang::tooling::dependencies::DependencyScanningWorkerFilesystem::
                status));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_openFileForRead() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorkerFilesystem_openFileForRead
#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorkerFilesystem_openFileForRead
    handle.def("openFileForRead", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setCurrentWorkingDirectory() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorkerFilesystem_setCurrentWorkingDirectory
    handle.def(
        "setCurrentWorkingDirectory",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningWorkerFilesystem,
            std::error_code, const llvm::Twine &>::type>(
            &clang::tooling::dependencies::DependencyScanningWorkerFilesystem::
                setCurrentWorkingDirectory));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getOrCreateFileSystemEntry() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns entry for the given filename.
  ///
  /// Attempts to use the local and shared caches first, then falls back to
  /// using the underlying filesystem.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorkerFilesystem_getOrCreateFileSystemEntry
    handle.def(
        "getOrCreateFileSystemEntry",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::DependencyScanningWorkerFilesystem,
            llvm::ErrorOr<clang::tooling::dependencies::EntryRef>,
            llvm::StringRef, bool>::type>(
            &clang::tooling::dependencies::DependencyScanningWorkerFilesystem::
                getOrCreateFileSystemEntry),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A virtual file system optimized for the dependency discovery.
///
/// It is primarily designed to work with source files whose contents was
/// preprocessed to remove any tokens that are unlikely to affect the dependency
/// computation.
///
/// This is not a thread safe VFS. A single instance is meant to be used only in
/// one thread. Multiple instances are allowed to service multiple threads
/// running in parallel.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_DependencyScanningWorkerFilesystem_Ctor0
    handle.def(
        pybind11::init<clang::tooling::dependencies::
                           DependencyScanningFilesystemSharedCache &,
                       llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_DependencyScanningWorkerFilesystem(
      EntityScope parent_h)
      : handle{
            parent_h, "DependencyScanningWorkerFilesystem",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A virtual file system optimized for the dependency discovery.
///
/// It is primarily designed to work with source files whose contents was
/// preprocessed to remove any tokens that are unlikely to affect the dependency
/// computation.
///
/// This is not a thread safe VFS. A single instance is meant to be used only in
/// one thread. Multiple instances are allowed to service multiple threads
/// running in parallel.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_DependencyScanningWorkerFilesystem(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_status();
    AddMethod_openFileForRead();
    AddMethod_setCurrentWorkingDirectory();
    AddMethod_getOrCreateFileSystemEntry();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningWorkerFilesystem";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningWorkerFilesystem

using Entity_clang_tooling_dependencies_DependencyScanningWorkerFilesystem =
    Bind_clang_tooling_dependencies_DependencyScanningWorkerFilesystem<>;

#else

struct Entity_clang_tooling_dependencies_DependencyScanningWorkerFilesystem
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_DependencyScanningWorkerFilesystem(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_DependencyScanningWorkerFilesystem";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_DependencyScanningWorkerFilesystem

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::EntryRef>>
struct Bind_clang_tooling_dependencies_EntryRef : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getStatus() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_getStatus
    handle.def(
        "getStatus",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::dependencies::EntryRef,
                                    llvm::vfs::Status>::const_type>(
            &clang::tooling::dependencies::EntryRef::getStatus));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isError() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_isError
    handle.def("isError",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::EntryRef, bool>::const_type>(
                   &clang::tooling::dependencies::EntryRef::isError));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isDirectory() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_isDirectory
    handle.def("isDirectory",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::EntryRef, bool>::const_type>(
                   &clang::tooling::dependencies::EntryRef::isDirectory));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_unwrapError() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If the cached entry represents an error, promotes it into `ErrorOr`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_unwrapError
    handle.def(
        "unwrapError",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::EntryRef,
            llvm::ErrorOr<clang::tooling::dependencies::EntryRef>>::const_type>(
            &clang::tooling::dependencies::EntryRef::unwrapError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getContents() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_getContents
    handle.def(
        "getContents",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::dependencies::EntryRef,
                                    llvm::StringRef>::const_type>(
            &clang::tooling::dependencies::EntryRef::getContents));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getDirectiveTokens() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_getDirectiveTokens
    handle.def(
        "getDirectiveTokens",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::EntryRef,
            std::optional<llvm::ArrayRef<
                clang::dependency_directives_scan::Directive>>>::const_type>(
            &clang::tooling::dependencies::EntryRef::getDirectiveTokens));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Reference to a CachedFileSystemEntry.
/// If the underlying entry is an opened file, this wrapper returns the file
/// contents and the scanned preprocessor directives.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_EntryRef_Ctor0
    handle.def(
        pybind11::init<
            llvm::StringRef,
            const clang::tooling::dependencies::CachedFileSystemEntry &>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_EntryRef(EntityScope parent_h)
      : handle{parent_h, "EntryRef", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Reference to a CachedFileSystemEntry.
/// If the underlying entry is an opened file, this wrapper returns the file
/// contents and the scanned preprocessor directives.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_EntryRef(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getStatus();
    AddMethod_isError();
    AddMethod_isDirectory();
    AddMethod_unwrapError();
    AddMethod_getContents();
    AddMethod_getDirectiveTokens();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies_EntryRef"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_EntryRef

using Entity_clang_tooling_dependencies_EntryRef =
    Bind_clang_tooling_dependencies_EntryRef<>;

#else

struct Entity_clang_tooling_dependencies_EntryRef
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_EntryRef(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies_EntryRef"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_EntryRef

template <class = void>
class PyTrampFullDependencyConsumer1
    : public clang::tooling::dependencies::FullDependencyConsumer {
public:
  using _PB11_WR_BaseT = clang::tooling::dependencies::FullDependencyConsumer;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9std_optional6P1689ModuleInfo9__std_vector6P1689ModuleInfo9_
  void handleProvidedAndRequiredStdCXXModules(
      std::optional<clang::tooling::dependencies::P1689ModuleInfo> Provided,
      std::vector<clang::tooling::dependencies::P1689ModuleInfo> Requires)
      override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleProvidedAndRequiredStdCXXModules, Provided,
                      Requires);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9std_optional6P1689ModuleInfo9__std_vector6P1689ModuleInfo9_
};

template <class = void>
class PyTrampFullDependencyConsumer : public PyTrampFullDependencyConsumer1<> {
public:
  using _PB11_WR_BaseT = PyTrampFullDependencyConsumer1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9Command_
  void handleBuildCommand(clang::tooling::dependencies::Command Cmd) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleBuildCommand, Cmd);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9Command_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9const_DependencyOutputOptions___
  void handleDependencyOutputOpts(
      const clang::DependencyOutputOptions &arg0) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleDependencyOutputOpts, arg0);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9const_DependencyOutputOptions___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9StringRef_
  void handleFileDependency(llvm::StringRef File) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleFileDependency, File);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9StringRef_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9PrebuiltModuleDep_
  void handlePrebuiltModuleDependency(
      clang::tooling::dependencies::PrebuiltModuleDep PMD) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handlePrebuiltModuleDependency, PMD);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9PrebuiltModuleDep_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9ModuleDeps_
  void
  handleModuleDependency(clang::tooling::dependencies::ModuleDeps MD) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleModuleDependency, MD);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9ModuleDeps_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9std_string_
  void handleContextHash(std::basic_string<char> Hash) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::FullDependencyConsumer;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      handleContextHash, Hash);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_FullDependencyConsumervoid_9std_string_
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::FullDependencyConsumer,
              PyTrampFullDependencyConsumer<>,
              clang::tooling::dependencies::DependencyConsumer>>
struct Bind_clang_tooling_dependencies_FullDependencyConsumer
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_handleBuildCommand() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_handleBuildCommand
    handle.def("handleBuildCommand",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer, void,
                   clang::tooling::dependencies::Command>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       handleBuildCommand));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleDependencyOutputOpts() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_handleDependencyOutputOpts
    handle.def("handleDependencyOutputOpts",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer, void,
                   const clang::DependencyOutputOptions &>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       handleDependencyOutputOpts));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleFileDependency() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_handleFileDependency
    handle.def("handleFileDependency",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer, void,
                   llvm::StringRef>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       handleFileDependency));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handlePrebuiltModuleDependency() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_handlePrebuiltModuleDependency
    handle.def("handlePrebuiltModuleDependency",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer, void,
                   clang::tooling::dependencies::PrebuiltModuleDep>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       handlePrebuiltModuleDependency));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleModuleDependency() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_handleModuleDependency
    handle.def("handleModuleDependency",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer, void,
                   clang::tooling::dependencies::ModuleDeps>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       handleModuleDependency));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_handleContextHash() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_handleContextHash
    handle.def("handleContextHash",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer, void,
                   std::basic_string<char>>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       handleContextHash));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_takeTranslationUnitDeps() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_takeTranslationUnitDeps
    handle.def("takeTranslationUnitDeps",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::FullDependencyConsumer,
                   clang::tooling::dependencies::TranslationUnitDeps>::type>(
                   &clang::tooling::dependencies::FullDependencyConsumer::
                       takeTranslationUnitDeps));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_takeModuleGraphDeps() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_takeModuleGraphDeps
    handle.def(
        "takeModuleGraphDeps",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::FullDependencyConsumer,
            std::vector<clang::tooling::dependencies::ModuleDeps>>::type>(
            &clang::tooling::dependencies::FullDependencyConsumer::
                takeModuleGraphDeps));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_FullDependencyConsumer_Ctor0
    handle.def(pybind11::init<const llvm::StringSet<> &>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_FullDependencyConsumer(
      EntityScope parent_h)
      : handle{parent_h, "FullDependencyConsumer", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_FullDependencyConsumer(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_handleBuildCommand();
    AddMethod_handleDependencyOutputOpts();
    AddMethod_handleFileDependency();
    AddMethod_handlePrebuiltModuleDependency();
    AddMethod_handleModuleDependency();
    AddMethod_handleContextHash();
    AddMethod_takeTranslationUnitDeps();
    AddMethod_takeModuleGraphDeps();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_FullDependencyConsumer";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_FullDependencyConsumer

using Entity_clang_tooling_dependencies_FullDependencyConsumer =
    Bind_clang_tooling_dependencies_FullDependencyConsumer<>;

#else

struct Entity_clang_tooling_dependencies_FullDependencyConsumer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_FullDependencyConsumer(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_FullDependencyConsumer";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_FullDependencyConsumer

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::ModuleDepCollector>>
struct Bind_clang_tooling_dependencies_ModuleDepCollector : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_attachToPreprocessor() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollector_attachToPreprocessor
    handle.def("attachToPreprocessor",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::ModuleDepCollector, void,
                   clang::Preprocessor &>::type>(
                   &clang::tooling::dependencies::ModuleDepCollector::
                       attachToPreprocessor));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_attachToASTReader() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollector_attachToASTReader
    handle.def("attachToASTReader",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::ModuleDepCollector, void,
                   clang::ASTReader &>::type>(
                   &clang::tooling::dependencies::ModuleDepCollector::
                       attachToASTReader));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_applyDiscoveredDependencies() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Apply any changes implied by the discovered dependencies to the given
  /// invocation, (e.g. disable implicit modules, add explicit module paths).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollector_applyDiscoveredDependencies
    handle.def("applyDiscoveredDependencies",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::ModuleDepCollector, void,
                   clang::CompilerInvocation &>::type>(
                   &clang::tooling::dependencies::ModuleDepCollector::
                       applyDiscoveredDependencies),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Collects modular and non-modular dependencies of the main file by attaching
/// \c ModuleDepCollectorPP to the preprocessor.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollector_Ctor0
#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollector_Ctor0
    handle.def(pybind11::init<
                   std::unique_ptr<clang::DependencyOutputOptions>,
                   clang::CompilerInstance &,
                   clang::tooling::dependencies::DependencyConsumer &,
                   clang::tooling::dependencies::DependencyActionController &,
                   clang::CompilerInvocation, bool, bool, bool>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_ModuleDepCollector(
      EntityScope parent_h)
      : handle{
            parent_h, "ModuleDepCollector", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Collects modular and non-modular dependencies of the main file by attaching
/// \c ModuleDepCollectorPP to the preprocessor.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ModuleDepCollector(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_attachToPreprocessor();
    AddMethod_attachToASTReader();
    AddMethod_applyDiscoveredDependencies();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_ModuleDepCollector";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleDepCollector

using Entity_clang_tooling_dependencies_ModuleDepCollector =
    Bind_clang_tooling_dependencies_ModuleDepCollector<>;

#else

struct Entity_clang_tooling_dependencies_ModuleDepCollector
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ModuleDepCollector(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_ModuleDepCollector";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleDepCollector

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::ModuleDepCollectorPP>>
struct Bind_clang_tooling_dependencies_ModuleDepCollectorPP
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_LexedFileChanged() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollectorPP_LexedFileChanged
    handle.def("LexedFileChanged",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::ModuleDepCollectorPP, void,
                   clang::FileID, clang::PPCallbacks::LexedFileChangeReason,
                   clang::SrcMgr::CharacteristicKind, clang::FileID,
                   clang::SourceLocation>::type>(
                   &clang::tooling::dependencies::ModuleDepCollectorPP::
                       LexedFileChanged));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_InclusionDirective() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollectorPP_InclusionDirective
    handle.def("InclusionDirective",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::ModuleDepCollectorPP, void,
                   clang::SourceLocation, const clang::Token &, llvm::StringRef,
                   bool, clang::CharSourceRange,
                   clang::CustomizableOptional<clang::FileEntryRef>,
                   llvm::StringRef, llvm::StringRef, const clang::Module *,
                   clang::SrcMgr::CharacteristicKind>::type>(
                   &clang::tooling::dependencies::ModuleDepCollectorPP::
                       InclusionDirective));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_moduleImport() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollectorPP_moduleImport
    handle.def(
        "moduleImport",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::ModuleDepCollectorPP, void,
            clang::SourceLocation,
            llvm::ArrayRef<
                std::pair<clang::IdentifierInfo *, clang::SourceLocation>>,
            const clang::Module *>::type>(
            &clang::tooling::dependencies::ModuleDepCollectorPP::moduleImport));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_EndOfMainFile() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollectorPP_EndOfMainFile
    handle.def(
        "EndOfMainFile",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::dependencies::ModuleDepCollectorPP, void>::type>(
            &clang::tooling::dependencies::ModuleDepCollectorPP::
                EndOfMainFile));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Callback that records textual includes and direct modular includes/imports
/// during preprocessing. At the end of the main file, it also collects
/// transitive modular dependencies and passes everything to the
/// \c DependencyConsumer of the parent \c ModuleDepCollector.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_ModuleDepCollectorPP_Ctor0
    handle.def(
        pybind11::init<clang::tooling::dependencies::ModuleDepCollector &>(),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_ModuleDepCollectorPP(
      EntityScope parent_h)
      : handle{
            parent_h, "ModuleDepCollectorPP", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Callback that records textual includes and direct modular includes/imports
/// during preprocessing. At the end of the main file, it also collects
/// transitive modular dependencies and passes everything to the
/// \c DependencyConsumer of the parent \c ModuleDepCollector.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ModuleDepCollectorPP(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_LexedFileChanged();
    AddMethod_InclusionDirective();
    AddMethod_moduleImport();
    AddMethod_EndOfMainFile();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_ModuleDepCollectorPP";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleDepCollectorPP

using Entity_clang_tooling_dependencies_ModuleDepCollectorPP =
    Bind_clang_tooling_dependencies_ModuleDepCollectorPP<>;

#else

struct Entity_clang_tooling_dependencies_ModuleDepCollectorPP
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ModuleDepCollectorPP(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_ModuleDepCollectorPP";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleDepCollectorPP

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::ModuleDeps>>
struct Bind_clang_tooling_dependencies_ModuleDeps : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_ModuleDeps(EntityScope parent_h)
      : handle{parent_h, "ModuleDeps", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ModuleDeps(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::ModuleDeps>(handle);
    handle.def_readwrite(
        "IsSystem", &clang::tooling::dependencies::ModuleDeps::IsSystem,
        R"_pb11_weaver(/// Whether this is a "system" module.)_pb11_weaver");
    handle.def_readwrite(
        "ClangModuleMapFile",
        &clang::tooling::dependencies::ModuleDeps::ClangModuleMapFile,
        R"_pb11_weaver(/// The path to the modulemap file which defines this module.
  ///
  /// This can be used to explicitly build this module. This file will
  /// additionally appear in \c FileDeps as a dependency.)_pb11_weaver");
    handle.def_readwrite(
        "ImportedByMainFile",
        &clang::tooling::dependencies::ModuleDeps::ImportedByMainFile,
        R"_pb11_weaver(// Used to track which modules that were discovered were directly imported by
  // the primary TU.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies_ModuleDeps"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleDeps

using Entity_clang_tooling_dependencies_ModuleDeps =
    Bind_clang_tooling_dependencies_ModuleDeps<>;

#else

struct Entity_clang_tooling_dependencies_ModuleDeps
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ModuleDeps(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies_ModuleDeps"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleDeps

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::ModuleID>>
struct Bind_clang_tooling_dependencies_ModuleID : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_ModuleID(EntityScope parent_h)
      : handle{parent_h, "ModuleID", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// This is used to identify a specific module.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ModuleID(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::dependencies::ModuleID>(
        handle);
    handle.def_readwrite(
        "ModuleName", &clang::tooling::dependencies::ModuleID::ModuleName,
        R"_pb11_weaver(/// The name of the module. This may include `:` for C++20 module partitions,
  /// or a header-name for C++20 header units.)_pb11_weaver");
    handle.def_readwrite(
        "ContextHash", &clang::tooling::dependencies::ModuleID::ContextHash,
        R"_pb11_weaver(/// The context hash of a module represents the compiler options that affect
  /// the resulting command-line invocation.
  ///
  /// Modules with the same name and ContextHash but different invocations could
  /// cause non-deterministic build results.
  ///
  /// Modules with the same name but a different \c ContextHash should be
  /// treated as separate modules for the purpose of a build.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies_ModuleID"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleID

using Entity_clang_tooling_dependencies_ModuleID =
    Bind_clang_tooling_dependencies_ModuleID<>;

#else

struct Entity_clang_tooling_dependencies_ModuleID
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ModuleID(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies_ModuleID"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleID

template <class Pybind11T =
              pybind11::enum_<clang::tooling::dependencies::ModuleOutputKind>>
struct Bind_clang_tooling_dependencies_ModuleOutputKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_ModuleOutputKind(
      EntityScope parent_h)
      : handle{parent_h, "ModuleOutputKind", pybind11::arithmetic(),
               R"_pb11_weaver(/// An output from a module compilation, such as the path of the module file.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ModuleOutputKind(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "ModuleFile",
        clang::tooling::dependencies::ModuleOutputKind::ModuleFile,
        R"_pb11_weaver(/// The module file (.pcm). Required.)_pb11_weaver");
    handle.value(
        "DependencyFile",
        clang::tooling::dependencies::ModuleOutputKind::DependencyFile,
        R"_pb11_weaver(/// The path of the dependency file (.d), if any.)_pb11_weaver");
    handle.value(
        "DependencyTargets",
        clang::tooling::dependencies::ModuleOutputKind::DependencyTargets,
        R"_pb11_weaver(/// The null-separated list of names to use as the targets in the dependency
  /// file, if any. Defaults to the value of \c ModuleFile, as in the driver.)_pb11_weaver");
    handle.value(
        "DiagnosticSerializationFile",
        clang::tooling::dependencies::ModuleOutputKind::
            DiagnosticSerializationFile,
        R"_pb11_weaver(/// The path of the serialized diagnostic file (.dia), if any.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_ModuleOutputKind";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleOutputKind

using Entity_clang_tooling_dependencies_ModuleOutputKind =
    Bind_clang_tooling_dependencies_ModuleOutputKind<>;

#else

struct Entity_clang_tooling_dependencies_ModuleOutputKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ModuleOutputKind(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_ModuleOutputKind";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ModuleOutputKind

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::P1689ModuleInfo>>
struct Bind_clang_tooling_dependencies_P1689ModuleInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_P1689ModuleInfo(EntityScope parent_h)
      : handle{
            parent_h, "P1689ModuleInfo", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// P1689ModuleInfo - Represents the needed information of standard C++20
/// modules for P1689 format.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_P1689ModuleInfo(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::P1689ModuleInfo>(handle);
    handle.def_readwrite(
        "ModuleName",
        &clang::tooling::dependencies::P1689ModuleInfo::ModuleName,
        R"_pb11_weaver(/// The name of the module. This may include `:` for partitions.)_pb11_weaver");
    handle.def_readwrite(
        "SourcePath",
        &clang::tooling::dependencies::P1689ModuleInfo::SourcePath,
        R"_pb11_weaver(/// Optional. The source path to the module.)_pb11_weaver");
    handle.def_readwrite(
        "IsStdCXXModuleInterface",
        &clang::tooling::dependencies::P1689ModuleInfo::IsStdCXXModuleInterface,
        R"_pb11_weaver(/// If this module is a standard c++ interface unit.)_pb11_weaver");
    handle.def_readwrite("Type",
                         &clang::tooling::dependencies::P1689ModuleInfo::Type);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_P1689ModuleInfo";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_P1689ModuleInfo

using Entity_clang_tooling_dependencies_P1689ModuleInfo =
    Bind_clang_tooling_dependencies_P1689ModuleInfo<>;

#else

struct Entity_clang_tooling_dependencies_P1689ModuleInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_P1689ModuleInfo(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_P1689ModuleInfo";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_P1689ModuleInfo

template <class Pybind11T = pybind11::enum_<
              clang::tooling::dependencies::P1689ModuleInfo::ModuleType>>
struct Bind_clang_tooling_dependencies_P1689ModuleInfo_ModuleType
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_P1689ModuleInfo_ModuleType(
      EntityScope parent_h)
      : handle{parent_h, "ModuleType", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_P1689ModuleInfo_ModuleType(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("NamedCXXModule",
                 clang::tooling::dependencies::P1689ModuleInfo::ModuleType::
                     NamedCXXModule);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_P1689ModuleInfo_ModuleType";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_P1689ModuleInfo_ModuleType

using Entity_clang_tooling_dependencies_P1689ModuleInfo_ModuleType =
    Bind_clang_tooling_dependencies_P1689ModuleInfo_ModuleType<>;

#else

struct Entity_clang_tooling_dependencies_P1689ModuleInfo_ModuleType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_P1689ModuleInfo_ModuleType(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_P1689ModuleInfo_ModuleType";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_P1689ModuleInfo_ModuleType

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::P1689Rule>>
struct Bind_clang_tooling_dependencies_P1689Rule : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_P1689Rule(EntityScope parent_h)
      : handle{parent_h, "P1689Rule", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_P1689Rule(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::dependencies::P1689Rule>(
        handle);
    handle.def_readwrite(
        "PrimaryOutput",
        &clang::tooling::dependencies::P1689Rule::PrimaryOutput);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies_P1689Rule"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_P1689Rule

using Entity_clang_tooling_dependencies_P1689Rule =
    Bind_clang_tooling_dependencies_P1689Rule<>;

#else

struct Entity_clang_tooling_dependencies_P1689Rule
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_P1689Rule(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies_P1689Rule"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_P1689Rule

template <class Pybind11T =
              pybind11::class_<clang::tooling::dependencies::PrebuiltModuleDep>>
struct Bind_clang_tooling_dependencies_PrebuiltModuleDep : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Modular dependency that has already been built prior to the dependency scan.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_PrebuiltModuleDep_Ctor0
    handle.def(pybind11::init<const clang::Module *>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_PrebuiltModuleDep(
      EntityScope parent_h)
      : handle{parent_h, "PrebuiltModuleDep", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Modular dependency that has already been built prior to the dependency scan.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_PrebuiltModuleDep(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddCtor0();
    handle.def_readwrite(
        "ModuleName",
        &clang::tooling::dependencies::PrebuiltModuleDep::ModuleName);
    handle.def_readwrite(
        "PCMFile", &clang::tooling::dependencies::PrebuiltModuleDep::PCMFile);
    handle.def_readwrite(
        "ModuleMapFile",
        &clang::tooling::dependencies::PrebuiltModuleDep::ModuleMapFile);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_PrebuiltModuleDep";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_PrebuiltModuleDep

using Entity_clang_tooling_dependencies_PrebuiltModuleDep =
    Bind_clang_tooling_dependencies_PrebuiltModuleDep<>;

#else

struct Entity_clang_tooling_dependencies_PrebuiltModuleDep
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_PrebuiltModuleDep(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_PrebuiltModuleDep";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_PrebuiltModuleDep

template <class Pybind11T =
              pybind11::enum_<clang::tooling::dependencies::ScanningMode>>
struct Bind_clang_tooling_dependencies_ScanningMode : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_ScanningMode(EntityScope parent_h)
      : handle{
            parent_h, "ScanningMode", pybind11::arithmetic(),
            R"_pb11_weaver(/// The mode in which the dependency scanner will operate to find the
/// dependencies.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ScanningMode(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "CanonicalPreprocessing",
        clang::tooling::dependencies::ScanningMode::CanonicalPreprocessing,
        R"_pb11_weaver(/// This mode is used to compute the dependencies by running the preprocessor
  /// over the source files.)_pb11_weaver");
    handle.value(
        "DependencyDirectivesScan",
        clang::tooling::dependencies::ScanningMode::DependencyDirectivesScan,
        R"_pb11_weaver(/// This mode is used to compute the dependencies by running the preprocessor
  /// with special kind of lexing after scanning header and source files to get
  /// the minimum necessary preprocessor directives for evaluating includes.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_dependencies_ScanningMode"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ScanningMode

using Entity_clang_tooling_dependencies_ScanningMode =
    Bind_clang_tooling_dependencies_ScanningMode<>;

#else

struct Entity_clang_tooling_dependencies_ScanningMode
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ScanningMode(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_dependencies_ScanningMode"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ScanningMode

template <class Pybind11T = pybind11::enum_<
              clang::tooling::dependencies::ScanningOutputFormat>>
struct Bind_clang_tooling_dependencies_ScanningOutputFormat
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_ScanningOutputFormat(
      EntityScope parent_h)
      : handle{parent_h, "ScanningOutputFormat", pybind11::arithmetic(),
               R"_pb11_weaver(/// The format that is output by the dependency scanner.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_ScanningOutputFormat(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "Make", clang::tooling::dependencies::ScanningOutputFormat::Make,
        R"_pb11_weaver(/// This is the Makefile compatible dep format. This will include all of the
  /// deps necessary for an implicit modules build, but won't include any
  /// intermodule dependency information.)_pb11_weaver");
    handle.value(
        "Full", clang::tooling::dependencies::ScanningOutputFormat::Full,
        R"_pb11_weaver(/// This outputs the full clang module dependency graph suitable for use for
  /// explicitly building modules.)_pb11_weaver");
    handle.value(
        "P1689", clang::tooling::dependencies::ScanningOutputFormat::P1689,
        R"_pb11_weaver(/// This outputs the dependency graph for standard c++ modules in P1689R5
  /// format.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_ScanningOutputFormat";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ScanningOutputFormat

using Entity_clang_tooling_dependencies_ScanningOutputFormat =
    Bind_clang_tooling_dependencies_ScanningOutputFormat<>;

#else

struct Entity_clang_tooling_dependencies_ScanningOutputFormat
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_ScanningOutputFormat(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_ScanningOutputFormat";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_ScanningOutputFormat

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::TranslationUnitDeps>>
struct Bind_clang_tooling_dependencies_TranslationUnitDeps : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_dependencies_TranslationUnitDeps(
      EntityScope parent_h)
      : handle{parent_h, "TranslationUnitDeps", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// The full dependencies and module graph for a specific input.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_TranslationUnitDeps(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::dependencies::TranslationUnitDeps>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_TranslationUnitDeps";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_TranslationUnitDeps

using Entity_clang_tooling_dependencies_TranslationUnitDeps =
    Bind_clang_tooling_dependencies_TranslationUnitDeps<>;

#else

struct Entity_clang_tooling_dependencies_TranslationUnitDeps
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_TranslationUnitDeps(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_TranslationUnitDeps";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_TranslationUnitDeps

template <class = void>
class PyTrampCallbackActionController
    : public clang::tooling::dependencies::CallbackActionController {
public:
  using _PB11_WR_BaseT = clang::tooling::dependencies::CallbackActionController;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_CallbackActionControllerstd_string_9const_ModuleID____ModuleOutputKind_
  std::basic_string<char> lookupModuleOutput(
      const clang::tooling::dependencies::ModuleID &ID,
      clang::tooling::dependencies::ModuleOutputKind Kind) override {
    using _PB11_WR_RET_TYPE = std::basic_string<char>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::dependencies::CallbackActionController;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      lookupModuleOutput, ID, Kind);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_dependencies_CallbackActionControllerstd_string_9const_ModuleID____ModuleOutputKind_
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::dependencies::CallbackActionController,
              PyTrampCallbackActionController<>,
              clang::tooling::dependencies::DependencyActionController>>
struct Bind_clang_tooling_dependencies_CallbackActionController
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_lookupModuleOutput() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CallbackActionController_lookupModuleOutput
    handle.def("lookupModuleOutput",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::dependencies::CallbackActionController,
                   std::basic_string<char>,
                   const clang::tooling::dependencies::ModuleID &,
                   clang::tooling::dependencies::ModuleOutputKind>::type>(
                   &clang::tooling::dependencies::CallbackActionController::
                       lookupModuleOutput));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A simple dependency action controller that uses a callback. If no callback
/// is provided, it is assumed that looking up module outputs is unreachable.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_dependencies_CallbackActionController_Ctor0
    handle.def(pybind11::init<llvm::function_ref<std::basic_string<char>(
                   const clang::tooling::dependencies::ModuleID &,
                   clang::tooling::dependencies::ModuleOutputKind)>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_dependencies_CallbackActionController(
      EntityScope parent_h)
      : handle{parent_h, "CallbackActionController", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A simple dependency action controller that uses a callback. If no callback
/// is provided, it is assumed that looking up module outputs is unreachable.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_dependencies_CallbackActionController(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_lookupModuleOutput();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_dependencies_CallbackActionController";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_CallbackActionController

using Entity_clang_tooling_dependencies_CallbackActionController =
    Bind_clang_tooling_dependencies_CallbackActionController<>;

#else

struct Entity_clang_tooling_dependencies_CallbackActionController
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_dependencies_CallbackActionController(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_dependencies_CallbackActionController";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_dependencies_CallbackActionController

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_detail : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_detail(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "detail")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_detail(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_detail"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_detail

using Entity_clang_tooling_detail = Bind_clang_tooling_detail<>;

#else

struct Entity_clang_tooling_detail : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_detail(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_detail"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_detail

template <class = void>
class PyTrampTransformerImpl : public clang::tooling::detail::TransformerImpl {
public:
  using _PB11_WR_BaseT = clang::tooling::detail::TransformerImpl;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_detail_TransformerImplstd_vector6ast_matchers_internal_DynTypedMatcher9_9__const
  std::vector<clang::ast_matchers::internal::DynTypedMatcher>
  buildMatchers() const override {
    using _PB11_WR_RET_TYPE =
        std::vector<clang::ast_matchers::internal::DynTypedMatcher>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::detail::TransformerImpl;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           buildMatchers,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_detail_TransformerImplstd_vector6ast_matchers_internal_DynTypedMatcher9_9__const
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::detail::TransformerImpl,
                               PyTrampTransformerImpl<>>>
struct Bind_clang_tooling_detail_TransformerImpl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_onMatch() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_detail_TransformerImpl_onMatch
    handle.def(
        "onMatch",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::detail::TransformerImpl, void,
            const clang::ast_matchers::MatchFinder::MatchResult &>::type>(
            &clang::tooling::detail::TransformerImpl::onMatch));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_buildMatchers() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_detail_TransformerImpl_buildMatchers
    handle.def(
        "buildMatchers",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::detail::TransformerImpl,
            std::vector<clang::ast_matchers::internal::DynTypedMatcher>>::
                        const_type>(
            &clang::tooling::detail::TransformerImpl::buildMatchers));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_detail_TransformerImpl(EntityScope parent_h)
      : handle{
            parent_h, "TransformerImpl", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Implementation details of \c Transformer with type erasure around
/// \c RewriteRule<T> as well as the corresponding consumers.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_detail_TransformerImpl(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_onMatch();
    AddMethod_buildMatchers();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::detail::TransformerImpl>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_detail_TransformerImpl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_detail_TransformerImpl

using Entity_clang_tooling_detail_TransformerImpl =
    Bind_clang_tooling_detail_TransformerImpl<>;

#else

struct Entity_clang_tooling_detail_TransformerImpl
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_detail_TransformerImpl(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_detail_TransformerImpl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_detail_TransformerImpl

template <class Pybind11T = pybind11::module_ &>
struct Bind_expandResponseFiles : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a wrapped CompilationDatabase that will expand all rsp(response)
/// files on commandline returned by underlying database.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_expandResponseFiles_AddFunction
#ifndef PB11_WEAVER_DISABLE_expandResponseFiles_AddFunction
    handle.def("expandResponseFiles", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_expandResponseFiles(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_expandResponseFiles(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "expandResponseFiles"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_expandResponseFiles

using Entity_expandResponseFiles = Bind_expandResponseFiles<>;

#else

struct Entity_expandResponseFiles : public pybind11_weaver::DisabledEntity {
  explicit Entity_expandResponseFiles(EntityScope parent_h) {}
  static const char *Key() { return "expandResponseFiles"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_expandResponseFiles

template <class Pybind11T = pybind11::module_ &>
struct Bind_findSelectedASTNodes : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Traverses the given ASTContext and creates a tree of selected AST nodes.
///
/// \returns std::nullopt if no nodes are selected in the AST, or a selected AST
/// node that corresponds to the TranslationUnitDecl otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_findSelectedASTNodes_AddFunction
    handle.def(
        "findSelectedASTNodes",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::tooling::SelectedASTNode>(
                      const clang::ASTContext &, clang::SourceRange)>::type>(
            &clang::tooling::findSelectedASTNodes),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_findSelectedASTNodes(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_findSelectedASTNodes(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "findSelectedASTNodes"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_findSelectedASTNodes

using Entity_findSelectedASTNodes = Bind_findSelectedASTNodes<>;

#else

struct Entity_findSelectedASTNodes : public pybind11_weaver::DisabledEntity {
  explicit Entity_findSelectedASTNodes(EntityScope parent_h) {}
  static const char *Key() { return "findSelectedASTNodes"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_findSelectedASTNodes

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_fixit : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_fixit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "fixit")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_fixit(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_fixit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_fixit

using Entity_clang_tooling_fixit = Bind_clang_tooling_fixit<>;

#else

struct Entity_clang_tooling_fixit : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_fixit(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_fixit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_fixit

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_fixit_internal : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_fixit_internal(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "internal")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_fixit_internal(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_fixit_internal"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_fixit_internal

using Entity_clang_tooling_fixit_internal = Bind_clang_tooling_fixit_internal<>;

#else

struct Entity_clang_tooling_fixit_internal
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_fixit_internal(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_fixit_internal"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_fixit_internal

template <class Pybind11T = pybind11::module_ &>
struct Bind_getSourceRange1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the CharSourceRange of the token at Location \p Loc.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getSourceRange1_AddFunction
    handle.def(
        "getSourceRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::CharSourceRange(const clang::SourceLocation &)>::type>(
            &clang::tooling::fixit::internal::getSourceRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getSourceRange1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getSourceRange1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getSourceRange1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getSourceRange1

using Entity_getSourceRange1 = Bind_getSourceRange1<>;

#else

struct Entity_getSourceRange1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_getSourceRange1(EntityScope parent_h) {}
  static const char *Key() { return "getSourceRange1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getSourceRange1

template <class Pybind11T = pybind11::module_ &>
struct Bind_getSourceRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the token CharSourceRange corresponding to \p Range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getSourceRange_AddFunction
    handle.def(
        "getSourceRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::CharSourceRange(const clang::SourceRange &)>::type>(
            &clang::tooling::fixit::internal::getSourceRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getSourceRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getSourceRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getSourceRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getSourceRange

using Entity_getSourceRange = Bind_getSourceRange<>;

#else

struct Entity_getSourceRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_getSourceRange(EntityScope parent_h) {}
  static const char *Key() { return "getSourceRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getSourceRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_getText1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_getText1_AddFunction
    handle.def("getText",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::StringRef(clang::CharSourceRange,
                                         const clang::ASTContext &)>::type>(
                   &clang::tooling::fixit::internal::getText));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getText1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getText1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getText1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getText1

using Entity_getText1 = Bind_getText1<>;

#else

struct Entity_getText1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_getText1(EntityScope parent_h) {}
  static const char *Key() { return "getText1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getText1

template <class Pybind11T = pybind11::module_ &>
struct Bind_formatAndApplyAllReplacements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Groups \p Replaces by the file path and applies each group of
/// Replacements on the related file in \p Rewriter. In addition to applying
/// given Replacements, this function also formats the changed code.
///
/// \pre Replacements must be conflict-free.
///
/// FileToReplaces will be deduplicated with `groupReplacementsByFile` before
/// application.
///
/// Replacement applications happen independently of the success of other
/// applications.
///
/// \param[in] FileToReplaces Replacements (grouped by files) to apply.
/// \param[in] Rewrite The `Rewritter` to apply replacements on.
/// \param[in] Style The style name used for reformatting. See ```getStyle``` in
/// "include/clang/Format/Format.h" for all possible style forms.
///
/// \returns true if all replacements applied and formatted. false otherwise.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_formatAndApplyAllReplacements_AddFunction
    handle.def("formatAndApplyAllReplacements",
               static_cast<pybind11_weaver::FnPtrT<
                   void, bool(const std::map<std::basic_string<char>,
                                             clang::tooling::Replacements> &,
                              clang::Rewriter &, llvm::StringRef)>::type>(
                   &clang::tooling::formatAndApplyAllReplacements),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_formatAndApplyAllReplacements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_formatAndApplyAllReplacements(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "formatAndApplyAllReplacements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_formatAndApplyAllReplacements

using Entity_formatAndApplyAllReplacements =
    Bind_formatAndApplyAllReplacements<>;

#else

struct Entity_formatAndApplyAllReplacements
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_formatAndApplyAllReplacements(EntityScope parent_h) {}
  static const char *Key() { return "formatAndApplyAllReplacements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_formatAndApplyAllReplacements

template <class Pybind11T = pybind11::module_ &>
struct Bind_getAbsolutePath : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the absolute path of \c File, by prepending it with
/// the current directory if \c File is not absolute.
///
/// Otherwise returns \c File.
/// If 'File' starts with "./", the returned path will not contain the "./".
/// Otherwise, the returned path will contain the literal path-concatenation of
/// the current directory and \c File.
///
/// The difference to llvm::sys::fs::make_absolute is the canonicalization this
/// does by removing "./" and computing native paths.
///
/// \param File Either an absolute or relative path.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getAbsolutePath_AddFunction
    handle.def("getAbsolutePath",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::basic_string<char>(llvm::StringRef)>::type>(
                   &clang::tooling::getAbsolutePath),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getAbsolutePath(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getAbsolutePath(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getAbsolutePath"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getAbsolutePath

using Entity_getAbsolutePath = Bind_getAbsolutePath<>;

#else

struct Entity_getAbsolutePath : public pybind11_weaver::DisabledEntity {
  explicit Entity_getAbsolutePath(EntityScope parent_h) {}
  static const char *Key() { return "getAbsolutePath"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getAbsolutePath

template <class Pybind11T = pybind11::module_ &>
struct Bind_getAbsolutePath1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// An overload of getAbsolutePath that works over the provided \p FS.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getAbsolutePath1_AddFunction
    handle.def("getAbsolutePath",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::Expected<std::basic_string<char>>(
                             llvm::vfs::FileSystem &, llvm::StringRef)>::type>(
                   &clang::tooling::getAbsolutePath),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getAbsolutePath1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getAbsolutePath1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getAbsolutePath1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getAbsolutePath1

using Entity_getAbsolutePath1 = Bind_getAbsolutePath1<>;

#else

struct Entity_getAbsolutePath1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_getAbsolutePath1(EntityScope parent_h) {}
  static const char *Key() { return "getAbsolutePath1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getAbsolutePath1

template <class Pybind11T = pybind11::module_ &>
struct Bind_getAssociatedRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the logical source range of the node extended to include associated
/// comments and whitespace before and after the node, and associated
/// terminators. The returned range consists of file locations, if valid file
/// locations can be found for the associated content; otherwise, an invalid
/// range is returned.
///
/// Note that parsing comments is disabled by default. In order to select a
/// range containing associated comments, you may need to invoke the tool with
/// `-fparse-all-comments`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getAssociatedRange_AddFunction
    handle.def("getAssociatedRange",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::CharSourceRange(const clang::Decl &,
                                                clang::ASTContext &)>::type>(
                   &clang::tooling::getAssociatedRange),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getAssociatedRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getAssociatedRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getAssociatedRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getAssociatedRange

using Entity_getAssociatedRange = Bind_getAssociatedRange<>;

#else

struct Entity_getAssociatedRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_getAssociatedRange(EntityScope parent_h) {}
  static const char *Key() { return "getAssociatedRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getAssociatedRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_getCC1Arguments : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Retrieves the flags of the `-cc1` job in `Compilation` that has only source
/// files as its inputs.
/// Returns nullptr if there are no such jobs or multiple of them. Note that
/// offloading jobs are ignored.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getCC1Arguments_AddFunction
    handle.def(
        "getCC1Arguments",
        [](clang::DiagnosticsEngine *Diagnostics,
           pybind11_weaver::WrappedPtrT<clang::driver::Compilation *>
               Compilation) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, const llvm::SmallVector<const char *, 16> *(
                                        clang::DiagnosticsEngine *,
                                        clang::driver::Compilation *)>::type>(
                              &clang::tooling::getCC1Arguments),
                          Diagnostics, (Compilation)->Cptr());
          return pybind11_weaver::WrapP<
              const llvm::SmallVector<const char *, 16> *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getCC1Arguments(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getCC1Arguments(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getCC1Arguments"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getCC1Arguments

using Entity_getCC1Arguments = Bind_getCC1Arguments<>;

#else

struct Entity_getCC1Arguments : public pybind11_weaver::DisabledEntity {
  explicit Entity_getCC1Arguments(EntityScope parent_h) {}
  static const char *Key() { return "getCC1Arguments"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getCC1Arguments

template <class Pybind11T = pybind11::module_ &>
struct Bind_getCanonicalSymbolDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the canonical declaration that best represents a symbol that can be
/// renamed.
///
/// The following canonicalization rules are currently used:
///
/// - A constructor is canonicalized to its class.
/// - A destructor is canonicalized to its class.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getCanonicalSymbolDeclaration_AddFunction
    handle.def(
        "getCanonicalSymbolDeclaration",
        [](pybind11_weaver::WrappedPtrT<const clang::NamedDecl *> FoundDecl) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  const clang::NamedDecl *(const clang::NamedDecl *)>::type>(
                  &clang::tooling::getCanonicalSymbolDeclaration),
              (FoundDecl)->Cptr());
          return pybind11_weaver::WrapP<const clang::NamedDecl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getCanonicalSymbolDeclaration(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getCanonicalSymbolDeclaration(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getCanonicalSymbolDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getCanonicalSymbolDeclaration

using Entity_getCanonicalSymbolDeclaration =
    Bind_getCanonicalSymbolDeclaration<>;

#else

struct Entity_getCanonicalSymbolDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_getCanonicalSymbolDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "getCanonicalSymbolDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getCanonicalSymbolDeclaration

template <class Pybind11T = pybind11::module_ &>
struct Bind_getClangStripDependencyFileAdjuster : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster which removes dependency-file
/// related command line arguments.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getClangStripDependencyFileAdjuster_AddFunction
    handle.def("getClangStripDependencyFileAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::function<std::vector<std::basic_string<char>>(
                             const std::vector<std::basic_string<char>> &,
                             llvm::StringRef)>()>::type>(
                   &clang::tooling::getClangStripDependencyFileAdjuster),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getClangStripDependencyFileAdjuster(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getClangStripDependencyFileAdjuster(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getClangStripDependencyFileAdjuster"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getClangStripDependencyFileAdjuster

using Entity_getClangStripDependencyFileAdjuster =
    Bind_getClangStripDependencyFileAdjuster<>;

#else

struct Entity_getClangStripDependencyFileAdjuster
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_getClangStripDependencyFileAdjuster(EntityScope parent_h) {}
  static const char *Key() { return "getClangStripDependencyFileAdjuster"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getClangStripDependencyFileAdjuster

template <class Pybind11T = pybind11::module_ &>
struct Bind_getClangStripOutputAdjuster : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster which removes output-related command line
/// arguments.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getClangStripOutputAdjuster_AddFunction
    handle.def("getClangStripOutputAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::function<std::vector<std::basic_string<char>>(
                             const std::vector<std::basic_string<char>> &,
                             llvm::StringRef)>()>::type>(
                   &clang::tooling::getClangStripOutputAdjuster),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getClangStripOutputAdjuster(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getClangStripOutputAdjuster(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getClangStripOutputAdjuster"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getClangStripOutputAdjuster

using Entity_getClangStripOutputAdjuster = Bind_getClangStripOutputAdjuster<>;

#else

struct Entity_getClangStripOutputAdjuster
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_getClangStripOutputAdjuster(EntityScope parent_h) {}
  static const char *Key() { return "getClangStripOutputAdjuster"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getClangStripOutputAdjuster

template <class Pybind11T = pybind11::module_ &>
struct Bind_getClangSyntaxOnlyAdjuster : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster that converts input command line arguments
/// to the "syntax check only" variant.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getClangSyntaxOnlyAdjuster_AddFunction
    handle.def("getClangSyntaxOnlyAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::function<std::vector<std::basic_string<char>>(
                             const std::vector<std::basic_string<char>> &,
                             llvm::StringRef)>()>::type>(
                   &clang::tooling::getClangSyntaxOnlyAdjuster),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getClangSyntaxOnlyAdjuster(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getClangSyntaxOnlyAdjuster(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getClangSyntaxOnlyAdjuster"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getClangSyntaxOnlyAdjuster

using Entity_getClangSyntaxOnlyAdjuster = Bind_getClangSyntaxOnlyAdjuster<>;

#else

struct Entity_getClangSyntaxOnlyAdjuster
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_getClangSyntaxOnlyAdjuster(EntityScope parent_h) {}
  static const char *Key() { return "getClangSyntaxOnlyAdjuster"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getClangSyntaxOnlyAdjuster

template <class Pybind11T = pybind11::module_ &>
struct Bind_getFileRange1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_getFileRange1_AddFunction
    handle.def(
        "getFileRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::CharSourceRange>(
                      const clang::CharSourceRange &, const clang::ASTContext &,
                      bool)>::type>(&clang::tooling::getFileRange));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getFileRange1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getFileRange1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getFileRange1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getFileRange1

using Entity_getFileRange1 = Bind_getFileRange1<>;

#else

struct Entity_getFileRange1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_getFileRange1(EntityScope parent_h) {}
  static const char *Key() { return "getFileRange1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getFileRange1

template <class Pybind11T = pybind11::module_ &>
struct Bind_getFileRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Attempts to resolve the given range to one that starts and ends in a
/// particular file.
///
/// If \c IncludeMacroExpansion is true, a limited set of cases involving source
/// locations in macro expansions is supported. For example, if we're looking to
/// get the range of the int literal 3, and we have the following definition:
///    #define DO_NOTHING(x) x
///    foo(DO_NOTHING(3))
/// the returned range will hold the source text `DO_NOTHING(3)`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getFileRange_AddFunction
    handle.def(
        "getFileRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::CharSourceRange>(
                      const clang::CharSourceRange &,
                      const clang::SourceManager &, const clang::LangOptions &,
                      bool)>::type>(&clang::tooling::getFileRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getFileRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getFileRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getFileRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getFileRange

using Entity_getFileRange = Bind_getFileRange<>;

#else

struct Entity_getFileRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_getFileRange(EntityScope parent_h) {}
  static const char *Key() { return "getFileRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getFileRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_getFileRangeForEdit1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_getFileRangeForEdit1_AddFunction
    handle.def(
        "getFileRangeForEdit",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::CharSourceRange>(
                      const clang::CharSourceRange &, const clang::ASTContext &,
                      bool)>::type>(&clang::tooling::getFileRangeForEdit));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getFileRangeForEdit1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getFileRangeForEdit1(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getFileRangeForEdit1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getFileRangeForEdit1

using Entity_getFileRangeForEdit1 = Bind_getFileRangeForEdit1<>;

#else

struct Entity_getFileRangeForEdit1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_getFileRangeForEdit1(EntityScope parent_h) {}
  static const char *Key() { return "getFileRangeForEdit1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getFileRangeForEdit1

template <class Pybind11T = pybind11::module_ &>
struct Bind_getFileRangeForEdit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Attempts to resolve the given range to one that can be edited by a rewrite;
/// generally, one that starts and ends within a particular file. If a value is
/// returned, it satisfies \c validateEditRange.
///
/// If \c IncludeMacroExpansion is true, a limited set of cases involving source
/// locations in macro expansions is supported. For example, if we're looking to
/// rewrite the int literal 3 to 6, and we have the following definition:
///    #define DO_NOTHING(x) x
/// then
///    foo(DO_NOTHING(3))
/// will be rewritten to
///    foo(6))_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getFileRangeForEdit_AddFunction
    handle.def(
        "getFileRangeForEdit",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::CharSourceRange>(
                      const clang::CharSourceRange &,
                      const clang::SourceManager &, const clang::LangOptions &,
                      bool)>::type>(&clang::tooling::getFileRangeForEdit),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getFileRangeForEdit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getFileRangeForEdit(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getFileRangeForEdit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getFileRangeForEdit

using Entity_getFileRangeForEdit = Bind_getFileRangeForEdit<>;

#else

struct Entity_getFileRangeForEdit : public pybind11_weaver::DisabledEntity {
  explicit Entity_getFileRangeForEdit(EntityScope parent_h) {}
  static const char *Key() { return "getFileRangeForEdit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getFileRangeForEdit

template <class Pybind11T = pybind11::module_ &>
struct Bind_getInsertArgumentAdjuster : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster which inserts \p Extra arguments in the
/// specified position.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getInsertArgumentAdjuster_AddFunction
    handle.def(
        "getInsertArgumentAdjuster",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<std::vector<std::basic_string<char>>(
                const std::vector<std::basic_string<char>> &, llvm::StringRef)>(
                const std::vector<std::basic_string<char>> &,
                clang::tooling::ArgumentInsertPosition)>::type>(
            &clang::tooling::getInsertArgumentAdjuster),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getInsertArgumentAdjuster(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getInsertArgumentAdjuster(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getInsertArgumentAdjuster"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getInsertArgumentAdjuster

using Entity_getInsertArgumentAdjuster = Bind_getInsertArgumentAdjuster<>;

#else

struct Entity_getInsertArgumentAdjuster
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_getInsertArgumentAdjuster(EntityScope parent_h) {}
  static const char *Key() { return "getInsertArgumentAdjuster"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getInsertArgumentAdjuster

template <class Pybind11T = pybind11::module_ &>
struct Bind_getInsertArgumentAdjuster1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster which inserts an \p Extra argument in the
/// specified position.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getInsertArgumentAdjuster1_AddFunction
    handle.def(
        "getInsertArgumentAdjuster",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<std::vector<std::basic_string<char>>(
                const std::vector<std::basic_string<char>> &, llvm::StringRef)>(
                const char *, clang::tooling::ArgumentInsertPosition)>::type>(
            &clang::tooling::getInsertArgumentAdjuster),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getInsertArgumentAdjuster1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getInsertArgumentAdjuster1(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getInsertArgumentAdjuster1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getInsertArgumentAdjuster1

using Entity_getInsertArgumentAdjuster1 = Bind_getInsertArgumentAdjuster1<>;

#else

struct Entity_getInsertArgumentAdjuster1
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_getInsertArgumentAdjuster1(EntityScope parent_h) {}
  static const char *Key() { return "getInsertArgumentAdjuster1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getInsertArgumentAdjuster1

template <class Pybind11T = pybind11::module_ &>
struct Bind_getNamedDeclAt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Given an AST context and a point, returns a NamedDecl identifying the symbol
// at the point. Returns null if nothing is found at the point.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getNamedDeclAt_AddFunction
    handle.def(
        "getNamedDeclAt",
        [](const clang::ASTContext &Context,
           const clang::SourceLocation Point) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  const clang::NamedDecl *(const clang::ASTContext &,
                                           const clang::SourceLocation)>::type>(
                  &clang::tooling::getNamedDeclAt),
              Context, Point);
          return pybind11_weaver::WrapP<const clang::NamedDecl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getNamedDeclAt(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getNamedDeclAt(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getNamedDeclAt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getNamedDeclAt

using Entity_getNamedDeclAt = Bind_getNamedDeclAt<>;

#else

struct Entity_getNamedDeclAt : public pybind11_weaver::DisabledEntity {
  explicit Entity_getNamedDeclAt(EntityScope parent_h) {}
  static const char *Key() { return "getNamedDeclAt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getNamedDeclAt

template <class Pybind11T = pybind11::module_ &>
struct Bind_getNamedDeclFor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Given an AST context and a fully qualified name, returns a NamedDecl
// identifying the symbol with a matching name. Returns null if nothing is
// found for the name.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getNamedDeclFor_AddFunction
    handle.def(
        "getNamedDeclFor",
        [](const clang::ASTContext &Context,
           const std::basic_string<char> &Name) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, const clang::NamedDecl *(
                            const clang::ASTContext &,
                            const std::basic_string<char> &)>::type>(
                  &clang::tooling::getNamedDeclFor),
              Context, Name);
          return pybind11_weaver::WrapP<const clang::NamedDecl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getNamedDeclFor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getNamedDeclFor(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getNamedDeclFor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getNamedDeclFor

using Entity_getNamedDeclFor = Bind_getNamedDeclFor<>;

#else

struct Entity_getNamedDeclFor : public pybind11_weaver::DisabledEntity {
  explicit Entity_getNamedDeclFor(EntityScope parent_h) {}
  static const char *Key() { return "getNamedDeclFor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getNamedDeclFor

template <class Pybind11T = pybind11::module_ &>
struct Bind_getOccurrencesOfUSRs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Finds the symbol occurrences for the symbol that's identified by the given
/// USR set.
///
/// \return SymbolOccurrences that can be converted to AtomicChanges when
/// renaming.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getOccurrencesOfUSRs_AddFunction
    handle.def(
        "getOccurrencesOfUSRs",
        [](llvm::ArrayRef<std::basic_string<char>> USRs,
           llvm::StringRef PrevName,
           pybind11_weaver::WrappedPtrT<clang::Decl *> Decl) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, std::vector<clang::tooling::SymbolOccurrence>(
                            llvm::ArrayRef<std::basic_string<char>>,
                            llvm::StringRef, clang::Decl *)>::type>(
                  &clang::tooling::getOccurrencesOfUSRs),
              USRs, PrevName, (Decl)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getOccurrencesOfUSRs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getOccurrencesOfUSRs(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getOccurrencesOfUSRs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getOccurrencesOfUSRs

using Entity_getOccurrencesOfUSRs = Bind_getOccurrencesOfUSRs<>;

#else

struct Entity_getOccurrencesOfUSRs : public pybind11_weaver::DisabledEntity {
  explicit Entity_getOccurrencesOfUSRs(EntityScope parent_h) {}
  static const char *Key() { return "getOccurrencesOfUSRs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getOccurrencesOfUSRs

template <class Pybind11T = pybind11::module_ &>
struct Bind_getStripPluginsAdjuster : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets an argument adjuster which strips plugin related command line
/// arguments.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getStripPluginsAdjuster_AddFunction
    handle.def("getStripPluginsAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::function<std::vector<std::basic_string<char>>(
                             const std::vector<std::basic_string<char>> &,
                             llvm::StringRef)>()>::type>(
                   &clang::tooling::getStripPluginsAdjuster),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getStripPluginsAdjuster(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getStripPluginsAdjuster(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getStripPluginsAdjuster"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getStripPluginsAdjuster

using Entity_getStripPluginsAdjuster = Bind_getStripPluginsAdjuster<>;

#else

struct Entity_getStripPluginsAdjuster : public pybind11_weaver::DisabledEntity {
  explicit Entity_getStripPluginsAdjuster(EntityScope parent_h) {}
  static const char *Key() { return "getStripPluginsAdjuster"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getStripPluginsAdjuster

template <class Pybind11T = pybind11::module_ &>
struct Bind_getText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the source-code text in the specified range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getText_AddFunction
    handle.def("getText",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::StringRef(clang::CharSourceRange,
                                         const clang::ASTContext &)>::type>(
                   &clang::tooling::getText),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getText(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getText

using Entity_getText = Bind_getText<>;

#else

struct Entity_getText : public pybind11_weaver::DisabledEntity {
  explicit Entity_getText(EntityScope parent_h) {}
  static const char *Key() { return "getText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getText

template <class Pybind11T = pybind11::module_ &>
struct Bind_getUSRForDecl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Converts a Decl into a USR.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getUSRForDecl_AddFunction
    handle.def(
        "getUSRForDecl",
        [](pybind11_weaver::WrappedPtrT<const clang::Decl *> Decl) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, std::basic_string<char>(const clang::Decl *)>::type>(
                  &clang::tooling::getUSRForDecl),
              (Decl)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getUSRForDecl(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getUSRForDecl(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getUSRForDecl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getUSRForDecl

using Entity_getUSRForDecl = Bind_getUSRForDecl<>;

#else

struct Entity_getUSRForDecl : public pybind11_weaver::DisabledEntity {
  explicit Entity_getUSRForDecl(EntityScope parent_h) {}
  static const char *Key() { return "getUSRForDecl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getUSRForDecl

template <class Pybind11T = pybind11::module_ &>
struct Bind_getUSRsForDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the set of USRs that correspond to the given declaration.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getUSRsForDeclaration_AddFunction
    handle.def(
        "getUSRsForDeclaration",
        [](pybind11_weaver::WrappedPtrT<const clang::NamedDecl *> ND,
           clang::ASTContext &Context) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, std::vector<std::basic_string<char>>(
                                           const clang::NamedDecl *,
                                           clang::ASTContext &)>::type>(
                                 &clang::tooling::getUSRsForDeclaration),
                             (ND)->Cptr(), Context);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getUSRsForDeclaration(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getUSRsForDeclaration(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getUSRsForDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getUSRsForDeclaration

using Entity_getUSRsForDeclaration = Bind_getUSRsForDeclaration<>;

#else

struct Entity_getUSRsForDeclaration : public pybind11_weaver::DisabledEntity {
  explicit Entity_getUSRsForDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "getUSRsForDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getUSRsForDeclaration

template <class Pybind11T = pybind11::module_ &>
struct Bind_groupReplacementsByFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If there are multiple <File, Replacements> pairs with the same file
/// entry, we only keep one pair and discard the rest.
/// If a file does not exist, its corresponding replacements will be ignored.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_groupReplacementsByFile_AddFunction
    handle.def(
        "groupReplacementsByFile",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::map<std::basic_string<char>, clang::tooling::Replacements>(
                clang::FileManager &,
                const std::map<std::basic_string<char>,
                               clang::tooling::Replacements> &)>::type>(
            &clang::tooling::groupReplacementsByFile),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_groupReplacementsByFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_groupReplacementsByFile(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "groupReplacementsByFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_groupReplacementsByFile

using Entity_groupReplacementsByFile = Bind_groupReplacementsByFile<>;

#else

struct Entity_groupReplacementsByFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_groupReplacementsByFile(EntityScope parent_h) {}
  static const char *Key() { return "groupReplacementsByFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_groupReplacementsByFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_inferMissingCompileCommands : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a wrapped CompilationDatabase that defers to the provided one,
/// but getCompileCommands() will infer commands for unknown files.
/// The return value of getAllFiles() or getAllCompileCommands() is unchanged.
/// See InterpolatingCompilationDatabase.cpp for details on heuristics.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_inferMissingCompileCommands_AddFunction
#ifndef PB11_WEAVER_DISABLE_inferMissingCompileCommands_AddFunction
    handle.def("inferMissingCompileCommands", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_inferMissingCompileCommands(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_inferMissingCompileCommands(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "inferMissingCompileCommands"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_inferMissingCompileCommands

using Entity_inferMissingCompileCommands = Bind_inferMissingCompileCommands<>;

#else

struct Entity_inferMissingCompileCommands
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_inferMissingCompileCommands(EntityScope parent_h) {}
  static const char *Key() { return "inferMissingCompileCommands"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_inferMissingCompileCommands

template <class Pybind11T = pybind11::module_ &>
struct Bind_inferTargetAndDriverMode : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a wrapped CompilationDatabase that will add -target and -mode flags
/// to commandline when they can be deduced from argv[0] of commandline returned
/// by underlying database.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_inferTargetAndDriverMode_AddFunction
#ifndef PB11_WEAVER_DISABLE_inferTargetAndDriverMode_AddFunction
    handle.def("inferTargetAndDriverMode", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_inferTargetAndDriverMode(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_inferTargetAndDriverMode(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "inferTargetAndDriverMode"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_inferTargetAndDriverMode

using Entity_inferTargetAndDriverMode = Bind_inferTargetAndDriverMode<>;

#else

struct Entity_inferTargetAndDriverMode
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_inferTargetAndDriverMode(EntityScope parent_h) {}
  static const char *Key() { return "inferTargetAndDriverMode"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_inferTargetAndDriverMode

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_internal : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_internal(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "internal")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_internal(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_internal"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_internal

using Entity_clang_tooling_internal = Bind_clang_tooling_internal<>;

#else

struct Entity_clang_tooling_internal : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_internal(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_internal"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_internal

template <class Pybind11T =
              pybind11::class_<clang::tooling::internal::RangeLessThan>>
struct Bind_clang_tooling_internal_RangeLessThan : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_internal_RangeLessThan(EntityScope parent_h)
      : handle{parent_h, "RangeLessThan", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_internal_RangeLessThan(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::internal::RangeLessThan>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_internal_RangeLessThan"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_internal_RangeLessThan

using Entity_clang_tooling_internal_RangeLessThan =
    Bind_clang_tooling_internal_RangeLessThan<>;

#else

struct Entity_clang_tooling_internal_RangeLessThan
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_internal_RangeLessThan(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_internal_RangeLessThan"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_internal_RangeLessThan

template <class Pybind11T = pybind11::module_ &>
struct Bind_createExecutorFromCommandLineArgsImpl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_createExecutorFromCommandLineArgsImpl_AddFunction
#ifndef PB11_WEAVER_DISABLE_createExecutorFromCommandLineArgsImpl_AddFunction
    handle.def("createExecutorFromCommandLineArgsImpl", None);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_createExecutorFromCommandLineArgsImpl(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_createExecutorFromCommandLineArgsImpl(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "createExecutorFromCommandLineArgsImpl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_createExecutorFromCommandLineArgsImpl

using Entity_createExecutorFromCommandLineArgsImpl =
    Bind_createExecutorFromCommandLineArgsImpl<>;

#else

struct Entity_createExecutorFromCommandLineArgsImpl
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_createExecutorFromCommandLineArgsImpl(EntityScope parent_h) {}
  static const char *Key() { return "createExecutorFromCommandLineArgsImpl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_createExecutorFromCommandLineArgsImpl

template <class Pybind11T = pybind11::module_ &>
struct Bind_findError : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_findError_AddFunction
    handle.def("findError",
               static_cast<pybind11_weaver::FnPtrT<void, llvm::Error()>::type>(
                   &clang::tooling::internal::findError));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_findError(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_findError(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "findError"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_findError

using Entity_findError = Bind_findError<>;

#else

struct Entity_findError : public pybind11_weaver::DisabledEntity {
  explicit Entity_findError(EntityScope parent_h) {}
  static const char *Key() { return "findError"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_findError

template <class Pybind11T = pybind11::module_ &>
struct Bind_ignoreError : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_ignoreError_AddFunction
    handle.def("ignoreError",
               static_cast<pybind11_weaver::FnPtrT<void, void()>::type>(
                   &clang::tooling::internal::ignoreError));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_ignoreError(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_ignoreError(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "ignoreError"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_ignoreError

using Entity_ignoreError = Bind_ignoreError<>;

#else

struct Entity_ignoreError : public pybind11_weaver::DisabledEntity {
  explicit Entity_ignoreError(EntityScope parent_h) {}
  static const char *Key() { return "ignoreError"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_ignoreError

template <class Pybind11T = pybind11::module_ &>
struct Bind_visitRefactoringOptionsImpl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_visitRefactoringOptionsImpl_AddFunction
    handle.def(
        "visitRefactoringOptionsImpl",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(clang::tooling::RefactoringOptionVisitor &)>::type>(
            &clang::tooling::internal::visitRefactoringOptionsImpl));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_visitRefactoringOptionsImpl(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_visitRefactoringOptionsImpl(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "visitRefactoringOptionsImpl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_visitRefactoringOptionsImpl

using Entity_visitRefactoringOptionsImpl = Bind_visitRefactoringOptionsImpl<>;

#else

struct Entity_visitRefactoringOptionsImpl
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_visitRefactoringOptionsImpl(EntityScope parent_h) {}
  static const char *Key() { return "visitRefactoringOptionsImpl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_visitRefactoringOptionsImpl

template <class Pybind11T = pybind11::module_ &>
struct Bind_isKnownPointerLikeType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Recognizes known types (and sugared versions thereof) that overload the `*`
// and `->` operator. Below is the list of currently included types, but it is
// subject to change:
//
// * std::unique_ptr, std::shared_ptr, std::weak_ptr,
// * std::optional, absl::optional, llvm::Optional,
// * absl::StatusOr, llvm::Expected.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_isKnownPointerLikeType_AddFunction
    handle.def("isKnownPointerLikeType",
               static_cast<pybind11_weaver::FnPtrT<
                   void, bool(clang::QualType, clang::ASTContext &)>::type>(
                   &clang::tooling::isKnownPointerLikeType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_isKnownPointerLikeType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_isKnownPointerLikeType(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "isKnownPointerLikeType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_isKnownPointerLikeType

using Entity_isKnownPointerLikeType = Bind_isKnownPointerLikeType<>;

#else

struct Entity_isKnownPointerLikeType : public pybind11_weaver::DisabledEntity {
  explicit Entity_isKnownPointerLikeType(EntityScope parent_h) {}
  static const char *Key() { return "isKnownPointerLikeType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_isKnownPointerLikeType

template <class Pybind11T = pybind11::module_ &>
struct Bind_isSelfContainedHeader : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns true if the given physical file is a self-contained header.
///
/// A header is considered self-contained if
//   - it has a proper header guard or has been #imported or contains #import(s)
//   - *and* it doesn't have a dont-include-me pattern.
///
/// This function can be expensive as it may scan the source code to find out
/// dont-include-me pattern heuristically.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_isSelfContainedHeader_AddFunction
    handle.def(
        "isSelfContainedHeader",
        static_cast<pybind11_weaver::FnPtrT<
            void, bool(const clang::FileEntry *, const clang::SourceManager &,
                       const clang::HeaderSearch &)>::type>(
            &clang::tooling::isSelfContainedHeader),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_isSelfContainedHeader(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_isSelfContainedHeader(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "isSelfContainedHeader"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_isSelfContainedHeader

using Entity_isSelfContainedHeader = Bind_isSelfContainedHeader<>;

#else

struct Entity_isSelfContainedHeader : public pybind11_weaver::DisabledEntity {
  explicit Entity_isSelfContainedHeader(EntityScope parent_h) {}
  static const char *Key() { return "isSelfContainedHeader"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_isSelfContainedHeader

template <class Pybind11T = pybind11::module_ &>
struct Bind_mayEverNeedParens : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Determines whether printing this expression in *any* expression requires
/// parentheses to preserve its meaning. This analyses is necessarily
/// conservative because it lacks information about the target context.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_mayEverNeedParens_AddFunction
    handle.def(
        "mayEverNeedParens",
        static_cast<
            pybind11_weaver::FnPtrT<void, bool(const clang::Expr &)>::type>(
            &clang::tooling::mayEverNeedParens),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_mayEverNeedParens(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_mayEverNeedParens(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "mayEverNeedParens"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_mayEverNeedParens

using Entity_mayEverNeedParens = Bind_mayEverNeedParens<>;

#else

struct Entity_mayEverNeedParens : public pybind11_weaver::DisabledEntity {
  explicit Entity_mayEverNeedParens(EntityScope parent_h) {}
  static const char *Key() { return "mayEverNeedParens"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_mayEverNeedParens

template <class Pybind11T = pybind11::module_ &>
struct Bind_maybeExtendRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Extends \p Range to include the token \p Terminator, if it immediately
/// follows the end of the range. Otherwise, returns \p Range unchanged.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_maybeExtendRange_AddFunction
    handle.def("maybeExtendRange",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::CharSourceRange(clang::CharSourceRange,
                                                clang::tok::TokenKind,
                                                clang::ASTContext &)>::type>(
                   &clang::tooling::maybeExtendRange),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_maybeExtendRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_maybeExtendRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "maybeExtendRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_maybeExtendRange

using Entity_maybeExtendRange = Bind_maybeExtendRange<>;

#else

struct Entity_maybeExtendRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_maybeExtendRange(EntityScope parent_h) {}
  static const char *Key() { return "maybeExtendRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_maybeExtendRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_needParensAfterUnaryOperator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Determines whether printing this expression to the right of a unary operator
/// requires a parentheses to preserve its meaning.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_needParensAfterUnaryOperator_AddFunction
    handle.def(
        "needParensAfterUnaryOperator",
        static_cast<
            pybind11_weaver::FnPtrT<void, bool(const clang::Expr &)>::type>(
            &clang::tooling::needParensAfterUnaryOperator),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_needParensAfterUnaryOperator(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_needParensAfterUnaryOperator(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "needParensAfterUnaryOperator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_needParensAfterUnaryOperator

using Entity_needParensAfterUnaryOperator = Bind_needParensAfterUnaryOperator<>;

#else

struct Entity_needParensAfterUnaryOperator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_needParensAfterUnaryOperator(EntityScope parent_h) {}
  static const char *Key() { return "needParensAfterUnaryOperator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_needParensAfterUnaryOperator

template <class Pybind11T = pybind11::module_ &>
struct Bind_needParensBeforeDotOrArrow : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Determines whether printing this expression to the left of a dot or arrow
/// operator requires a parentheses to preserve its meaning. Given that
/// dot/arrow are (effectively) the highest precedence, this is equivalent to
/// asking whether it ever needs parens.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_needParensBeforeDotOrArrow_AddFunction
    handle.def(
        "needParensBeforeDotOrArrow",
        static_cast<
            pybind11_weaver::FnPtrT<void, bool(const clang::Expr &)>::type>(
            &clang::tooling::needParensBeforeDotOrArrow),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_needParensBeforeDotOrArrow(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_needParensBeforeDotOrArrow(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "needParensBeforeDotOrArrow"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_needParensBeforeDotOrArrow

using Entity_needParensBeforeDotOrArrow = Bind_needParensBeforeDotOrArrow<>;

#else

struct Entity_needParensBeforeDotOrArrow
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_needParensBeforeDotOrArrow(EntityScope parent_h) {}
  static const char *Key() { return "needParensBeforeDotOrArrow"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_needParensBeforeDotOrArrow

template <class Pybind11T = pybind11::module_ &>
struct Bind_newInvocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Creates a \c CompilerInvocation.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_newInvocation_AddFunction
    handle.def(
        "newInvocation",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::CompilerInvocation *(clang::DiagnosticsEngine *,
                                              llvm::ArrayRef<const char *>,
                                              const char *const)>::type>(
            &clang::tooling::newInvocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_newInvocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_newInvocation(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "newInvocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_newInvocation

using Entity_newInvocation = Bind_newInvocation<>;

#else

struct Entity_newInvocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_newInvocation(EntityScope parent_h) {}
  static const char *Key() { return "newInvocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_newInvocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_parseIWYUPragma : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If Text begins an Include-What-You-Use directive, returns it.
/// Given "// IWYU pragma: keep", returns "keep".
/// Input is a null-terminated char* as provided by SM.getCharacterData().
/// (This should not be StringRef as we do *not* want to scan for its length).
/// For multi-line comments, we return only the first line.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_parseIWYUPragma_AddFunction
    handle.def("parseIWYUPragma",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::optional<llvm::StringRef>(const char *)>::type>(
                   &clang::tooling::parseIWYUPragma),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_parseIWYUPragma(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_parseIWYUPragma(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "parseIWYUPragma"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_parseIWYUPragma

using Entity_parseIWYUPragma = Bind_parseIWYUPragma<>;

#else

struct Entity_parseIWYUPragma : public pybind11_weaver::DisabledEntity {
  explicit Entity_parseIWYUPragma(EntityScope parent_h) {}
  static const char *Key() { return "parseIWYUPragma"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_parseIWYUPragma

template <class Pybind11T = pybind11::module_ &>
struct Bind_reallyIgnoreImplicit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \name Code analysis utilities.
/// @{
/// Ignores implicit object-construction expressions in addition to the normal
/// implicit expressions that are ignored.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_reallyIgnoreImplicit_AddFunction
    handle.def(
        "reallyIgnoreImplicit",
        [](const clang::Expr &E) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, const clang::Expr *(const clang::Expr &)>::type>(
                  &clang::tooling::reallyIgnoreImplicit),
              E);
          return pybind11_weaver::WrapP<const clang::Expr *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_reallyIgnoreImplicit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_reallyIgnoreImplicit(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "reallyIgnoreImplicit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_reallyIgnoreImplicit

using Entity_reallyIgnoreImplicit = Bind_reallyIgnoreImplicit<>;

#else

struct Entity_reallyIgnoreImplicit : public pybind11_weaver::DisabledEntity {
  explicit Entity_reallyIgnoreImplicit(EntityScope parent_h) {}
  static const char *Key() { return "reallyIgnoreImplicit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_reallyIgnoreImplicit

template <class Pybind11T = pybind11::module_ &>
struct Bind_replaceNestedName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Emulate a lookup to replace one nested name specifier with another using as
/// few additional namespace qualifications as possible.
///
/// This does not perform a full C++ lookup so ADL will not work.
///
/// \param Use The nested name to be replaced.
/// \param UseLoc The location of name to be replaced.
/// \param UseContext The context in which the nested name is contained. This
///                   will be used to minimize namespace qualifications.
/// \param FromDecl The declaration to which the nested name points.
/// \param ReplacementString The replacement nested name. Must be fully
///                          qualified including a leading "::".
/// \returns The new name to be inserted in place of the current nested name.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_replaceNestedName_AddFunction
    handle.def(
        "replaceNestedName",
        [](const clang::NestedNameSpecifier *Use, clang::SourceLocation UseLoc,
           const clang::DeclContext *UseContext,
           pybind11_weaver::WrappedPtrT<const clang::NamedDecl *> FromDecl,
           llvm::StringRef ReplacementString) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, std::basic_string<char>(
                            const clang::NestedNameSpecifier *,
                            clang::SourceLocation, const clang::DeclContext *,
                            const clang::NamedDecl *, llvm::StringRef)>::type>(
                  &clang::tooling::replaceNestedName),
              Use, UseLoc, UseContext, (FromDecl)->Cptr(), ReplacementString);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_replaceNestedName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_replaceNestedName(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "replaceNestedName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_replaceNestedName

using Entity_replaceNestedName = Bind_replaceNestedName<>;

#else

struct Entity_replaceNestedName : public pybind11_weaver::DisabledEntity {
  explicit Entity_replaceNestedName(EntityScope parent_h) {}
  static const char *Key() { return "replaceNestedName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_replaceNestedName

template <class Pybind11T = pybind11::enum_<clang::tooling::replacement_error>>
struct Bind_clang_tooling_replacement_error : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_replacement_error(EntityScope parent_h)
      : handle{parent_h, "replacement_error", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_replacement_error(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("fail_to_apply",
                 clang::tooling::replacement_error::fail_to_apply);
    handle.value("wrong_file_path",
                 clang::tooling::replacement_error::wrong_file_path);
    handle.value("overlap_conflict",
                 clang::tooling::replacement_error::overlap_conflict);
    handle.value("insert_conflict",
                 clang::tooling::replacement_error::insert_conflict);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_replacement_error"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_replacement_error

using Entity_clang_tooling_replacement_error =
    Bind_clang_tooling_replacement_error<>;

#else

struct Entity_clang_tooling_replacement_error
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_replacement_error(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_replacement_error"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_replacement_error

template <class Pybind11T = pybind11::module_ &>
struct Bind_runToolOnCode : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag.
///
/// \param ToolAction The action to run over the code.
/// \param Code C++ code.
/// \param FileName The file name which 'Code' will be mapped as.
/// \param PCHContainerOps  The PCHContainerOperations for loading and creating
///                         clang modules.
///
/// \return - True if 'ToolAction' was successfully executed.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_runToolOnCode_AddFunction
#ifndef PB11_WEAVER_DISABLE_runToolOnCode_AddFunction
    handle.def("runToolOnCode", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_runToolOnCode(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_runToolOnCode(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "runToolOnCode"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_runToolOnCode

using Entity_runToolOnCode = Bind_runToolOnCode<>;

#else

struct Entity_runToolOnCode : public pybind11_weaver::DisabledEntity {
  explicit Entity_runToolOnCode(EntityScope parent_h) {}
  static const char *Key() { return "runToolOnCode"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_runToolOnCode

template <class Pybind11T = pybind11::module_ &>
struct Bind_runToolOnCodeWithArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag and
///        with additional other flags.
///
/// \param ToolAction The action to run over the code.
/// \param Code C++ code.
/// \param Args Additional flags to pass on.
/// \param FileName The file name which 'Code' will be mapped as.
/// \param ToolName The name of the binary running the tool. Standard library
///                 header paths will be resolved relative to this.
/// \param PCHContainerOps   The PCHContainerOperations for loading and creating
///                          clang modules.
///
/// \return - True if 'ToolAction' was successfully executed.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_runToolOnCodeWithArgs_AddFunction
#ifndef PB11_WEAVER_DISABLE_runToolOnCodeWithArgs_AddFunction
    handle.def("runToolOnCodeWithArgs", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_runToolOnCodeWithArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_runToolOnCodeWithArgs(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "runToolOnCodeWithArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_runToolOnCodeWithArgs

using Entity_runToolOnCodeWithArgs = Bind_runToolOnCodeWithArgs<>;

#else

struct Entity_runToolOnCodeWithArgs : public pybind11_weaver::DisabledEntity {
  explicit Entity_runToolOnCodeWithArgs(EntityScope parent_h) {}
  static const char *Key() { return "runToolOnCodeWithArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_runToolOnCodeWithArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_runToolOnCodeWithArgs1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Similar to the overload except this takes a VFS.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_runToolOnCodeWithArgs1_AddFunction
#ifndef PB11_WEAVER_DISABLE_runToolOnCodeWithArgs1_AddFunction
    handle.def("runToolOnCodeWithArgs", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_runToolOnCodeWithArgs1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_runToolOnCodeWithArgs1(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "runToolOnCodeWithArgs1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_runToolOnCodeWithArgs1

using Entity_runToolOnCodeWithArgs1 = Bind_runToolOnCodeWithArgs1<>;

#else

struct Entity_runToolOnCodeWithArgs1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_runToolOnCodeWithArgs1(EntityScope parent_h) {}
  static const char *Key() { return "runToolOnCodeWithArgs1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_runToolOnCodeWithArgs1

template <class Pybind11T = pybind11::module_ &>
struct Bind_selectFirstFix : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Get the first fix to apply for this diagnostic.
/// \returns nullptr if no fixes are attached to the diagnostic.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_selectFirstFix_AddFunction
    handle.def("selectFirstFix",
               static_cast<pybind11_weaver::FnPtrT<
                   void, const llvm::StringMap<clang::tooling::Replacements> *(
                             const clang::tooling::Diagnostic &)>::type>(
                   &clang::tooling::selectFirstFix),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_selectFirstFix(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_selectFirstFix(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "selectFirstFix"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_selectFirstFix

using Entity_selectFirstFix = Bind_selectFirstFix<>;

#else

struct Entity_selectFirstFix : public pybind11_weaver::DisabledEntity {
  explicit Entity_selectFirstFix(EntityScope parent_h) {}
  static const char *Key() { return "selectFirstFix"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_selectFirstFix

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_stdlib : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_stdlib(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "stdlib")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_stdlib(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_stdlib"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib

using Entity_clang_tooling_stdlib = Bind_clang_tooling_stdlib<>;

#else

struct Entity_clang_tooling_stdlib : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_stdlib(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_stdlib"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib

template <class Pybind11T = pybind11::class_<clang::tooling::stdlib::Header>>
struct Bind_clang_tooling_stdlib_Header : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_all() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Header_all
    handle.def_static("all",
                      static_cast<pybind11_weaver::FnPtrT<
                          void, std::vector<clang::tooling::stdlib::Header>(
                                    clang::tooling::stdlib::Lang)>::type>(
                          &clang::tooling::stdlib::Header::all));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_named() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Name should contain the angle brackets, e.g. "<vector>".)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Header_named
    handle.def_static(
        "named",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::optional<clang::tooling::stdlib::Header>(
                      llvm::StringRef, clang::tooling::stdlib::Lang)>::type>(
            &clang::tooling::stdlib::Header::named),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_name() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Header_name
    handle.def(
        "name",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::stdlib::Header,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::stdlib::Header::name));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_stdlib_Header(EntityScope parent_h)
      : handle{parent_h, "Header", pybind11::dynamic_attr(),
               R"_pb11_weaver(// A standard library header, such as <iostream>
// Lightweight class, in fact just an index into a table.
// C++ and C Library compatibility headers are considered different: e.g.
// "<cstdio>" and "<stdio.h>" (and their symbols) are treated differently.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_stdlib_Header(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_all();
    AddMethod_named();
    AddMethod_name();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::stdlib::Header>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_stdlib_Header"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Header

using Entity_clang_tooling_stdlib_Header = Bind_clang_tooling_stdlib_Header<>;

#else

struct Entity_clang_tooling_stdlib_Header
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_stdlib_Header(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_stdlib_Header"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Header

template <class Pybind11T = pybind11::enum_<clang::tooling::stdlib::Lang>>
struct Bind_clang_tooling_stdlib_Lang : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_stdlib_Lang(EntityScope parent_h)
      : handle{parent_h, "Lang", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_stdlib_Lang(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("C", clang::tooling::stdlib::Lang::C);
    handle.value("CXX", clang::tooling::stdlib::Lang::CXX);
    handle.value("LastValue", clang::tooling::stdlib::Lang::LastValue);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_stdlib_Lang"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Lang

using Entity_clang_tooling_stdlib_Lang = Bind_clang_tooling_stdlib_Lang<>;

#else

struct Entity_clang_tooling_stdlib_Lang
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_stdlib_Lang(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_stdlib_Lang"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Lang

template <class Pybind11T =
              pybind11::class_<clang::tooling::stdlib::Recognizer>>
struct Bind_clang_tooling_stdlib_Recognizer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// A functor to find the stdlib::Symbol associated with a decl.
//
// For non-top-level decls (std::vector<int>::iterator), returns the top-level
// symbol (std::vector).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Recognizer_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_stdlib_Recognizer(EntityScope parent_h)
      : handle{
            parent_h, "Recognizer", pybind11::dynamic_attr(),
            R"_pb11_weaver(// A functor to find the stdlib::Symbol associated with a decl.
//
// For non-top-level decls (std::vector<int>::iterator), returns the top-level
// symbol (std::vector).)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_stdlib_Recognizer(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddCtor0(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_stdlib_Recognizer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Recognizer

using Entity_clang_tooling_stdlib_Recognizer =
    Bind_clang_tooling_stdlib_Recognizer<>;

#else

struct Entity_clang_tooling_stdlib_Recognizer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_stdlib_Recognizer(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_stdlib_Recognizer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Recognizer

template <class Pybind11T = pybind11::class_<clang::tooling::stdlib::Symbol>>
struct Bind_clang_tooling_stdlib_Symbol : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_all() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_all
    handle.def_static("all",
                      static_cast<pybind11_weaver::FnPtrT<
                          void, std::vector<clang::tooling::stdlib::Symbol>(
                                    clang::tooling::stdlib::Lang)>::type>(
                          &clang::tooling::stdlib::Symbol::all));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_named() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// \p Scope should have the trailing "::", for example:
  /// named("std::chrono::", "system_clock"))_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_named
    handle.def_static("named",
                      static_cast<pybind11_weaver::FnPtrT<
                          void, std::optional<clang::tooling::stdlib::Symbol>(
                                    llvm::StringRef, llvm::StringRef,
                                    clang::tooling::stdlib::Lang)>::type>(
                          &clang::tooling::stdlib::Symbol::named),
                      _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_scope() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_scope
    handle.def(
        "scope",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::stdlib::Symbol,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::stdlib::Symbol::scope));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_name() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_name
    handle.def(
        "name",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::stdlib::Symbol,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::stdlib::Symbol::name));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_qualifiedName() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_qualifiedName
    handle.def(
        "qualifiedName",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::stdlib::Symbol,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::stdlib::Symbol::qualifiedName));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_header() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// The preferred header for this symbol (e.g. the suggested insertion).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_header
    handle.def("header",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::stdlib::Symbol,
                   std::optional<clang::tooling::stdlib::Header>>::const_type>(
                   &clang::tooling::stdlib::Symbol::header),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_headers() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Some symbols may be provided by multiple headers.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_stdlib_Symbol_headers
    handle.def(
        "headers",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::stdlib::Symbol,
            llvm::SmallVector<clang::tooling::stdlib::Header, 6>>::const_type>(
            &clang::tooling::stdlib::Symbol::headers),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_stdlib_Symbol(EntityScope parent_h)
      : handle{
            parent_h, "Symbol", pybind11::dynamic_attr(),
            R"_pb11_weaver(// A top-level standard library symbol, such as std::vector
// Lightweight class, in fact just an index into a table.
// C++ and C Standard Library symbols are considered distinct: e.g. std::printf
// and ::printf are not treated as the same symbol.
// The symbols do not contain macros right now, we don't have a reliable index
// for them.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_stdlib_Symbol(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_all();
    AddMethod_named();
    AddMethod_scope();
    AddMethod_name();
    AddMethod_qualifiedName();
    AddMethod_header();
    AddMethod_headers();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::stdlib::Symbol>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_stdlib_Symbol"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Symbol

using Entity_clang_tooling_stdlib_Symbol = Bind_clang_tooling_stdlib_Symbol<>;

#else

struct Entity_clang_tooling_stdlib_Symbol
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_stdlib_Symbol(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_stdlib_Symbol"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_stdlib_Symbol

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_traits : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_traits(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "traits")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_traits(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_traits"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_traits

using Entity_clang_tooling_traits = Bind_clang_tooling_traits<>;

#else

struct Entity_clang_tooling_traits : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_traits(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_traits"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_traits

template <class Pybind11T = pybind11::module_>
struct Bind_clang_tooling_traits_internal : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_tooling_traits_internal(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "internal")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_traits_internal(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_traits_internal"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_traits_internal

using Entity_clang_tooling_traits_internal =
    Bind_clang_tooling_traits_internal<>;

#else

struct Entity_clang_tooling_traits_internal
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_traits_internal(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_traits_internal"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_traits_internal

template <class Pybind11T = pybind11::module_ &>
struct Bind_transferCompileCommand : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Transforms a compile command so that it applies the same configuration to
/// a different file. Most args are left intact, but tweaks may be needed
/// to certain flags (-x, -std etc).
///
/// The output command will always end in {"--", Filename}.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_transferCompileCommand_AddFunction
    handle.def(
        "transferCompileCommand",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::CompileCommand(clang::tooling::CompileCommand,
                                                 llvm::StringRef)>::type>(
            &clang::tooling::transferCompileCommand),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_transferCompileCommand(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_transferCompileCommand(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "transferCompileCommand"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_transferCompileCommand

using Entity_transferCompileCommand = Bind_transferCompileCommand<>;

#else

struct Entity_transferCompileCommand : public pybind11_weaver::DisabledEntity {
  explicit Entity_transferCompileCommand(EntityScope parent_h) {}
  static const char *Key() { return "transferCompileCommand"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_transferCompileCommand

template <class Pybind11T = pybind11::module_ &>
struct Bind_validateEditRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Determines whether \p Range is one that can be edited by a rewrite;
/// generally, one that starts and ends within a particular file.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_validateEditRange_AddFunction
    handle.def("validateEditRange",
               static_cast<pybind11_weaver::FnPtrT<
                   void, llvm::Error(const clang::CharSourceRange &,
                                     const clang::SourceManager &)>::type>(
                   &clang::tooling::validateEditRange),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_validateEditRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_validateEditRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "validateEditRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_validateEditRange

using Entity_validateEditRange = Bind_validateEditRange<>;

#else

struct Entity_validateEditRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_validateEditRange(EntityScope parent_h) {}
  static const char *Key() { return "validateEditRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_validateEditRange

template <class = void>
class PyTrampAllTUsToolExecutor : public clang::tooling::AllTUsToolExecutor {
public:
  using _PB11_WR_BaseT = clang::tooling::AllTUsToolExecutor;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorStringRef_9__const
  llvm::StringRef getExecutorName() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::AllTUsToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getExecutorName,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorllvm_Error_9llvm_ArrayRef6std_pair6std_unique_ptr6FrontendActionFactory9__ArgumentsAdjuster99_
  llvm::Error execute(
      llvm::ArrayRef<std::pair<
          std::unique_ptr<clang::tooling::FrontendActionFactory>,
          std::function<std::vector<std::basic_string<char>>(
              const std::vector<std::basic_string<char>> &, llvm::StringRef)>>>
          Actions) override {
    using _PB11_WR_RET_TYPE = llvm::Error;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::AllTUsToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, execute,
                      Actions);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorllvm_Error_9llvm_ArrayRef6std_pair6std_unique_ptr6FrontendActionFactory9__ArgumentsAdjuster99_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorExecutionContext__9_
  clang::tooling::ExecutionContext *getExecutionContext() override {
    using _PB11_WR_RET_TYPE = clang::tooling::ExecutionContext *;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::AllTUsToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getExecutionContext,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorExecutionContext__9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorToolResults__9_
  clang::tooling::ToolResults *getToolResults() override {
    using _PB11_WR_RET_TYPE = clang::tooling::ToolResults *;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::AllTUsToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getToolResults,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorToolResults__9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorvoid_9StringRef__StringRef_
  void mapVirtualFile(llvm::StringRef FilePath,
                      llvm::StringRef Content) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::AllTUsToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      mapVirtualFile, FilePath, Content);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_AllTUsToolExecutorvoid_9StringRef__StringRef_
};

template <class Pybind11T = pybind11::class_<clang::tooling::AllTUsToolExecutor,
                                             PyTrampAllTUsToolExecutor<>,
                                             clang::tooling::ToolExecutor>>
struct Bind_clang_tooling_AllTUsToolExecutor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getExecutorName() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_getExecutorName
    handle.def(
        "getExecutorName",
        static_cast<pybind11_weaver::FnPtrT<clang::tooling::AllTUsToolExecutor,
                                            llvm::StringRef>::const_type>(
            &clang::tooling::AllTUsToolExecutor::getExecutorName));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_execute() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_execute
#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_execute
    handle.def("execute", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getExecutionContext() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_getExecutionContext
    handle.def(
        "getExecutionContext",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::AllTUsToolExecutor,
                                    clang::tooling::ExecutionContext *>::type>(
            &clang::tooling::AllTUsToolExecutor::getExecutionContext));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getToolResults() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_getToolResults
    handle.def(
        "getToolResults",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::AllTUsToolExecutor,
                                    clang::tooling::ToolResults *>::type>(
            &clang::tooling::AllTUsToolExecutor::getToolResults));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_mapVirtualFile() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_mapVirtualFile
    handle.def(
        "mapVirtualFile",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::AllTUsToolExecutor, void,
                                    llvm::StringRef, llvm::StringRef>::type>(
            &clang::tooling::AllTUsToolExecutor::mapVirtualFile));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Executes given frontend actions on all files/TUs in the compilation
/// database.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_Ctor0
    handle.def(pybind11::init<const clang::tooling::CompilationDatabase &,
                              unsigned int,
                              std::shared_ptr<clang::PCHContainerOperations>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Executes given frontend actions on all files/TUs in the compilation
/// database.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_AllTUsToolExecutor_Ctor1
    handle.def(pybind11::init<clang::tooling::CommonOptionsParser, unsigned int,
                              std::shared_ptr<clang::PCHContainerOperations>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_AllTUsToolExecutor(EntityScope parent_h)
      : handle{
            parent_h, "AllTUsToolExecutor", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Executes given frontend actions on all files/TUs in the compilation
/// database.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_AllTUsToolExecutor(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getExecutorName();
    AddMethod_execute();
    AddMethod_getExecutionContext();
    AddMethod_getToolResults();
    AddMethod_mapVirtualFile();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_AllTUsToolExecutor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_AllTUsToolExecutor

using Entity_clang_tooling_AllTUsToolExecutor =
    Bind_clang_tooling_AllTUsToolExecutor<>;

#else

struct Entity_clang_tooling_AllTUsToolExecutor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_AllTUsToolExecutor(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_AllTUsToolExecutor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_AllTUsToolExecutor

template <class = void>
class PyTrampArgumentsAdjustingCompilations
    : public clang::tooling::ArgumentsAdjustingCompilations {
public:
  using _PB11_WR_BaseT = clang::tooling::ArgumentsAdjustingCompilations;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ArgumentsAdjustingCompilationsstd_vector6CompileCommand9_9StringRef__const
  std::vector<clang::tooling::CompileCommand>
  getCompileCommands(llvm::StringRef FilePath) const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::ArgumentsAdjustingCompilations;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getCompileCommands, FilePath);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ArgumentsAdjustingCompilationsstd_vector6CompileCommand9_9StringRef__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ArgumentsAdjustingCompilationsstd_vector6std_string9_9__const
  std::vector<std::basic_string<char>> getAllFiles() const override {
    using _PB11_WR_RET_TYPE = std::vector<std::basic_string<char>>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::ArgumentsAdjustingCompilations;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, getAllFiles,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ArgumentsAdjustingCompilationsstd_vector6std_string9_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_ArgumentsAdjustingCompilationsstd_vector6CompileCommand9_9__const
  std::vector<clang::tooling::CompileCommand>
  getAllCompileCommands() const override {
    using _PB11_WR_RET_TYPE = std::vector<clang::tooling::CompileCommand>;
    using _PB11_WR_CONCREATE_TYPE =
        clang::tooling::ArgumentsAdjustingCompilations;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getAllCompileCommands,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_ArgumentsAdjustingCompilationsstd_vector6CompileCommand9_9__const
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::ArgumentsAdjustingCompilations,
                               PyTrampArgumentsAdjustingCompilations<>,
                               clang::tooling::CompilationDatabase>>
struct Bind_clang_tooling_ArgumentsAdjustingCompilations : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_appendArgumentsAdjuster() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ArgumentsAdjustingCompilations_appendArgumentsAdjuster
    handle.def("appendArgumentsAdjuster",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ArgumentsAdjustingCompilations, void,
                   std::function<std::vector<std::basic_string<char>>(
                       const std::vector<std::basic_string<char>> &,
                       llvm::StringRef)>>::type>(
                   &clang::tooling::ArgumentsAdjustingCompilations::
                       appendArgumentsAdjuster));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getCompileCommands() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ArgumentsAdjustingCompilations_getCompileCommands
    handle.def("getCompileCommands",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ArgumentsAdjustingCompilations,
                   std::vector<clang::tooling::CompileCommand>,
                   llvm::StringRef>::const_type>(
                   &clang::tooling::ArgumentsAdjustingCompilations::
                       getCompileCommands));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAllFiles() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ArgumentsAdjustingCompilations_getAllFiles
    handle.def(
        "getAllFiles",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::ArgumentsAdjustingCompilations,
            std::vector<std::basic_string<char>>>::const_type>(
            &clang::tooling::ArgumentsAdjustingCompilations::getAllFiles));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getAllCompileCommands() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ArgumentsAdjustingCompilations_getAllCompileCommands
    handle.def("getAllCompileCommands",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ArgumentsAdjustingCompilations,
                   std::vector<clang::tooling::CompileCommand>>::const_type>(
                   &clang::tooling::ArgumentsAdjustingCompilations::
                       getAllCompileCommands));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_ArgumentsAdjustingCompilations_Ctor0
#ifndef PB11_WEAVER_DISABLE_clang_tooling_ArgumentsAdjustingCompilations_Ctor0
    handle.def(
        pybind11::init<std::unique_ptr<clang::tooling::CompilationDatabase>>());
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ArgumentsAdjustingCompilations(
      EntityScope parent_h)
      : handle{parent_h, "ArgumentsAdjustingCompilations",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ArgumentsAdjustingCompilations(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_appendArgumentsAdjuster();
    AddMethod_getCompileCommands();
    AddMethod_getAllFiles();
    AddMethod_getAllCompileCommands();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_ArgumentsAdjustingCompilations";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ArgumentsAdjustingCompilations

using Entity_clang_tooling_ArgumentsAdjustingCompilations =
    Bind_clang_tooling_ArgumentsAdjustingCompilations<>;

#else

struct Entity_clang_tooling_ArgumentsAdjustingCompilations
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ArgumentsAdjustingCompilations(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_ArgumentsAdjustingCompilations";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ArgumentsAdjustingCompilations

template <class Pybind11T =
              pybind11::class_<clang::tooling::ExtractFunction,
                               clang::tooling::SourceChangeRefactoringRule>>
struct Bind_clang_tooling_ExtractFunction : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_initiate() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Initiates the extract function refactoring operation.
  ///
  /// \param Code     The selected set of statements.
  /// \param DeclName The name of the extract function. If None,
  ///                 "extracted" is used.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExtractFunction_initiate
    handle.def_static(
        "initiate",
        static_cast<pybind11_weaver::FnPtrT<
            void, llvm::Expected<clang::tooling::ExtractFunction>(
                      clang::tooling::RefactoringRuleContext &,
                      clang::tooling::CodeRangeASTSelection,
                      std::optional<std::basic_string<char>>)>::type>(
            &clang::tooling::ExtractFunction::initiate),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_describe() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ExtractFunction_describe
    handle.def_static(
        "describe",
        static_cast<pybind11_weaver::FnPtrT<
            void, const clang::tooling::RefactoringDescriptor &()>::type>(
            &clang::tooling::ExtractFunction::describe));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ExtractFunction(EntityScope parent_h)
      : handle{
            parent_h, "ExtractFunction", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An "Extract Function" refactoring moves code into a new function that's
/// then called from the place where the original code was.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ExtractFunction(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_initiate();
    AddMethod_describe();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ExtractFunction>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ExtractFunction"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ExtractFunction

using Entity_clang_tooling_ExtractFunction =
    Bind_clang_tooling_ExtractFunction<>;

#else

struct Entity_clang_tooling_ExtractFunction
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ExtractFunction(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ExtractFunction"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ExtractFunction

template <class Pybind11T = pybind11::class_<
              clang::tooling::FindSymbolOccurrencesRefactoringRule,
              clang::tooling::RefactoringActionRuleBase>>
struct Bind_clang_tooling_FindSymbolOccurrencesRefactoringRule
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_invoke() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FindSymbolOccurrencesRefactoringRule_invoke
    handle.def(
        "invoke",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::FindSymbolOccurrencesRefactoringRule, void,
            clang::tooling::RefactoringResultConsumer &,
            clang::tooling::RefactoringRuleContext &>::type>(
            &clang::tooling::FindSymbolOccurrencesRefactoringRule::invoke));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_FindSymbolOccurrencesRefactoringRule(
      EntityScope parent_h)
      : handle{
            parent_h, "FindSymbolOccurrencesRefactoringRule",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A type of refactoring action rule that finds a set of symbol occurrences
/// that reference a particular symbol.
///
/// This action rule is typically used for an interactive rename that allows
/// users to specify the new name and the set of selected occurrences during
/// the refactoring.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_FindSymbolOccurrencesRefactoringRule(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_invoke();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::FindSymbolOccurrencesRefactoringRule>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_FindSymbolOccurrencesRefactoringRule";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_FindSymbolOccurrencesRefactoringRule

using Entity_clang_tooling_FindSymbolOccurrencesRefactoringRule =
    Bind_clang_tooling_FindSymbolOccurrencesRefactoringRule<>;

#else

struct Entity_clang_tooling_FindSymbolOccurrencesRefactoringRule
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_FindSymbolOccurrencesRefactoringRule(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_FindSymbolOccurrencesRefactoringRule";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_FindSymbolOccurrencesRefactoringRule

template <class = void>
class PyTrampFrontendActionFactory
    : public clang::tooling::FrontendActionFactory {
public:
  using _PB11_WR_BaseT = clang::tooling::FrontendActionFactory;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_FrontendActionFactorybool_9std_shared_ptr6CompilerInvocation9__FileManager____std_shared_ptr6PCHContainerOperations9__DiagnosticConsumer___
  bool
  runInvocation(std::shared_ptr<clang::CompilerInvocation> Invocation,
                clang::FileManager *Files,
                std::shared_ptr<clang::PCHContainerOperations> PCHContainerOps,
                clang::DiagnosticConsumer *DiagConsumer) override {
    using _PB11_WR_RET_TYPE = bool;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::FrontendActionFactory;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, runInvocation,
                      Invocation, Files, PCHContainerOps, DiagConsumer);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_FrontendActionFactorybool_9std_shared_ptr6CompilerInvocation9__FileManager____std_shared_ptr6PCHContainerOperations9__DiagnosticConsumer___

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_FrontendActionFactorystd_unique_ptr6FrontendAction9_9_
  std::unique_ptr<clang::FrontendAction> create() override {
    using _PB11_WR_RET_TYPE = std::unique_ptr<clang::FrontendAction>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::FrontendActionFactory;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, create,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_FrontendActionFactorystd_unique_ptr6FrontendAction9_9_
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::FrontendActionFactory,
              PyTrampFrontendActionFactory<>, clang::tooling::ToolAction>>
struct Bind_clang_tooling_FrontendActionFactory : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_runInvocation() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Invokes the compiler with a FrontendAction created by create().)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_FrontendActionFactory_runInvocation
    handle.def(
        "runInvocation",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::FrontendActionFactory, bool,
            std::shared_ptr<clang::CompilerInvocation>, clang::FileManager *,
            std::shared_ptr<clang::PCHContainerOperations>,
            clang::DiagnosticConsumer *>::type>(
            &clang::tooling::FrontendActionFactory::runInvocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_create() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns a new clang::FrontendAction.)_pb11_weaver";
#define PB11_WEAVER_DISABLE_clang_tooling_FrontendActionFactory_create
#ifndef PB11_WEAVER_DISABLE_clang_tooling_FrontendActionFactory_create
    handle.def("create", None, _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_FrontendActionFactory(EntityScope parent_h)
      : handle{parent_h, "FrontendActionFactory", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Interface to generate clang::FrontendActions.
///
/// Having a factory interface allows, for example, a new FrontendAction to be
/// created for each translation unit processed by ClangTool.  This class is
/// also a ToolAction which uses the FrontendActions created by create() to
/// process each translation unit.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_FrontendActionFactory(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_runInvocation();
    AddMethod_create();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::FrontendActionFactory>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_FrontendActionFactory"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_FrontendActionFactory

using Entity_clang_tooling_FrontendActionFactory =
    Bind_clang_tooling_FrontendActionFactory<>;

#else

struct Entity_clang_tooling_FrontendActionFactory
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_FrontendActionFactory(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_FrontendActionFactory"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_FrontendActionFactory

template <class = void>
class PyTrampInMemoryToolResults : public clang::tooling::InMemoryToolResults {
public:
  using _PB11_WR_BaseT = clang::tooling::InMemoryToolResults;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_InMemoryToolResultsvoid_9StringRef__StringRef_
  void addResult(llvm::StringRef Key, llvm::StringRef Value) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::InMemoryToolResults;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, addResult,
                      Key, Value);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_InMemoryToolResultsvoid_9StringRef__StringRef_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_InMemoryToolResultsstd_vector6std_pair6llvm_StringRef__llvm_StringRef99_9_
  std::vector<std::pair<llvm::StringRef, llvm::StringRef>>
  AllKVResults() override {
    using _PB11_WR_RET_TYPE =
        std::vector<std::pair<llvm::StringRef, llvm::StringRef>>;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::InMemoryToolResults;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, AllKVResults,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_InMemoryToolResultsstd_vector6std_pair6llvm_StringRef__llvm_StringRef99_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_InMemoryToolResultsvoid_9llvm_function_ref6void_9StringRef__StringRef_9_
  void forEachResult(llvm::function_ref<void(llvm::StringRef, llvm::StringRef)>
                         Callback) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::InMemoryToolResults;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, forEachResult,
                      Callback);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_InMemoryToolResultsvoid_9llvm_function_ref6void_9StringRef__StringRef_9_
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::InMemoryToolResults, PyTrampInMemoryToolResults<>,
              clang::tooling::ToolResults>>
struct Bind_clang_tooling_InMemoryToolResults : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_addResult() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_InMemoryToolResults_addResult
    handle.def(
        "addResult",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::InMemoryToolResults, void,
                                    llvm::StringRef, llvm::StringRef>::type>(
            &clang::tooling::InMemoryToolResults::addResult));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_AllKVResults() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_InMemoryToolResults_AllKVResults
    handle.def(
        "AllKVResults",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::InMemoryToolResults,
            std::vector<std::pair<llvm::StringRef, llvm::StringRef>>>::type>(
            &clang::tooling::InMemoryToolResults::AllKVResults));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_forEachResult() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_InMemoryToolResults_forEachResult
    handle.def(
        "forEachResult",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::InMemoryToolResults, void,
            llvm::function_ref<void(llvm::StringRef, llvm::StringRef)>>::type>(
            &clang::tooling::InMemoryToolResults::forEachResult));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Stores the key-value results in memory. It maintains the lifetime of
/// the result. Clang tools using this class are expected to generate a small
/// set of different results, or a large set of duplicated results.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_InMemoryToolResults_Ctor0
    handle.def(pybind11::init<>(), _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_InMemoryToolResults(EntityScope parent_h)
      : handle{parent_h, "InMemoryToolResults", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Stores the key-value results in memory. It maintains the lifetime of
/// the result. Clang tools using this class are expected to generate a small
/// set of different results, or a large set of duplicated results.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_InMemoryToolResults(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_addResult();
    AddMethod_AllKVResults();
    AddMethod_forEachResult();
    AddCtor0();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_InMemoryToolResults"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_InMemoryToolResults

using Entity_clang_tooling_InMemoryToolResults =
    Bind_clang_tooling_InMemoryToolResults<>;

#else

struct Entity_clang_tooling_InMemoryToolResults
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_InMemoryToolResults(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_InMemoryToolResults"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_InMemoryToolResults

template <class Pybind11T =
              pybind11::class_<clang::tooling::QualifiedRenameRule,
                               clang::tooling::SourceChangeRefactoringRule>>
struct Bind_clang_tooling_QualifiedRenameRule : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_initiate() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_QualifiedRenameRule_initiate
    handle.def_static(
        "initiate",
        static_cast<pybind11_weaver::FnPtrT<
            void, llvm::Expected<clang::tooling::QualifiedRenameRule>(
                      clang::tooling::RefactoringRuleContext &,
                      std::basic_string<char>, std::basic_string<char>)>::type>(
            &clang::tooling::QualifiedRenameRule::initiate));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_describe() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_QualifiedRenameRule_describe
    handle.def_static(
        "describe",
        static_cast<pybind11_weaver::FnPtrT<
            void, const clang::tooling::RefactoringDescriptor &()>::type>(
            &clang::tooling::QualifiedRenameRule::describe));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_QualifiedRenameRule(EntityScope parent_h)
      : handle{parent_h, "QualifiedRenameRule", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_QualifiedRenameRule(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_initiate();
    AddMethod_describe();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::QualifiedRenameRule>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_QualifiedRenameRule"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_QualifiedRenameRule

using Entity_clang_tooling_QualifiedRenameRule =
    Bind_clang_tooling_QualifiedRenameRule<>;

#else

struct Entity_clang_tooling_QualifiedRenameRule
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_QualifiedRenameRule(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_QualifiedRenameRule"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_QualifiedRenameRule

template <class = void>
class PyTrampRefactoringActionRule1
    : public clang::tooling::RefactoringActionRule {
public:
  using _PB11_WR_BaseT = clang::tooling::RefactoringActionRule;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRulevoid_9RefactoringResultConsumer____RefactoringRuleContext___
  void invoke(clang::tooling::RefactoringResultConsumer &Consumer,
              clang::tooling::RefactoringRuleContext &Context) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringActionRule;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, invoke,
                           Consumer, Context);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRulevoid_9RefactoringResultConsumer____RefactoringRuleContext___
};

template <class = void>
class PyTrampRefactoringActionRule : public PyTrampRefactoringActionRule1<> {
public:
  using _PB11_WR_BaseT = PyTrampRefactoringActionRule1<>;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRulebool_9_
  bool hasSelectionRequirement() override {
    using _PB11_WR_RET_TYPE = bool;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringActionRule;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           hasSelectionRequirement,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRulebool_9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRulevoid_9RefactoringOptionVisitor___
  void visitRefactoringOptions(
      clang::tooling::RefactoringOptionVisitor &Visitor) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::RefactoringActionRule;
    PYBIND11_OVERRIDE_PURE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                           visitRefactoringOptions, Visitor);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_RefactoringActionRulevoid_9RefactoringOptionVisitor___
};

template <class Pybind11T =
              pybind11::class_<clang::tooling::RefactoringActionRule,
                               PyTrampRefactoringActionRule<>,
                               clang::tooling::RefactoringActionRuleBase>>
struct Bind_clang_tooling_RefactoringActionRule : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_hasSelectionRequirement() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns true when the rule has a source selection requirement that has
  /// to be fulfilled before refactoring can be performed.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringActionRule_hasSelectionRequirement
    handle.def(
        "hasSelectionRequirement",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::RefactoringActionRule, bool>::type>(
            &clang::tooling::RefactoringActionRule::hasSelectionRequirement),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_visitRefactoringOptions() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Traverses each refactoring option used by the rule and invokes the
  /// \c visit callback in the consumer for each option.
  ///
  /// Options are visited in the order of use, e.g. if a rule has two
  /// requirements that use options, the options from the first requirement
  /// are visited before the options in the second requirement.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RefactoringActionRule_visitRefactoringOptions
    handle.def(
        "visitRefactoringOptions",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::RefactoringActionRule, void,
            clang::tooling::RefactoringOptionVisitor &>::type>(
            &clang::tooling::RefactoringActionRule::visitRefactoringOptions),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RefactoringActionRule(EntityScope parent_h)
      : handle{
            parent_h, "RefactoringActionRule", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A refactoring action rule is a wrapper class around a specific refactoring
/// action rule (SourceChangeRefactoringRule, etc) that, in addition to invoking
/// the action, describes the requirements that determine when the action can be
/// initiated.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RefactoringActionRule(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_hasSelectionRequirement();
    AddMethod_visitRefactoringOptions();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::RefactoringActionRule>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RefactoringActionRule"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringActionRule

using Entity_clang_tooling_RefactoringActionRule =
    Bind_clang_tooling_RefactoringActionRule<>;

#else

struct Entity_clang_tooling_RefactoringActionRule
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RefactoringActionRule(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RefactoringActionRule"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RefactoringActionRule

template <class Pybind11T =
              pybind11::class_<clang::tooling::RenameOccurrences,
                               clang::tooling::SourceChangeRefactoringRule>>
struct Bind_clang_tooling_RenameOccurrences : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_initiate() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RenameOccurrences_initiate
    handle.def_static(
        "initiate",
        static_cast<pybind11_weaver::FnPtrT<
            void, llvm::Expected<clang::tooling::RenameOccurrences>(
                      clang::tooling::RefactoringRuleContext &,
                      clang::SourceRange, std::basic_string<char>)>::type>(
            &clang::tooling::RenameOccurrences::initiate));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_describe() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RenameOccurrences_describe
    handle.def_static(
        "describe",
        static_cast<pybind11_weaver::FnPtrT<
            void, const clang::tooling::RefactoringDescriptor &()>::type>(
            &clang::tooling::RenameOccurrences::describe));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getRenameDecl() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_RenameOccurrences_getRenameDecl
    handle.def("getRenameDecl", [](clang::tooling::RenameOccurrences &self) {
      auto &&__ret__ = std::invoke(
          static_cast<
              pybind11_weaver::FnPtrT<clang::tooling::RenameOccurrences,
                                      const clang::NamedDecl *>::const_type>(
              &clang::tooling::RenameOccurrences::getRenameDecl),
          &self);
      return pybind11_weaver::WrapP<const clang::NamedDecl *>(__ret__);
    });
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_RenameOccurrences(EntityScope parent_h)
      : handle{parent_h, "RenameOccurrences", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_RenameOccurrences(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_initiate();
    AddMethod_describe();
    AddMethod_getRenameDecl();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::RenameOccurrences>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_RenameOccurrences"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_RenameOccurrences

using Entity_clang_tooling_RenameOccurrences =
    Bind_clang_tooling_RenameOccurrences<>;

#else

struct Entity_clang_tooling_RenameOccurrences
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_RenameOccurrences(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_RenameOccurrences"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_RenameOccurrences

template <class Pybind11T =
              pybind11::class_<clang::tooling::SourceRangeSelectionRequirement,
                               clang::tooling::SourceSelectionRequirement>>
struct Bind_clang_tooling_SourceRangeSelectionRequirement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_evaluate() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_SourceRangeSelectionRequirement_evaluate
    handle.def("evaluate",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::SourceRangeSelectionRequirement,
                   llvm::Expected<clang::SourceRange>,
                   clang::tooling::RefactoringRuleContext &>::const_type>(
                   &clang::tooling::SourceRangeSelectionRequirement::evaluate));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_SourceRangeSelectionRequirement(
      EntityScope parent_h)
      : handle{
            parent_h, "SourceRangeSelectionRequirement",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A selection requirement that is satisfied when any portion of the source
/// text is selected.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_SourceRangeSelectionRequirement(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_evaluate();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::SourceRangeSelectionRequirement>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_SourceRangeSelectionRequirement";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceRangeSelectionRequirement

using Entity_clang_tooling_SourceRangeSelectionRequirement =
    Bind_clang_tooling_SourceRangeSelectionRequirement<>;

#else

struct Entity_clang_tooling_SourceRangeSelectionRequirement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_SourceRangeSelectionRequirement(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_SourceRangeSelectionRequirement";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_SourceRangeSelectionRequirement

template <class = void>
class PyTrampStandaloneToolExecutor
    : public clang::tooling::StandaloneToolExecutor {
public:
  using _PB11_WR_BaseT = clang::tooling::StandaloneToolExecutor;
  using _PB11_WR_BaseT::_PB11_WR_BaseT;

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorStringRef_9__const
  llvm::StringRef getExecutorName() const override {
    using _PB11_WR_RET_TYPE = llvm::StringRef;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::StandaloneToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getExecutorName,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorStringRef_9__const

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorllvm_Error_9llvm_ArrayRef6std_pair6std_unique_ptr6FrontendActionFactory9__ArgumentsAdjuster99_
  llvm::Error execute(
      llvm::ArrayRef<std::pair<
          std::unique_ptr<clang::tooling::FrontendActionFactory>,
          std::function<std::vector<std::basic_string<char>>(
              const std::vector<std::basic_string<char>> &, llvm::StringRef)>>>
          Actions) override {
    using _PB11_WR_RET_TYPE = llvm::Error;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::StandaloneToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE, execute,
                      Actions);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorllvm_Error_9llvm_ArrayRef6std_pair6std_unique_ptr6FrontendActionFactory9__ArgumentsAdjuster99_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorExecutionContext__9_
  clang::tooling::ExecutionContext *getExecutionContext() override {
    using _PB11_WR_RET_TYPE = clang::tooling::ExecutionContext *;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::StandaloneToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getExecutionContext,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorExecutionContext__9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorToolResults__9_
  clang::tooling::ToolResults *getToolResults() override {
    using _PB11_WR_RET_TYPE = clang::tooling::ToolResults *;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::StandaloneToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      getToolResults,

    );
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorToolResults__9_

#ifndef PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorvoid_9StringRef__StringRef_
  void mapVirtualFile(llvm::StringRef FilePath,
                      llvm::StringRef Content) override {
    using _PB11_WR_RET_TYPE = void;
    using _PB11_WR_CONCREATE_TYPE = clang::tooling::StandaloneToolExecutor;
    PYBIND11_OVERRIDE(_PB11_WR_RET_TYPE, _PB11_WR_CONCREATE_TYPE,
                      mapVirtualFile, FilePath, Content);
  }
#endif // PYBIND11_DISABLE_OVERRIDE_clang_tooling_StandaloneToolExecutorvoid_9StringRef__StringRef_
};

template <class Pybind11T = pybind11::class_<
              clang::tooling::StandaloneToolExecutor,
              PyTrampStandaloneToolExecutor<>, clang::tooling::ToolExecutor>>
struct Bind_clang_tooling_StandaloneToolExecutor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_getExecutorName() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_getExecutorName
    handle.def(
        "getExecutorName",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::StandaloneToolExecutor,
                                    llvm::StringRef>::const_type>(
            &clang::tooling::StandaloneToolExecutor::getExecutorName));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_execute() {

    const char *_pb11_weaver_comment_str = nullptr;
#define PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_execute
#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_execute
    handle.def("execute", None);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_setDiagnosticConsumer() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Set a \c DiagnosticConsumer to use during parsing.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_setDiagnosticConsumer
    handle.def(
        "setDiagnosticConsumer",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::StandaloneToolExecutor,
                                    void, clang::DiagnosticConsumer *>::type>(
            &clang::tooling::StandaloneToolExecutor::setDiagnosticConsumer),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getExecutionContext() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_getExecutionContext
    handle.def(
        "getExecutionContext",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::StandaloneToolExecutor,
                                    clang::tooling::ExecutionContext *>::type>(
            &clang::tooling::StandaloneToolExecutor::getExecutionContext));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getToolResults() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_getToolResults
    handle.def(
        "getToolResults",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::StandaloneToolExecutor,
                                    clang::tooling::ToolResults *>::type>(
            &clang::tooling::StandaloneToolExecutor::getToolResults));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getSourcePaths() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_getSourcePaths
    handle.def("getSourcePaths",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::StandaloneToolExecutor,
                   llvm::ArrayRef<std::basic_string<char>>>::const_type>(
                   &clang::tooling::StandaloneToolExecutor::getSourcePaths));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_mapVirtualFile() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_mapVirtualFile
    handle.def("mapVirtualFile",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::StandaloneToolExecutor, void,
                   llvm::StringRef, llvm::StringRef>::type>(
                   &clang::tooling::StandaloneToolExecutor::mapVirtualFile));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getFiles() {

    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the file manager used in the tool.
  ///
  /// The file manager is shared between all translation units.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_getFiles
    handle.def(
        "getFiles",
        static_cast<
            pybind11_weaver::FnPtrT<clang::tooling::StandaloneToolExecutor,
                                    clang::FileManager &>::type>(
            &clang::tooling::StandaloneToolExecutor::getFiles),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A standalone executor that runs FrontendActions on a given set of
/// TUs in sequence.
///
/// By default, this executor uses the following arguments adjusters (as defined
/// in `clang/Tooling/ArgumentsAdjusters.h`):
///   - `getClangStripOutputAdjuster()`
///   - `getClangSyntaxOnlyAdjuster()`
///   - `getClangStripDependencyFileAdjuster()`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_Ctor0
    handle.def(pybind11::init<const clang::tooling::CompilationDatabase &,
                              llvm::ArrayRef<std::basic_string<char>>,
                              llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>,
                              std::shared_ptr<clang::PCHContainerOperations>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// A standalone executor that runs FrontendActions on a given set of
/// TUs in sequence.
///
/// By default, this executor uses the following arguments adjusters (as defined
/// in `clang/Tooling/ArgumentsAdjusters.h`):
///   - `getClangStripOutputAdjuster()`
///   - `getClangSyntaxOnlyAdjuster()`
///   - `getClangStripDependencyFileAdjuster()`)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tooling_StandaloneToolExecutor_Ctor1
    handle.def(pybind11::init<clang::tooling::CommonOptionsParser,
                              std::shared_ptr<clang::PCHContainerOperations>>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_StandaloneToolExecutor(EntityScope parent_h)
      : handle{
            parent_h, "StandaloneToolExecutor", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A standalone executor that runs FrontendActions on a given set of
/// TUs in sequence.
///
/// By default, this executor uses the following arguments adjusters (as defined
/// in `clang/Tooling/ArgumentsAdjusters.h`):
///   - `getClangStripOutputAdjuster()`
///   - `getClangSyntaxOnlyAdjuster()`
///   - `getClangStripDependencyFileAdjuster()`)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_StandaloneToolExecutor(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getExecutorName();
    AddMethod_execute();
    AddMethod_setDiagnosticConsumer();
    AddMethod_getExecutionContext();
    AddMethod_getToolResults();
    AddMethod_getSourcePaths();
    AddMethod_mapVirtualFile();
    AddMethod_getFiles();
    AddCtor0();
    AddCtor1();
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_StandaloneToolExecutor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_StandaloneToolExecutor

using Entity_clang_tooling_StandaloneToolExecutor =
    Bind_clang_tooling_StandaloneToolExecutor<>;

#else

struct Entity_clang_tooling_StandaloneToolExecutor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_StandaloneToolExecutor(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_StandaloneToolExecutor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_StandaloneToolExecutor

template <class Pybind11T =
              pybind11::class_<clang::tooling::ASTSelectionRequirement,
                               clang::tooling::SourceRangeSelectionRequirement>>
struct Bind_clang_tooling_ASTSelectionRequirement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_evaluate() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_ASTSelectionRequirement_evaluate
    handle.def("evaluate",
               static_cast<pybind11_weaver::FnPtrT<
                   clang::tooling::ASTSelectionRequirement,
                   llvm::Expected<clang::tooling::SelectedASTNode>,
                   clang::tooling::RefactoringRuleContext &>::const_type>(
                   &clang::tooling::ASTSelectionRequirement::evaluate));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_ASTSelectionRequirement(EntityScope parent_h)
      : handle{
            parent_h, "ASTSelectionRequirement", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// An AST selection requirement is satisfied when any portion of the AST
/// overlaps with the selection range.
///
/// The requirement will be evaluated only once during the initiation and
/// search of matching refactoring action rules.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_ASTSelectionRequirement(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_evaluate();
    pybind11_weaver::TryAddDefaultCtor<clang::tooling::ASTSelectionRequirement>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tooling_ASTSelectionRequirement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_ASTSelectionRequirement

using Entity_clang_tooling_ASTSelectionRequirement =
    Bind_clang_tooling_ASTSelectionRequirement<>;

#else

struct Entity_clang_tooling_ASTSelectionRequirement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_ASTSelectionRequirement(EntityScope parent_h) {}
  static const char *Key() { return "clang_tooling_ASTSelectionRequirement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_ASTSelectionRequirement

template <class Pybind11T =
              pybind11::class_<clang::tooling::CodeRangeASTSelectionRequirement,
                               clang::tooling::ASTSelectionRequirement>>
struct Bind_clang_tooling_CodeRangeASTSelectionRequirement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_evaluate() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_tooling_CodeRangeASTSelectionRequirement_evaluate
    handle.def(
        "evaluate",
        static_cast<pybind11_weaver::FnPtrT<
            clang::tooling::CodeRangeASTSelectionRequirement,
            llvm::Expected<clang::tooling::CodeRangeASTSelection>,
            clang::tooling::RefactoringRuleContext &>::const_type>(
            &clang::tooling::CodeRangeASTSelectionRequirement::evaluate));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tooling_CodeRangeASTSelectionRequirement(
      EntityScope parent_h)
      : handle{
            parent_h, "CodeRangeASTSelectionRequirement",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// A selection requirement that is satisfied when the selection range overlaps
/// with a number of neighbouring statements in the AST. The statemenst must be
/// contained in declaration like a function. The selection range must be a
/// non-empty source selection (i.e. cursors won't be accepted).
///
/// The requirement will be evaluated only once during the initiation and search
/// of matching refactoring action rules.
///
/// \see CodeRangeASTSelection)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tooling_CodeRangeASTSelectionRequirement(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_evaluate();
    pybind11_weaver::TryAddDefaultCtor<
        clang::tooling::CodeRangeASTSelectionRequirement>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_tooling_CodeRangeASTSelectionRequirement";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tooling_CodeRangeASTSelectionRequirement

using Entity_clang_tooling_CodeRangeASTSelectionRequirement =
    Bind_clang_tooling_CodeRangeASTSelectionRequirement<>;

#else

struct Entity_clang_tooling_CodeRangeASTSelectionRequirement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tooling_CodeRangeASTSelectionRequirement(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_tooling_CodeRangeASTSelectionRequirement";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tooling_CodeRangeASTSelectionRequirement

template <class Pybind11T = pybind11::module_>
struct Bind_clang_transformer : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "transformer")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer

using Entity_clang_transformer = Bind_clang_transformer<>;

#else

struct Entity_clang_transformer : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer

template <class Pybind11T = pybind11::class_<clang::transformer::ASTEdit>>
struct Bind_clang_transformer_ASTEdit : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_ASTEdit(EntityScope parent_h)
      : handle{
            parent_h, "ASTEdit", pybind11::dynamic_attr(),
            R"_pb11_weaver(// Description of a source-code edit, expressed in terms of an AST node.
// Includes: an ID for the (bound) node, a selector for source related to the
// node, a replacement and, optionally, an explanation for the edit.
//
// * Target: the source code impacted by the rule. This identifies an AST node,
//   or part thereof (\c Part), whose source range indicates the extent of the
//   replacement applied by the replacement term.  By default, the extent is the
//   node matched by the pattern term (\c NodePart::Node). Target's are typed
//   (\c Kind), which guides the determination of the node extent.
//
// * Replacement: a function that produces a replacement string for the target,
//   based on the match result.
//
// * Note: (optional) a note specifically for this edit, potentially referencing
//   elements of the match.  This will be displayed to the user, where possible;
//   for example, in clang-tidy diagnostics.  Use of notes should be rare --
//   explanations of the entire rewrite should be set in the rule
//   (`RewriteRule::Explanation`) instead.  Notes serve the rare cases wherein
//   edit-specific diagnostics are required.
//
// `ASTEdit` should be built using the `change` convenience functions. For
// example,
// \code
//   changeTo(name(fun), cat("Frodo"))
// \endcode
// Or, if we use Stencil for the TextGenerator:
// \code
//   using stencil::cat;
//   changeTo(statement(thenNode), cat("{", thenNode, "}"))
//   changeTo(callArgs(call), cat(x, ",", y))
// \endcode
// Or, if you are changing the node corresponding to the rule's matcher, you can
// use the single-argument override of \c change:
// \code
//   changeTo(cat("different_expr"))
// \endcode)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_ASTEdit(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::transformer::ASTEdit>(handle);
    handle.def_readwrite("Kind", &clang::transformer::ASTEdit::Kind);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_ASTEdit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_ASTEdit

using Entity_clang_transformer_ASTEdit = Bind_clang_transformer_ASTEdit<>;

#else

struct Entity_clang_transformer_ASTEdit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_ASTEdit(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_ASTEdit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_ASTEdit

template <class Pybind11T = pybind11::class_<clang::transformer::Edit>>
struct Bind_clang_transformer_Edit : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_Edit(EntityScope parent_h)
      : handle{parent_h, "Edit", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// A concrete description of a source edit, represented by a character range in
/// the source to be replaced and a corresponding replacement string.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_Edit(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::transformer::Edit>(handle);
    handle.def_readwrite("Kind", &clang::transformer::Edit::Kind);
    handle.def_readwrite("Replacement", &clang::transformer::Edit::Replacement);
    handle.def_readwrite("Note", &clang::transformer::Edit::Note);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_Edit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_Edit

using Entity_clang_transformer_Edit = Bind_clang_transformer_Edit<>;

#else

struct Entity_clang_transformer_Edit : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_Edit(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_Edit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_Edit

template <class Pybind11T = pybind11::enum_<clang::transformer::EditKind>>
struct Bind_clang_transformer_EditKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_EditKind(EntityScope parent_h)
      : handle{
            parent_h, "EditKind", pybind11::arithmetic(),
            R"_pb11_weaver(// Specifies how to interpret an edit.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_EditKind(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "Range", clang::transformer::EditKind::Range,
        R"_pb11_weaver(// Edits a source range in the file.)_pb11_weaver");
    handle.value(
        "AddInclude", clang::transformer::EditKind::AddInclude,
        R"_pb11_weaver(// Inserts an include in the file. The `Replacement` field is the name of the
  // newly included file.)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_EditKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_EditKind

using Entity_clang_transformer_EditKind = Bind_clang_transformer_EditKind<>;

#else

struct Entity_clang_transformer_EditKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_EditKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_EditKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_EditKind

template <class Pybind11T = pybind11::enum_<clang::transformer::IncludeFormat>>
struct Bind_clang_transformer_IncludeFormat : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_IncludeFormat(EntityScope parent_h)
      : handle{parent_h, "IncludeFormat", pybind11::arithmetic(),
               R"_pb11_weaver(/// Format of the path in an include directive -- angle brackets or quotes.)_pb11_weaver"} {
  }

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_IncludeFormat(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("Quoted", clang::transformer::IncludeFormat::Quoted);
    handle.value("Angled", clang::transformer::IncludeFormat::Angled);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_IncludeFormat"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_IncludeFormat

using Entity_clang_transformer_IncludeFormat =
    Bind_clang_transformer_IncludeFormat<>;

#else

struct Entity_clang_transformer_IncludeFormat
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_IncludeFormat(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_IncludeFormat"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_IncludeFormat

template <class Pybind11T =
              pybind11::class_<clang::transformer::RewriteRuleBase>>
struct Bind_clang_transformer_RewriteRuleBase : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_RewriteRuleBase(EntityScope parent_h)
      : handle{parent_h, "RewriteRuleBase", pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Description of a source-code transformation.
//
// A *rewrite rule* describes a transformation of source code. A simple rule
// contains each of the following components:
//
// * Matcher: the pattern term, expressed as clang matchers (with Transformer
//   extensions).
//
// * Edits: a set of Edits to the source code, described with ASTEdits.
//
// However, rules can also consist of (sub)rules, where the first that matches
// is applied and the rest are ignored.  So, the above components together form
// a logical "case" and a rule is a sequence of cases.
//
// Rule cases have an additional, implicit, component: the parameters. These are
// portions of the pattern which are left unspecified, yet bound in the pattern
// so that we can reference them in the edits.
//
// The \c Transformer class can be used to apply the rewrite rule and obtain the
// corresponding replacements.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_RewriteRuleBase(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<clang::transformer::RewriteRuleBase>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_RewriteRuleBase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_RewriteRuleBase

using Entity_clang_transformer_RewriteRuleBase =
    Bind_clang_transformer_RewriteRuleBase<>;

#else

struct Entity_clang_transformer_RewriteRuleBase
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_RewriteRuleBase(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_RewriteRuleBase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_RewriteRuleBase

template <class Pybind11T =
              pybind11::class_<clang::transformer::RewriteRuleBase::Case>>
struct Bind_clang_transformer_RewriteRuleBase_Case : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_RewriteRuleBase_Case(EntityScope parent_h)
      : handle{parent_h, "Case", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_RewriteRuleBase_Case(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::transformer::RewriteRuleBase::Case>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_RewriteRuleBase_Case"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_RewriteRuleBase_Case

using Entity_clang_transformer_RewriteRuleBase_Case =
    Bind_clang_transformer_RewriteRuleBase_Case<>;

#else

struct Entity_clang_transformer_RewriteRuleBase_Case
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_RewriteRuleBase_Case(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_transformer_RewriteRuleBase_Case"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_RewriteRuleBase_Case

template <class Pybind11T =
              pybind11::class_<clang::transformer::RewriteRuleWith<void>,
                               clang::transformer::RewriteRuleBase>>
struct Bind_clang_transformer_RewriteRuleWith6void9 : public EntityBase {
  using Pybind11Type = Pybind11T;
  using MetadataT = void;

  explicit Bind_clang_transformer_RewriteRuleWith6void9(EntityScope parent_h)
      : handle{parent_h, "RewriteRuleWith6void9", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_RewriteRuleWith6void9(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        clang::transformer::RewriteRuleWith<void>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_RewriteRuleWith6void9"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_RewriteRuleWith6void9

using Entity_clang_transformer_RewriteRuleWith6void9 =
    Bind_clang_transformer_RewriteRuleWith6void9<>;

#else

struct Entity_clang_transformer_RewriteRuleWith6void9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_RewriteRuleWith6void9(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_RewriteRuleWith6void9"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_RewriteRuleWith6void9

template <class Pybind11T = pybind11::module_ &>
struct Bind_access : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Constructs a `MemberExpr` that accesses the named member (\p Member) of the
/// object bound to \p BaseId. The access is constructed idiomatically: if \p
/// BaseId is bound to `e` and \p Member identifies member `m`, then returns
/// `e->m`, when e is a pointer, `e2->m` when e = `*e2` and `e.m` otherwise.
/// Additionally, `e` is wrapped in parentheses, if needed.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_access_AddFunction
    handle.def(
        "access",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      llvm::StringRef,
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>)>::type>(
            &clang::transformer::access),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_access(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_access(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "access"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_access

using Entity_access = Bind_access<>;

#else

struct Entity_access : public pybind11_weaver::DisabledEntity {
  explicit Entity_access(EntityScope parent_h) {}
  static const char *Key() { return "access"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_access

template <class Pybind11T = pybind11::module_ &>
struct Bind_access1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_access1_AddFunction
    handle.def("access",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef,
                                                       llvm::StringRef)>::type>(
                   &clang::transformer::access));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_access1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_access1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "access1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_access1

using Entity_access1 = Bind_access1<>;

#else

struct Entity_access1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_access1(EntityScope parent_h) {}
  static const char *Key() { return "access1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_access1

template <class Pybind11T = pybind11::module_ &>
struct Bind_addInclude : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds an include directive for the given header to the file of `Target`. The
/// particular location specified by `Target` is ignored.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_addInclude_AddFunction
    handle.def(
        "addInclude",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::ASTEdit(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                llvm::StringRef, clang::transformer::IncludeFormat)>::type>(
            &clang::transformer::addInclude),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_addInclude(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_addInclude(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "addInclude"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_addInclude

using Entity_addInclude = Bind_addInclude<>;

#else

struct Entity_addInclude : public pybind11_weaver::DisabledEntity {
  explicit Entity_addInclude(EntityScope parent_h) {}
  static const char *Key() { return "addInclude"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_addInclude

template <class Pybind11T = pybind11::module_ &>
struct Bind_addInclude2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// For every case in Rule, adds an include directive for the given header. The
/// common use is assumed to be a rule with only one case. For example, to
/// replace a function call and add headers corresponding to the new code, one
/// could write:
/// \code
///   auto R = makeRule(callExpr(callee(functionDecl(hasName("foo")))),
///            changeTo(cat("bar()")));
///   addInclude(R, "path/to/bar_header.h");
///   addInclude(R, "vector", IncludeFormat::Angled);
/// \endcode)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_addInclude2_AddFunction
    handle.def(
        "addInclude",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(clang::transformer::RewriteRuleBase &, llvm::StringRef,
                       clang::transformer::IncludeFormat)>::type>(
            &clang::transformer::addInclude),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_addInclude2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_addInclude2(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "addInclude2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_addInclude2

using Entity_addInclude2 = Bind_addInclude2<>;

#else

struct Entity_addInclude2 : public pybind11_weaver::DisabledEntity {
  explicit Entity_addInclude2(EntityScope parent_h) {}
  static const char *Key() { return "addInclude2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_addInclude2

template <class Pybind11T = pybind11::module_ &>
struct Bind_addInclude1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Adds an include directive for the given header to the file associated with
/// `RootID`. If `RootID` matches inside a macro expansion, will add the
/// directive to the file in which the macro was expanded (as opposed to the
/// file in which the macro is defined).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_addInclude1_AddFunction
    handle.def("addInclude",
               static_cast<pybind11_weaver::FnPtrT<
                   void, clang::transformer::ASTEdit(
                             llvm::StringRef,
                             clang::transformer::IncludeFormat)>::type>(
                   &clang::transformer::addInclude),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_addInclude1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_addInclude1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "addInclude1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_addInclude1

using Entity_addInclude1 = Bind_addInclude1<>;

#else

struct Entity_addInclude1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_addInclude1(EntityScope parent_h) {}
  static const char *Key() { return "addInclude1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_addInclude1

template <class Pybind11T = pybind11::module_ &>
struct Bind_addressOf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Constructs an expression that idiomatically takes the address of the
/// expression bound to \p ExprId. \p ExprId is wrapped in parentheses, if
/// needed.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_addressOf_AddFunction
    handle.def("addressOf",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::addressOf),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_addressOf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_addressOf(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "addressOf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_addressOf

using Entity_addressOf = Bind_addressOf<>;

#else

struct Entity_addressOf : public pybind11_weaver::DisabledEntity {
  explicit Entity_addressOf(EntityScope parent_h) {}
  static const char *Key() { return "addressOf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_addressOf

template <class Pybind11T = pybind11::module_ &>
struct Bind_after : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects the point immediately following \p Selector. That is, the
/// (empty) range [E,E), when \p Selector selects either
/// * the CharRange [B,E) or
/// * the TokenRange [B,E'] where the token at E' spans the range [E',E).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_after_AddFunction
    handle.def(
        "after",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::function<llvm::Expected<clang::CharSourceRange>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(&clang::transformer::after),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_after(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_after(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "after"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_after

using Entity_after = Bind_after<>;

#else

struct Entity_after : public pybind11_weaver::DisabledEntity {
  explicit Entity_after(EntityScope parent_h) {}
  static const char *Key() { return "after"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_after

template <class Pybind11T = pybind11::module_ &>
struct Bind_applyFirst_void : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_applyFirst_void_AddFunction
    handle.def(
        "applyFirst_void",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::transformer::RewriteRuleWith<void>(
                      llvm::ArrayRef<
                          clang::transformer::RewriteRuleWith<void>>)>::type>(
            &clang::transformer::applyFirst<void>));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_applyFirst_void(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_applyFirst_void(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "applyFirst_void"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_applyFirst_void

using Entity_applyFirst_void = Bind_applyFirst_void<>;

#else

struct Entity_applyFirst_void : public pybind11_weaver::DisabledEntity {
  explicit Entity_applyFirst_void(EntityScope parent_h) {}
  static const char *Key() { return "applyFirst_void"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_applyFirst_void

template <class Pybind11T = pybind11::module_ &>
struct Bind_before : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects the (empty) range [B,B) when \p Selector selects the range [B,E).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_before_AddFunction
    handle.def(
        "before",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::function<llvm::Expected<clang::CharSourceRange>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(&clang::transformer::before),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_before(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_before(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "before"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_before

using Entity_before = Bind_before<>;

#else

struct Entity_before : public pybind11_weaver::DisabledEntity {
  explicit Entity_before(EntityScope parent_h) {}
  static const char *Key() { return "before"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_before

template <class Pybind11T = pybind11::module_ &>
struct Bind_between : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects the range between `R1` and `R2.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_between_AddFunction
    handle.def(
        "between",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<llvm::Expected<clang::CharSourceRange>(
                const clang::ast_matchers::MatchFinder::MatchResult &)>(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>)>::
                        type>(&clang::transformer::between),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_between(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_between(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "between"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_between

using Entity_between = Bind_between<>;

#else

struct Entity_between : public pybind11_weaver::DisabledEntity {
  explicit Entity_between(EntityScope parent_h) {}
  static const char *Key() { return "between"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_between

template <class Pybind11T = pybind11::module_ &>
struct Bind_callArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Given a \c CallExpr (bound to \p ID), selects the arguments' source text (all
// source between the call's parentheses).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_callArgs_AddFunction
    handle.def(
        "callArgs",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::callArgs),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_callArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_callArgs(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "callArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_callArgs

using Entity_callArgs = Bind_callArgs<>;

#else

struct Entity_callArgs : public pybind11_weaver::DisabledEntity {
  explicit Entity_callArgs(EntityScope parent_h) {}
  static const char *Key() { return "callArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_callArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_catVector : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Constructs the string representing the concatenation of the given \p
/// Parts. If only one element is passed in \p Parts, returns that element.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_catVector_AddFunction
    handle.def(
        "catVector",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      std::vector<
                          std::shared_ptr<clang::transformer::MatchComputation<
                              std::basic_string<char>>>>)>::type>(
            &clang::transformer::catVector),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_catVector(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_catVector(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "catVector"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_catVector

using Entity_catVector = Bind_catVector<>;

#else

struct Entity_catVector : public pybind11_weaver::DisabledEntity {
  explicit Entity_catVector(EntityScope parent_h) {}
  static const char *Key() { return "catVector"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_catVector

template <class Pybind11T = pybind11::module_ &>
struct Bind_change : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// DEPRECATED: use \c changeTo.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_change_AddFunction
    handle.def(
        "change",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::ASTEdit(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::shared_ptr<clang::transformer::MatchComputation<
                    std::basic_string<char>>>)>::type>(
            &clang::transformer::change),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_change(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_change(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "change"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_change

using Entity_change = Bind_change<>;

#else

struct Entity_change : public pybind11_weaver::DisabledEntity {
  explicit Entity_change(EntityScope parent_h) {}
  static const char *Key() { return "change"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_change

template <class Pybind11T = pybind11::module_ &>
struct Bind_change1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// DEPRECATED: use \c changeTo.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_change1_AddFunction
    handle.def(
        "change",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::transformer::ASTEdit(
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>)>::type>(
            &clang::transformer::change),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_change1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_change1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "change1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_change1

using Entity_change1 = Bind_change1<>;

#else

struct Entity_change1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_change1(EntityScope parent_h) {}
  static const char *Key() { return "change1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_change1

template <class Pybind11T = pybind11::module_ &>
struct Bind_changeTo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Replaces a portion of the source text with \p Replacement.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_changeTo_AddFunction
    handle.def(
        "changeTo",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::ASTEdit(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::shared_ptr<clang::transformer::MatchComputation<
                    std::basic_string<char>>>)>::type>(
            &clang::transformer::changeTo),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_changeTo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_changeTo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "changeTo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_changeTo

using Entity_changeTo = Bind_changeTo<>;

#else

struct Entity_changeTo : public pybind11_weaver::DisabledEntity {
  explicit Entity_changeTo(EntityScope parent_h) {}
  static const char *Key() { return "changeTo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_changeTo

template <class Pybind11T = pybind11::module_ &>
struct Bind_changeTo1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Replaces the entirety of a RewriteRule's match with \p Replacement.  For
/// example, to replace a function call, one could write:
/// \code
///   makeRule(callExpr(callee(functionDecl(hasName("foo")))),
///            changeTo(cat("bar()")))
/// \endcode)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_changeTo1_AddFunction
    handle.def(
        "changeTo",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::transformer::ASTEdit(
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>)>::type>(
            &clang::transformer::changeTo),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_changeTo1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_changeTo1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "changeTo1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_changeTo1

using Entity_changeTo1 = Bind_changeTo1<>;

#else

struct Entity_changeTo1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_changeTo1(EntityScope parent_h) {}
  static const char *Key() { return "changeTo1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_changeTo1

template <class Pybind11T = pybind11::module_ &>
struct Bind_charRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_charRange_AddFunction
    handle.def(
        "charRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      clang::CharSourceRange)>::type>(
            &clang::transformer::charRange));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_charRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_charRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "charRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_charRange

using Entity_charRange = Bind_charRange<>;

#else

struct Entity_charRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_charRange(EntityScope parent_h) {}
  static const char *Key() { return "charRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_charRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_dPrint : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// For debug use only; semantics are not guaranteed.
///
/// \returns the string resulting from calling the node's print() method.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_dPrint_AddFunction
    handle.def("dPrint",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::dPrint),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_dPrint(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_dPrint(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "dPrint"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_dPrint

using Entity_dPrint = Bind_dPrint<>;

#else

struct Entity_dPrint : public pybind11_weaver::DisabledEntity {
  explicit Entity_dPrint(EntityScope parent_h) {}
  static const char *Key() { return "dPrint"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_dPrint

template <class Pybind11T = pybind11::module_ &>
struct Bind_deref : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Constructs an idiomatic dereferencing of the expression bound to \p ExprId.
/// \p ExprId is wrapped in parentheses, if needed.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_deref_AddFunction
    handle.def("deref",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::deref),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_deref(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_deref(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "deref"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_deref

using Entity_deref = Bind_deref<>;

#else

struct Entity_deref : public pybind11_weaver::DisabledEntity {
  explicit Entity_deref(EntityScope parent_h) {}
  static const char *Key() { return "deref"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_deref

template <class Pybind11T = pybind11::module_ &>
struct Bind_describe : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Produces a human-readable rendering of the node bound to `Id`, suitable for
/// diagnostics and debugging. This operator can be applied to any node, but is
/// targeted at those whose source cannot be printed directly, including:
///
/// * Types. represented based on their structure. Note that namespace
///   qualifiers are always printed, with the anonymous namespace represented
///   explicitly. No desugaring or canonicalization is applied.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_describe_AddFunction
    handle.def("describe",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::describe),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_describe(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_describe(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "describe"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_describe

using Entity_describe = Bind_describe<>;

#else

struct Entity_describe : public pybind11_weaver::DisabledEntity {
  explicit Entity_describe(EntityScope parent_h) {}
  static const char *Key() { return "describe"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_describe

template <class Pybind11T = pybind11::module_>
struct Bind_clang_transformer_detail : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_clang_transformer_detail(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h).def_submodule(
            "detail")} {}

  template <class... HandleArgsT>
  explicit Bind_clang_transformer_detail(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_transformer_detail"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_transformer_detail

using Entity_clang_transformer_detail = Bind_clang_transformer_detail<>;

#else

struct Entity_clang_transformer_detail
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_transformer_detail(EntityScope parent_h) {}
  static const char *Key() { return "clang_transformer_detail"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_transformer_detail

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildMatcher : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds a single matcher for the rule, covering all of the rule's cases.
/// Only supports Rules whose cases' matchers share the same base "kind"
/// (`Stmt`, `Decl`, etc.)  Deprecated: use `buildMatchers` instead, which
/// supports mixing matchers of different kinds.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildMatcher_AddFunction
    handle.def(
        "buildMatcher",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::ast_matchers::internal::DynTypedMatcher(
                      const clang::transformer::RewriteRuleBase &)>::type>(
            &clang::transformer::detail::buildMatcher),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildMatcher(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildMatcher(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildMatcher"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildMatcher

using Entity_buildMatcher = Bind_buildMatcher<>;

#else

struct Entity_buildMatcher : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildMatcher(EntityScope parent_h) {}
  static const char *Key() { return "buildMatcher"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildMatcher

template <class Pybind11T = pybind11::module_ &>
struct Bind_buildMatchers : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Builds a set of matchers that cover the rule.
///
/// One matcher is built for each distinct node matcher base kind: Stmt, Decl,
/// etc. Node-matchers for `QualType` and `Type` are not permitted, since such
/// nodes carry no source location information and are therefore not relevant
/// for rewriting. If any such matchers are included, will return an empty
/// vector.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_buildMatchers_AddFunction
    handle.def(
        "buildMatchers",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::vector<clang::ast_matchers::internal::DynTypedMatcher>(
                      const clang::transformer::RewriteRuleBase &)>::type>(
            &clang::transformer::detail::buildMatchers),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_buildMatchers(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_buildMatchers(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "buildMatchers"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_buildMatchers

using Entity_buildMatchers = Bind_buildMatchers<>;

#else

struct Entity_buildMatchers : public pybind11_weaver::DisabledEntity {
  explicit Entity_buildMatchers(EntityScope parent_h) {}
  static const char *Key() { return "buildMatchers"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_buildMatchers

template <class Pybind11T = pybind11::module_ &>
struct Bind_findSelectedCase : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Returns the index of the \c Case of \c Rule that was selected in the match
/// result. Assumes a matcher built with \c buildMatcher.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_findSelectedCase_AddFunction
    handle.def(
        "findSelectedCase",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            unsigned long(const clang::ast_matchers::MatchFinder::MatchResult &,
                          const clang::transformer::RewriteRuleBase &)>::type>(
            &clang::transformer::detail::findSelectedCase),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_findSelectedCase(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_findSelectedCase(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "findSelectedCase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_findSelectedCase

using Entity_findSelectedCase = Bind_findSelectedCase<>;

#else

struct Entity_findSelectedCase : public pybind11_weaver::DisabledEntity {
  explicit Entity_findSelectedCase(EntityScope parent_h) {}
  static const char *Key() { return "findSelectedCase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_findSelectedCase

template <class Pybind11T = pybind11::module_ &>
struct Bind_getRuleMatchLoc : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Gets the beginning location of the source matched by a rewrite rule. If the
/// match occurs within a macro expansion, returns the beginning of the
/// expansion point. `Result` must come from the matching of a rewrite rule.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_getRuleMatchLoc_AddFunction
    handle.def(
        "getRuleMatchLoc",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::SourceLocation(const clang::ast_matchers::MatchFinder::
                                            MatchResult &)>::type>(
            &clang::transformer::detail::getRuleMatchLoc),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_getRuleMatchLoc(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_getRuleMatchLoc(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "getRuleMatchLoc"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_getRuleMatchLoc

using Entity_getRuleMatchLoc = Bind_getRuleMatchLoc<>;

#else

struct Entity_getRuleMatchLoc : public pybind11_weaver::DisabledEntity {
  explicit Entity_getRuleMatchLoc(EntityScope parent_h) {}
  static const char *Key() { return "getRuleMatchLoc"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_getRuleMatchLoc

template <class Pybind11T = pybind11::module_ &>
struct Bind_injectEdits : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Helper function to construct an \c EditGenerator. Overloaded for common
/// cases so that user doesn't need to specify which factory function to
/// use. This pattern gives benefits similar to implicit constructors, while
/// maintaing a higher degree of explicitness.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_injectEdits_AddFunction
    handle.def(
        "injectEdits",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      clang::transformer::ASTEdit)>::type>(
            &clang::transformer::detail::injectEdits),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_injectEdits(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_injectEdits(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "injectEdits"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_injectEdits

using Entity_injectEdits = Bind_injectEdits<>;

#else

struct Entity_injectEdits : public pybind11_weaver::DisabledEntity {
  explicit Entity_injectEdits(EntityScope parent_h) {}
  static const char *Key() { return "injectEdits"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_injectEdits

template <class Pybind11T = pybind11::module_ &>
struct Bind_injectEdits1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_injectEdits1_AddFunction
    handle.def(
        "injectEdits",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::function<llvm::Expected<
                          llvm::SmallVector<clang::transformer::Edit, 1>>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(
            &clang::transformer::detail::injectEdits));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_injectEdits1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_injectEdits1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "injectEdits1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_injectEdits1

using Entity_injectEdits1 = Bind_injectEdits1<>;

#else

struct Entity_injectEdits1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_injectEdits1(EntityScope parent_h) {}
  static const char *Key() { return "injectEdits1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_injectEdits1

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeEditGenerator2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeEditGenerator2_AddFunction
    handle.def(
        "makeEditGenerator",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      clang::transformer::ASTEdit)>::type>(
            &clang::transformer::detail::makeEditGenerator));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeEditGenerator2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeEditGenerator2(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeEditGenerator2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeEditGenerator2

using Entity_makeEditGenerator2 = Bind_makeEditGenerator2<>;

#else

struct Entity_makeEditGenerator2 : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeEditGenerator2(EntityScope parent_h) {}
  static const char *Key() { return "makeEditGenerator2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeEditGenerator2

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeEditGenerator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeEditGenerator_AddFunction
    handle.def(
        "makeEditGenerator",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::function<llvm::Expected<
                          llvm::SmallVector<clang::transformer::Edit, 1>>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(
            &clang::transformer::detail::makeEditGenerator));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeEditGenerator(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeEditGenerator(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeEditGenerator"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeEditGenerator

using Entity_makeEditGenerator = Bind_makeEditGenerator<>;

#else

struct Entity_makeEditGenerator : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeEditGenerator(EntityScope parent_h) {}
  static const char *Key() { return "makeEditGenerator"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeEditGenerator

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeEditGenerator1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeEditGenerator1_AddFunction
    handle.def(
        "makeEditGenerator",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<
                llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>(
                llvm::SmallVector<clang::transformer::ASTEdit, 1>)>::type>(
            &clang::transformer::detail::makeEditGenerator));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeEditGenerator1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeEditGenerator1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeEditGenerator1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeEditGenerator1

using Entity_makeEditGenerator1 = Bind_makeEditGenerator1<>;

#else

struct Entity_makeEditGenerator1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeEditGenerator1(EntityScope parent_h) {}
  static const char *Key() { return "makeEditGenerator1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeEditGenerator1

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeRule1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeRule1_AddFunction
    handle.def(
        "makeRule",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::transformer::RewriteRuleWith<void>(
                      clang::ast_matchers::internal::DynTypedMatcher,
                      std::function<llvm::Expected<
                          llvm::SmallVector<clang::transformer::Edit, 1>>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(
            &clang::transformer::detail::makeRule));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeRule1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeRule1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeRule1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeRule1

using Entity_makeRule1 = Bind_makeRule1<>;

#else

struct Entity_makeRule1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeRule1(EntityScope parent_h) {}
  static const char *Key() { return "makeRule1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeRule1

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeStencil1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeStencil1_AddFunction
    handle.def(
        "makeStencil",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      std::function<llvm::Expected<clang::CharSourceRange>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(
            &clang::transformer::detail::makeStencil));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeStencil1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeStencil1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeStencil1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeStencil1

using Entity_makeStencil1 = Bind_makeStencil1<>;

#else

struct Entity_makeStencil1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeStencil1(EntityScope parent_h) {}
  static const char *Key() { return "makeStencil1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeStencil1

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeStencil2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeStencil2_AddFunction
    handle.def(
        "makeStencil",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>)>::type>(
            &clang::transformer::detail::makeStencil));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeStencil2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeStencil2(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeStencil2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeStencil2

using Entity_makeStencil2 = Bind_makeStencil2<>;

#else

struct Entity_makeStencil2 : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeStencil2(EntityScope parent_h) {}
  static const char *Key() { return "makeStencil2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeStencil2

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeStencil : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Convenience function to construct a \c Stencil. Overloaded for common cases
/// so that user doesn't need to specify which factory function to use. This
/// pattern gives benefits similar to implicit constructors, while maintaing a
/// higher degree of explicitness.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_makeStencil_AddFunction
    handle.def("makeStencil",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::detail::makeStencil),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeStencil(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeStencil(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeStencil"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeStencil

using Entity_makeStencil = Bind_makeStencil<>;

#else

struct Entity_makeStencil : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeStencil(EntityScope parent_h) {}
  static const char *Key() { return "makeStencil"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeStencil

template <class Pybind11T = pybind11::module_ &>
struct Bind_rewriteDescendants1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// The following overload set is a version of `rewriteDescendants` that
/// operates directly on the AST, rather than generating a Transformer
/// combinator. It applies `Rule` to all descendants of `Node`, although not
/// `Node` itself. `Rule` can refer to nodes bound in `Result`.
///
/// For example, assuming that "body" is bound to a function body in MatchResult
/// `Results`, this will produce edits to change all appearances of `x` in that
/// body to `3`.
/// ```
/// auto InlineX =
///     makeRule(declRefExpr(to(varDecl(hasName("x")))), changeTo(cat("3")));
/// const auto *Node = Results.Nodes.getNodeAs<Stmt>("body");
/// auto Edits = rewriteDescendants(*Node, InlineX, Results);
/// ```
/// @{)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_rewriteDescendants1_AddFunction
    handle.def(
        "rewriteDescendants",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                const clang::Decl &, clang::transformer::RewriteRuleWith<void>,
                const clang::ast_matchers::MatchFinder::MatchResult &)>::type>(
            &clang::transformer::detail::rewriteDescendants),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_rewriteDescendants1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_rewriteDescendants1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "rewriteDescendants1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_rewriteDescendants1

using Entity_rewriteDescendants1 = Bind_rewriteDescendants1<>;

#else

struct Entity_rewriteDescendants1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_rewriteDescendants1(EntityScope parent_h) {}
  static const char *Key() { return "rewriteDescendants1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_rewriteDescendants1

template <class Pybind11T = pybind11::module_ &>
struct Bind_rewriteDescendants4 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_rewriteDescendants4_AddFunction
    handle.def(
        "rewriteDescendants",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                const clang::DynTypedNode &,
                clang::transformer::RewriteRuleWith<void>,
                const clang::ast_matchers::MatchFinder::MatchResult &)>::type>(
            &clang::transformer::detail::rewriteDescendants));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_rewriteDescendants4(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_rewriteDescendants4(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "rewriteDescendants4"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_rewriteDescendants4

using Entity_rewriteDescendants4 = Bind_rewriteDescendants4<>;

#else

struct Entity_rewriteDescendants4 : public pybind11_weaver::DisabledEntity {
  explicit Entity_rewriteDescendants4(EntityScope parent_h) {}
  static const char *Key() { return "rewriteDescendants4"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_rewriteDescendants4

template <class Pybind11T = pybind11::module_ &>
struct Bind_rewriteDescendants2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_rewriteDescendants2_AddFunction
    handle.def(
        "rewriteDescendants",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                const clang::Stmt &, clang::transformer::RewriteRuleWith<void>,
                const clang::ast_matchers::MatchFinder::MatchResult &)>::type>(
            &clang::transformer::detail::rewriteDescendants));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_rewriteDescendants2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_rewriteDescendants2(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "rewriteDescendants2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_rewriteDescendants2

using Entity_rewriteDescendants2 = Bind_rewriteDescendants2<>;

#else

struct Entity_rewriteDescendants2 : public pybind11_weaver::DisabledEntity {
  explicit Entity_rewriteDescendants2(EntityScope parent_h) {}
  static const char *Key() { return "rewriteDescendants2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_rewriteDescendants2

template <class Pybind11T = pybind11::module_ &>
struct Bind_rewriteDescendants3 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_rewriteDescendants3_AddFunction
    handle.def(
        "rewriteDescendants",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                const clang::TypeLoc &,
                clang::transformer::RewriteRuleWith<void>,
                const clang::ast_matchers::MatchFinder::MatchResult &)>::type>(
            &clang::transformer::detail::rewriteDescendants));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_rewriteDescendants3(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_rewriteDescendants3(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "rewriteDescendants3"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_rewriteDescendants3

using Entity_rewriteDescendants3 = Bind_rewriteDescendants3<>;

#else

struct Entity_rewriteDescendants3 : public pybind11_weaver::DisabledEntity {
  explicit Entity_rewriteDescendants3(EntityScope parent_h) {}
  static const char *Key() { return "rewriteDescendants3"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_rewriteDescendants3

template <class Pybind11T = pybind11::module_ &>
struct Bind_edit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Generates a single (specified) edit.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_edit_AddFunction
    handle.def(
        "edit",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      clang::transformer::ASTEdit)>::type>(
            &clang::transformer::edit),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_edit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_edit(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "edit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_edit

using Entity_edit = Bind_edit<>;

#else

struct Entity_edit : public pybind11_weaver::DisabledEntity {
  explicit Entity_edit(EntityScope parent_h) {}
  static const char *Key() { return "edit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_edit

template <class Pybind11T = pybind11::module_ &>
struct Bind_editList : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Lifts a list of `ASTEdit`s into an `EditGenerator`.
///
/// The `EditGenerator` will return an empty vector if any of the edits apply to
/// portions of the source that are ineligible for rewriting (certain
/// interactions with macros, for example) and it will fail if any invariants
/// are violated relating to bound nodes in the match.  However, it does not
/// fail in the case of conflicting edits -- conflict handling is left to
/// clients.  We recommend use of the \c AtomicChange or \c Replacements classes
/// for assistance in detecting such conflicts.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_editList_AddFunction
    handle.def(
        "editList",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<
                llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>(
                llvm::SmallVector<clang::transformer::ASTEdit, 1>)>::type>(
            &clang::transformer::editList),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_editList(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_editList(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "editList"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_editList

using Entity_editList = Bind_editList<>;

#else

struct Entity_editList : public pybind11_weaver::DisabledEntity {
  explicit Entity_editList(EntityScope parent_h) {}
  static const char *Key() { return "editList"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_editList

template <class Pybind11T = pybind11::module_ &>
struct Bind_elseBranch : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Given an \IfStmt (bound to \p ID), selects the range of the else branch,
/// starting from the \c else keyword.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_elseBranch_AddFunction
    handle.def(
        "elseBranch",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::elseBranch),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_elseBranch(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_elseBranch(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "elseBranch"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_elseBranch

using Entity_elseBranch = Bind_elseBranch<>;

#else

struct Entity_elseBranch : public pybind11_weaver::DisabledEntity {
  explicit Entity_elseBranch(EntityScope parent_h) {}
  static const char *Key() { return "elseBranch"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_elseBranch

template <class Pybind11T = pybind11::module_ &>
struct Bind_enclose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects from the start of \p Begin and to the end of \p End.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_enclose_AddFunction
    handle.def(
        "enclose",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<llvm::Expected<clang::CharSourceRange>(
                const clang::ast_matchers::MatchFinder::MatchResult &)>(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>)>::
                        type>(&clang::transformer::enclose),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_enclose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_enclose(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "enclose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_enclose

using Entity_enclose = Bind_enclose<>;

#else

struct Entity_enclose : public pybind11_weaver::DisabledEntity {
  explicit Entity_enclose(EntityScope parent_h) {}
  static const char *Key() { return "enclose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_enclose

template <class Pybind11T = pybind11::module_ &>
struct Bind_encloseNodes : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Convenience version of \c range where end-points are bound nodes.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_encloseNodes_AddFunction
    handle.def(
        "encloseNodes",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>, std::basic_string<char>)>::type>(
            &clang::transformer::encloseNodes),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_encloseNodes(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_encloseNodes(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "encloseNodes"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_encloseNodes

using Entity_encloseNodes = Bind_encloseNodes<>;

#else

struct Entity_encloseNodes : public pybind11_weaver::DisabledEntity {
  explicit Entity_encloseNodes(EntityScope parent_h) {}
  static const char *Key() { return "encloseNodes"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_encloseNodes

template <class Pybind11T = pybind11::module_ &>
struct Bind_expansion : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects the range from which `S` was expanded (possibly along with other
/// source), if `S` is an expansion, and `S` itself, otherwise.  Corresponds to
/// `SourceManager::getExpansionRange`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_expansion_AddFunction
    handle.def(
        "expansion",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::function<llvm::Expected<clang::CharSourceRange>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(&clang::transformer::expansion),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_expansion(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_expansion(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "expansion"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_expansion

using Entity_expansion = Bind_expansion<>;

#else

struct Entity_expansion : public pybind11_weaver::DisabledEntity {
  explicit Entity_expansion(EntityScope parent_h) {}
  static const char *Key() { return "expansion"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_expansion

template <class Pybind11T = pybind11::module_ &>
struct Bind_expression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Generates the source of the expression bound to \p Id, wrapping it in
/// parentheses if it may parse differently depending on context. For example, a
/// binary operation is always wrapped, while a variable reference is never
/// wrapped.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_expression_AddFunction
    handle.def("expression",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::expression),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_expression(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_expression(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "expression"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_expression

using Entity_expression = Bind_expression<>;

#else

struct Entity_expression : public pybind11_weaver::DisabledEntity {
  explicit Entity_expression(EntityScope parent_h) {}
  static const char *Key() { return "expression"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_expression

template <class Pybind11T = pybind11::module_ &>
struct Bind_flattenVector : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Flattens a list of generators into a single generator whose elements are the
/// concatenation of the results of the argument generators.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_flattenVector_AddFunction
    handle.def(
        "flattenVector",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<
                llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>(
                llvm::SmallVector<
                    std::function<llvm::Expected<
                        llvm::SmallVector<clang::transformer::Edit, 1>>(
                        const clang::ast_matchers::MatchFinder::MatchResult &)>,
                    2>)>::type>(&clang::transformer::flattenVector),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_flattenVector(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_flattenVector(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "flattenVector"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_flattenVector

using Entity_flattenVector = Bind_flattenVector<>;

#else

struct Entity_flattenVector : public pybind11_weaver::DisabledEntity {
  explicit Entity_flattenVector(EntityScope parent_h) {}
  static const char *Key() { return "flattenVector"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_flattenVector

template <class Pybind11T = pybind11::module_ &>
struct Bind_ifBound : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Chooses between the two stencil parts, based on whether \p ID is bound in
/// the match.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_ifBound_AddFunction
    handle.def(
        "ifBound",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      llvm::StringRef,
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>,
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>)>::type>(
            &clang::transformer::ifBound),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_ifBound(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_ifBound(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "ifBound"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_ifBound

using Entity_ifBound = Bind_ifBound<>;

#else

struct Entity_ifBound : public pybind11_weaver::DisabledEntity {
  explicit Entity_ifBound(EntityScope parent_h) {}
  static const char *Key() { return "ifBound"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_ifBound

template <class Pybind11T = pybind11::module_ &>
struct Bind_ifBound1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Chooses between the two strings, based on whether \p ID is bound in the
/// match.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_ifBound1_AddFunction
    handle.def(
        "ifBound",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::shared_ptr<
                clang::transformer::MatchComputation<std::basic_string<char>>>(
                llvm::StringRef, llvm::StringRef, llvm::StringRef)>::type>(
            &clang::transformer::ifBound),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_ifBound1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_ifBound1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "ifBound1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_ifBound1

using Entity_ifBound1 = Bind_ifBound1<>;

#else

struct Entity_ifBound1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_ifBound1(EntityScope parent_h) {}
  static const char *Key() { return "ifBound1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_ifBound1

template <class Pybind11T = pybind11::module_ &>
struct Bind_ifBound3 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Version of `ifBound` that has no "False" branch. If the node is not bound,
/// then no edits are produced.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_ifBound3_AddFunction
    handle.def(
        "ifBound",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<
                llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>(
                std::basic_string<char>, clang::transformer::ASTEdit)>::type>(
            &clang::transformer::ifBound),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_ifBound3(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_ifBound3(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "ifBound3"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_ifBound3

using Entity_ifBound3 = Bind_ifBound3<>;

#else

struct Entity_ifBound3 : public pybind11_weaver::DisabledEntity {
  explicit Entity_ifBound3(EntityScope parent_h) {}
  static const char *Key() { return "ifBound3"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_ifBound3

template <class Pybind11T = pybind11::module_ &>
struct Bind_ifBound2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Version of `ifBound` specialized to `ASTEdit`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_ifBound2_AddFunction
    handle.def(
        "ifBound",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>, clang::transformer::ASTEdit,
                      clang::transformer::ASTEdit)>::type>(
            &clang::transformer::ifBound),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_ifBound2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_ifBound2(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "ifBound2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_ifBound2

using Entity_ifBound2 = Bind_ifBound2<>;

#else

struct Entity_ifBound2 : public pybind11_weaver::DisabledEntity {
  explicit Entity_ifBound2(EntityScope parent_h) {}
  static const char *Key() { return "ifBound2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_ifBound2

template <class Pybind11T = pybind11::module_ &>
struct Bind_initListElements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Given a \c InitListExpr (bound to \p ID), selects the range of the elements
// (all source between the braces).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_initListElements_AddFunction
    handle.def(
        "initListElements",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::initListElements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_initListElements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_initListElements(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "initListElements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_initListElements

using Entity_initListElements = Bind_initListElements<>;

#else

struct Entity_initListElements : public pybind11_weaver::DisabledEntity {
  explicit Entity_initListElements(EntityScope parent_h) {}
  static const char *Key() { return "initListElements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_initListElements

template <class Pybind11T = pybind11::module_ &>
struct Bind_insertAfter : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Inserts \p Replacement after \p S, leaving the source selected by \S
/// unchanged.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_insertAfter_AddFunction
    handle.def(
        "insertAfter",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::ASTEdit(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::shared_ptr<clang::transformer::MatchComputation<
                    std::basic_string<char>>>)>::type>(
            &clang::transformer::insertAfter),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_insertAfter(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_insertAfter(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "insertAfter"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_insertAfter

using Entity_insertAfter = Bind_insertAfter<>;

#else

struct Entity_insertAfter : public pybind11_weaver::DisabledEntity {
  explicit Entity_insertAfter(EntityScope parent_h) {}
  static const char *Key() { return "insertAfter"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_insertAfter

template <class Pybind11T = pybind11::module_ &>
struct Bind_insertBefore : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Inserts \p Replacement before \p S, leaving the source selected by \S
/// unchanged.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_insertBefore_AddFunction
    handle.def(
        "insertBefore",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::ASTEdit(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::shared_ptr<clang::transformer::MatchComputation<
                    std::basic_string<char>>>)>::type>(
            &clang::transformer::insertBefore),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_insertBefore(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_insertBefore(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "insertBefore"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_insertBefore

using Entity_insertBefore = Bind_insertBefore<>;

#else

struct Entity_insertBefore : public pybind11_weaver::DisabledEntity {
  explicit Entity_insertBefore(EntityScope parent_h) {}
  static const char *Key() { return "insertBefore"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_insertBefore

template <class Pybind11T = pybind11::module_ &>
struct Bind_makeRule : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_makeRule_AddFunction
    handle.def(
        "makeRule",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::RewriteRuleWith<void>(
                clang::ast_matchers::internal::DynTypedMatcher,
                std::initializer_list<clang::transformer::ASTEdit>)>::type>(
            &clang::transformer::makeRule));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_makeRule(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_makeRule(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "makeRule"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_makeRule

using Entity_makeRule = Bind_makeRule<>;

#else

struct Entity_makeRule : public pybind11_weaver::DisabledEntity {
  explicit Entity_makeRule(EntityScope parent_h) {}
  static const char *Key() { return "makeRule"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_makeRule

template <class Pybind11T = pybind11::module_ &>
struct Bind_maybeAddressOf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If \p ExprId is not a pointer type, constructs an expression that
/// idiomatically takes the address of the expression bound to \p ExprId,
/// including wrapping \p ExprId in parentheses, if needed. Otherwise, generates
/// the original expression source.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_maybeAddressOf_AddFunction
    handle.def("maybeAddressOf",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::maybeAddressOf),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_maybeAddressOf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_maybeAddressOf(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "maybeAddressOf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_maybeAddressOf

using Entity_maybeAddressOf = Bind_maybeAddressOf<>;

#else

struct Entity_maybeAddressOf : public pybind11_weaver::DisabledEntity {
  explicit Entity_maybeAddressOf(EntityScope parent_h) {}
  static const char *Key() { return "maybeAddressOf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_maybeAddressOf

template <class Pybind11T = pybind11::module_ &>
struct Bind_maybeDeref : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// If \p ExprId is of pointer type, constructs an idiomatic dereferencing of
/// the expression bound to \p ExprId, including wrapping it in parentheses, if
/// needed. Otherwise, generates the original expression source.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_maybeDeref_AddFunction
    handle.def("maybeDeref",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::shared_ptr<clang::transformer::MatchComputation<
                             std::basic_string<char>>>(llvm::StringRef)>::type>(
                   &clang::transformer::maybeDeref),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_maybeDeref(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_maybeDeref(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "maybeDeref"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_maybeDeref

using Entity_maybeDeref = Bind_maybeDeref<>;

#else

struct Entity_maybeDeref : public pybind11_weaver::DisabledEntity {
  explicit Entity_maybeDeref(EntityScope parent_h) {}
  static const char *Key() { return "maybeDeref"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_maybeDeref

template <class Pybind11T = pybind11::module_ &>
struct Bind_member : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Given a \c MemberExpr, selects the member token. \p ID is the node's
/// binding in the match result.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_member_AddFunction
    handle.def(
        "member",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::member),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_member(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_member(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "member"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_member

using Entity_member = Bind_member<>;

#else

struct Entity_member : public pybind11_weaver::DisabledEntity {
  explicit Entity_member(EntityScope parent_h) {}
  static const char *Key() { return "member"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_member

template <class Pybind11T = pybind11::module_ &>
struct Bind_name : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Given a node with a "name", (like \c NamedDecl, \c DeclRefExpr, \c
/// CxxCtorInitializer, and \c TypeLoc) selects the name's token.  Only selects
/// the final identifier of a qualified name, but not any qualifiers or template
/// arguments.  For example, for `::foo::bar::baz` and `::foo::bar::baz<int>`,
/// it selects only `baz`.
///
/// \param ID is the node's binding in the match result.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_name_AddFunction
    handle.def(
        "name",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::name),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_name(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_name(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "name"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_name

using Entity_name = Bind_name<>;

#else

struct Entity_name : public pybind11_weaver::DisabledEntity {
  explicit Entity_name(EntityScope parent_h) {}
  static const char *Key() { return "name"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_name

template <class Pybind11T = pybind11::module_ &>
struct Bind_noEdits : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Generates no edits.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_noEdits_AddFunction
    handle.def("noEdits",
               static_cast<pybind11_weaver::FnPtrT<
                   void, std::function<llvm::Expected<
                             llvm::SmallVector<clang::transformer::Edit, 1>>(
                             const clang::ast_matchers::MatchFinder::MatchResult
                                 &)>()>::type>(&clang::transformer::noEdits),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_noEdits(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_noEdits(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "noEdits"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_noEdits

using Entity_noEdits = Bind_noEdits<>;

#else

struct Entity_noEdits : public pybind11_weaver::DisabledEntity {
  explicit Entity_noEdits(EntityScope parent_h) {}
  static const char *Key() { return "noEdits"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_noEdits

template <class Pybind11T = pybind11::module_ &>
struct Bind_node : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects a node, including trailing semicolon, if any (for declarations and
/// non-expression statements). \p ID is the node's binding in the match result.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_node_AddFunction
    handle.def(
        "node",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::node),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_node(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_node(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "node"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_node

using Entity_node = Bind_node<>;

#else

struct Entity_node : public pybind11_weaver::DisabledEntity {
  explicit Entity_node(EntityScope parent_h) {}
  static const char *Key() { return "node"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_node

template <class Pybind11T = pybind11::module_ &>
struct Bind_noopEdit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Generates a single, no-op edit anchored at the start location of the
/// specified range. A `noopEdit` may be preferred over `noEdits` to associate a
/// diagnostic `Explanation` with the rule.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_noopEdit_AddFunction
    handle.def(
        "noopEdit",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::function<llvm::Expected<clang::CharSourceRange>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(&clang::transformer::noopEdit),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_noopEdit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_noopEdit(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "noopEdit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_noopEdit

using Entity_noopEdit = Bind_noopEdit<>;

#else

struct Entity_noopEdit : public pybind11_weaver::DisabledEntity {
  explicit Entity_noopEdit(EntityScope parent_h) {}
  static const char *Key() { return "noopEdit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_noopEdit

template <class Pybind11T = pybind11::module_ &>
struct Bind_notBoundError : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Creates an error that signals that a `MatchConsumer` expected a certain node
/// to be bound by AST matchers, but it was not actually bound.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_notBoundError_AddFunction
    handle.def(
        "notBoundError",
        static_cast<
            pybind11_weaver::FnPtrT<void, llvm::Error(llvm::StringRef)>::type>(
            &clang::transformer::notBoundError),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_notBoundError(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_notBoundError(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "notBoundError"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_notBoundError

using Entity_notBoundError = Bind_notBoundError<>;

#else

struct Entity_notBoundError : public pybind11_weaver::DisabledEntity {
  explicit Entity_notBoundError(EntityScope parent_h) {}
  static const char *Key() { return "notBoundError"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_notBoundError

template <class Pybind11T = pybind11::module_ &>
struct Bind_note : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Generates a single, no-op edit with the associated note anchored at the
/// start location of the specified range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_note_AddFunction
    handle.def(
        "note",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            clang::transformer::ASTEdit(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::shared_ptr<clang::transformer::MatchComputation<
                    std::basic_string<char>>>)>::type>(
            &clang::transformer::note),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_note(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_note(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "note"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_note

using Entity_note = Bind_note<>;

#else

struct Entity_note : public pybind11_weaver::DisabledEntity {
  explicit Entity_note(EntityScope parent_h) {}
  static const char *Key() { return "note"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_note

template <class Pybind11T = pybind11::module_ &>
struct Bind_parseRangeSelector : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Parses a string representation of a \c RangeSelector. The grammar of these
/// strings is closely based on the (sub)grammar of \c RangeSelectors as they'd
/// appear in C++ code. However, this language constrains the set of permissible
/// strings (for node ids) -- it does not support escapes in the
/// string. Additionally, the \c charRange combinator is not supported, because
/// there is no representation of values of type \c CharSourceRange in this
/// (little) language.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_parseRangeSelector_AddFunction
    handle.def(
        "parseRangeSelector",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            llvm::Expected<std::function<llvm::Expected<clang::CharSourceRange>(
                const clang::ast_matchers::MatchFinder::MatchResult &)>>(
                llvm::StringRef)>::type>(
            &clang::transformer::parseRangeSelector),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_parseRangeSelector(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_parseRangeSelector(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "parseRangeSelector"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_parseRangeSelector

using Entity_parseRangeSelector = Bind_parseRangeSelector<>;

#else

struct Entity_parseRangeSelector : public pybind11_weaver::DisabledEntity {
  explicit Entity_parseRangeSelector(EntityScope parent_h) {}
  static const char *Key() { return "parseRangeSelector"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_parseRangeSelector

template <class Pybind11T = pybind11::module_ &>
struct Bind_range : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// DEPRECATED. Use `enclose`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_range_AddFunction
    handle.def(
        "range",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<llvm::Expected<clang::CharSourceRange>(
                const clang::ast_matchers::MatchFinder::MatchResult &)>(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>)>::
                        type>(&clang::transformer::range),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_range(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_range(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "range"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_range

using Entity_range = Bind_range<>;

#else

struct Entity_range : public pybind11_weaver::DisabledEntity {
  explicit Entity_range(EntityScope parent_h) {}
  static const char *Key() { return "range"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_range

template <class Pybind11T = pybind11::module_ &>
struct Bind_range1 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// DEPRECATED. Use `encloseNodes`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_range1_AddFunction
    handle.def(
        "range",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>, std::basic_string<char>)>::type>(
            &clang::transformer::range),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_range1(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_range1(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "range1"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_range1

using Entity_range1 = Bind_range1<>;

#else

struct Entity_range1 : public pybind11_weaver::DisabledEntity {
  explicit Entity_range1(EntityScope parent_h) {}
  static const char *Key() { return "range1"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_range1

template <class Pybind11T = pybind11::module_ &>
struct Bind_remove : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Removes the source selected by \p S.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_remove_AddFunction
    handle.def(
        "remove",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::transformer::ASTEdit(
                      std::function<llvm::Expected<clang::CharSourceRange>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(&clang::transformer::remove),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_remove(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_remove(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "remove"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_remove

using Entity_remove = Bind_remove<>;

#else

struct Entity_remove : public pybind11_weaver::DisabledEntity {
  explicit Entity_remove(EntityScope parent_h) {}
  static const char *Key() { return "remove"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_remove

template <class Pybind11T = pybind11::module_ &>
struct Bind_rewriteDescendants : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Applies `Rule` to all descendants of the node bound to `NodeId`. `Rule` can
/// refer to nodes bound by the calling rule. `Rule` is not applied to the node
/// itself.
///
/// For example,
/// ```
/// auto InlineX =
///     makeRule(declRefExpr(to(varDecl(hasName("x")))), changeTo(cat("3")));
/// makeRule(functionDecl(hasName("f"), hasBody(stmt().bind("body"))).bind("f"),
///          flatten(
///            changeTo(name("f"), cat("newName")),
///            rewriteDescendants("body", InlineX)));
/// ```
/// Here, we find the function `f`, change its name to `newName` and change all
/// appearances of `x` in its body to `3`.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_rewriteDescendants_AddFunction
    handle.def(
        "rewriteDescendants",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<
                      llvm::SmallVector<clang::transformer::Edit, 1>>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>,
                      clang::transformer::RewriteRuleWith<void>)>::type>(
            &clang::transformer::rewriteDescendants),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_rewriteDescendants(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_rewriteDescendants(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "rewriteDescendants"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_rewriteDescendants

using Entity_rewriteDescendants = Bind_rewriteDescendants<>;

#else

struct Entity_rewriteDescendants : public pybind11_weaver::DisabledEntity {
  explicit Entity_rewriteDescendants(EntityScope parent_h) {}
  static const char *Key() { return "rewriteDescendants"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_rewriteDescendants

template <class Pybind11T = pybind11::module_ &>
struct Bind_run : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Wraps a \c MatchConsumer in a \c Stencil, so that it can be used in a \c
/// Stencil.  This supports user-defined extensions to the \c Stencil language.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_run_AddFunction
    handle.def(
        "run",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      std::function<llvm::Expected<std::basic_string<char>>(
                          const clang::ast_matchers::MatchFinder::MatchResult
                              &)>)>::type>(&clang::transformer::run),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_run(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_run(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "run"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_run

using Entity_run = Bind_run<>;

#else

struct Entity_run : public pybind11_weaver::DisabledEntity {
  explicit Entity_run(EntityScope parent_h) {}
  static const char *Key() { return "run"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_run

template <class Pybind11T = pybind11::module_ &>
struct Bind_selectBound : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Chooses between multiple stencils, based on the presence of bound nodes. \p
/// CaseStencils takes a vector of (ID, \c Stencil) pairs and checks each ID in
/// order to see if it's bound to a node.  If so, the associated \c Stencil is
/// run and all other cases are ignored.  An optional \p DefaultStencil can be
/// provided to be run if all cases are exhausted beacause none of the provided
/// IDs are bound.  If no default case is provided and all cases are exhausted,
/// the stencil will fail with error `llvm::errc::result_out_of_range`.
///
/// For example, say one matches a statement's type with:
///     anyOf(
///       qualType(isInteger()).bind("int"),
///       qualType(realFloatingPointType()).bind("float"),
///       qualType(isAnyCharacter()).bind("char"),
///       booleanType().bind("bool"))
///
/// Then, one can decide in a stencil how to construct a literal.
///     cat("a = ",
///         selectBound(
///             {{"int", cat("0")},
///              {"float", cat("0.0")},
///              {"char", cat("'\\0'")},
///              {"bool", cat("false")}}))
///
/// In addition, one could supply a default case for all other types:
///     selectBound(
///         {{"int", cat("0")},
///          ...
///          {"bool", cat("false")}},
///         cat("{}")))_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_selectBound_AddFunction
    handle.def(
        "selectBound",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::shared_ptr<clang::transformer::MatchComputation<
                      std::basic_string<char>>>(
                      std::vector<std::pair<
                          std::basic_string<char>,
                          std::shared_ptr<clang::transformer::MatchComputation<
                              std::basic_string<char>>>>>,
                      std::shared_ptr<clang::transformer::MatchComputation<
                          std::basic_string<char>>>)>::type>(
            &clang::transformer::selectBound),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_selectBound(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_selectBound(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "selectBound"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_selectBound

using Entity_selectBound = Bind_selectBound<>;

#else

struct Entity_selectBound : public pybind11_weaver::DisabledEntity {
  explicit Entity_selectBound(EntityScope parent_h) {}
  static const char *Key() { return "selectBound"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_selectBound

template <class Pybind11T = pybind11::module_ &>
struct Bind_shrinkTo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Assuming that the inner range is enclosed by the outer range, creates
/// precision edits to remove the parts of the outer range that are not included
/// in the inner range.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_shrinkTo_AddFunction
    handle.def(
        "shrinkTo",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            std::function<
                llvm::Expected<llvm::SmallVector<clang::transformer::Edit, 1>>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>(
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>,
                std::function<llvm::Expected<clang::CharSourceRange>(
                    const clang::ast_matchers::MatchFinder::MatchResult &)>)>::
                        type>(&clang::transformer::shrinkTo),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_shrinkTo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_shrinkTo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "shrinkTo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_shrinkTo

using Entity_shrinkTo = Bind_shrinkTo<>;

#else

struct Entity_shrinkTo : public pybind11_weaver::DisabledEntity {
  explicit Entity_shrinkTo(EntityScope parent_h) {}
  static const char *Key() { return "shrinkTo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_shrinkTo

template <class Pybind11T = pybind11::module_ &>
struct Bind_statement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Selects a node, including trailing semicolon (always). Useful for selecting
/// expression statements. \p ID is the node's binding in the match result.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_statement_AddFunction
    handle.def(
        "statement",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::statement),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_statement(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_statement(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "statement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_statement

using Entity_statement = Bind_statement<>;

#else

struct Entity_statement : public pybind11_weaver::DisabledEntity {
  explicit Entity_statement(EntityScope parent_h) {}
  static const char *Key() { return "statement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_statement

template <class Pybind11T = pybind11::module_ &>
struct Bind_statements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(// Given a \c CompoundStmt (bound to \p ID), selects the source of the
// statements (all source between the braces).)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_statements_AddFunction
    handle.def(
        "statements",
        static_cast<pybind11_weaver::FnPtrT<
            void, std::function<llvm::Expected<clang::CharSourceRange>(
                      const clang::ast_matchers::MatchFinder::MatchResult &)>(
                      std::basic_string<char>)>::type>(
            &clang::transformer::statements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_statements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_statements(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "statements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_statements

using Entity_statements = Bind_statements<>;

#else

struct Entity_statements : public pybind11_weaver::DisabledEntity {
  explicit Entity_statements(EntityScope parent_h) {}
  static const char *Key() { return "statements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_statements

template <class Pybind11T = pybind11::module_>
struct Bind_llvm : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_llvm(EntityScope parent_h)
      : handle{
            static_cast<pybind11::module_ &>(parent_h).def_submodule("llvm")} {}

  template <class... HandleArgsT>
  explicit Bind_llvm(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "llvm"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm

using Entity_llvm = Bind_llvm<>;

#else

struct Entity_llvm : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm(EntityScope parent_h) {}
  static const char *Key() { return "llvm"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm

template <class Pybind11T = pybind11::class_<
              llvm::DenseMapInfo<clang::tooling::dependencies::ModuleID>>>
struct Bind_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::dependencies::ModuleID;
  using Enable = void;

  virtual const char *AddMethod_getEmptyKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9_getEmptyKey
    handle.def_static(
        "getEmptyKey",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::dependencies::ModuleID()>::type>(
            &llvm::DenseMapInfo<
                clang::tooling::dependencies::ModuleID>::getEmptyKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTombstoneKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9_getTombstoneKey
    handle.def_static(
        "getTombstoneKey",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::dependencies::ModuleID()>::type>(
            &llvm::DenseMapInfo<
                clang::tooling::dependencies::ModuleID>::getTombstoneKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getHashValue() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9_getHashValue
    handle.def_static(
        "getHashValue",
        static_cast<pybind11_weaver::FnPtrT<
            void, unsigned int(
                      const clang::tooling::dependencies::ModuleID &)>::type>(
            &llvm::DenseMapInfo<
                clang::tooling::dependencies::ModuleID>::getHashValue));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isEqual() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9_isEqual
    handle.def_static(
        "isEqual",
        static_cast<pybind11_weaver::FnPtrT<
            void, bool(const clang::tooling::dependencies::ModuleID &,
                       const clang::tooling::dependencies::ModuleID &)>::type>(
            &llvm::DenseMapInfo<
                clang::tooling::dependencies::ModuleID>::isEqual));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9(
      EntityScope parent_h)
      : handle{parent_h, "DenseMapInfo6clang_tooling_dependencies_ModuleID9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getEmptyKey();
    AddMethod_getTombstoneKey();
    AddMethod_getHashValue();
    AddMethod_isEqual();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::DenseMapInfo<clang::tooling::dependencies::ModuleID>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9

using Entity_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9 =
    Bind_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9<>;

#else

struct Entity_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9

template <class Pybind11T = pybind11::class_<
              llvm::DenseMapInfo<clang::tooling::stdlib::Header>>>
struct Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Header9 : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::stdlib::Header;
  using Enable = void;

  virtual const char *AddMethod_getEmptyKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Header9_getEmptyKey
    handle.def_static(
        "getEmptyKey",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::stdlib::Header()>::type>(
            &llvm::DenseMapInfo<clang::tooling::stdlib::Header>::getEmptyKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTombstoneKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Header9_getTombstoneKey
    handle.def_static(
        "getTombstoneKey",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::stdlib::Header()>::type>(
            &llvm::DenseMapInfo<
                clang::tooling::stdlib::Header>::getTombstoneKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getHashValue() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Header9_getHashValue
    handle.def_static(
        "getHashValue",
        static_cast<pybind11_weaver::FnPtrT<
            void, unsigned int(const clang::tooling::stdlib::Header &)>::type>(
            &llvm::DenseMapInfo<clang::tooling::stdlib::Header>::getHashValue));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isEqual() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Header9_isEqual
    handle.def_static(
        "isEqual",
        static_cast<pybind11_weaver::FnPtrT<
            void, bool(const clang::tooling::stdlib::Header &,
                       const clang::tooling::stdlib::Header &)>::type>(
            &llvm::DenseMapInfo<clang::tooling::stdlib::Header>::isEqual));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Header9(
      EntityScope parent_h)
      : handle{parent_h, "DenseMapInfo6clang_tooling_stdlib_Header9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Header9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getEmptyKey();
    AddMethod_getTombstoneKey();
    AddMethod_getHashValue();
    AddMethod_isEqual();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::DenseMapInfo<clang::tooling::stdlib::Header>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_DenseMapInfo6clang_tooling_stdlib_Header9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Header9

using Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Header9 =
    Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Header9<>;

#else

struct Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Header9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Header9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_DenseMapInfo6clang_tooling_stdlib_Header9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Header9

template <class Pybind11T = pybind11::class_<
              llvm::DenseMapInfo<clang::tooling::stdlib::Symbol>>>
struct Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9 : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::stdlib::Symbol;
  using Enable = void;

  virtual const char *AddMethod_getEmptyKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9_getEmptyKey
    handle.def_static(
        "getEmptyKey",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::stdlib::Symbol()>::type>(
            &llvm::DenseMapInfo<clang::tooling::stdlib::Symbol>::getEmptyKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getTombstoneKey() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9_getTombstoneKey
    handle.def_static(
        "getTombstoneKey",
        static_cast<pybind11_weaver::FnPtrT<
            void, clang::tooling::stdlib::Symbol()>::type>(
            &llvm::DenseMapInfo<
                clang::tooling::stdlib::Symbol>::getTombstoneKey));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_getHashValue() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9_getHashValue
    handle.def_static(
        "getHashValue",
        static_cast<pybind11_weaver::FnPtrT<
            void, unsigned int(const clang::tooling::stdlib::Symbol &)>::type>(
            &llvm::DenseMapInfo<clang::tooling::stdlib::Symbol>::getHashValue));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddMethod_isEqual() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9_isEqual
    handle.def_static(
        "isEqual",
        static_cast<pybind11_weaver::FnPtrT<
            void, bool(const clang::tooling::stdlib::Symbol &,
                       const clang::tooling::stdlib::Symbol &)>::type>(
            &llvm::DenseMapInfo<clang::tooling::stdlib::Symbol>::isEqual));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9(
      EntityScope parent_h)
      : handle{parent_h, "DenseMapInfo6clang_tooling_stdlib_Symbol9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_getEmptyKey();
    AddMethod_getTombstoneKey();
    AddMethod_getHashValue();
    AddMethod_isEqual();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::DenseMapInfo<clang::tooling::stdlib::Symbol>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9

using Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9 =
    Bind_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9<>;

#else

struct Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9

template <class Pybind11T = pybind11::module_>
struct Bind_llvm_yaml : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_llvm_yaml(EntityScope parent_h)
      : handle{
            static_cast<pybind11::module_ &>(parent_h).def_submodule("yaml")} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {}

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "llvm_yaml"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml

using Entity_llvm_yaml = Bind_llvm_yaml<>;

#else

struct Entity_llvm_yaml : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml(EntityScope parent_h) {}
  static const char *Key() { return "llvm_yaml"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml

template <class Pybind11T = pybind11::class_<
              llvm::yaml::MappingTraits<clang::tooling::Diagnostic>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::Diagnostic;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_mapping
    handle.def_static(
        "mapping",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(llvm::yaml::IO &, clang::tooling::Diagnostic &)>::type>(
            &llvm::yaml::MappingTraits<clang::tooling::Diagnostic>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9(
      EntityScope parent_h)
      : handle{parent_h, "MappingTraits6clang_tooling_Diagnostic9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::MappingTraits<clang::tooling::Diagnostic>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Diagnostic9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9

using Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9<>;

#else

struct Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Diagnostic9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9

template <class Pybind11T = pybind11::class_<llvm::yaml::MappingTraits<
              clang::tooling::Diagnostic>::NormalizedDiagnostic>>
struct
    Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_denormalize() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic_denormalize
    handle.def("denormalize",
               static_cast<pybind11_weaver::FnPtrT<
                   llvm::yaml::MappingTraits<
                       clang::tooling::Diagnostic>::NormalizedDiagnostic,
                   clang::tooling::Diagnostic, const llvm::yaml::IO &>::type>(
                   &llvm::yaml::MappingTraits<clang::tooling::Diagnostic>::
                       NormalizedDiagnostic::denormalize));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Helper to (de)serialize a Diagnostic since we don't have direct
  /// access to its data members.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic_Ctor0
    handle.def(pybind11::init<const llvm::yaml::IO &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Helper to (de)serialize a Diagnostic since we don't have direct
  /// access to its data members.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic_Ctor1
    handle.def(pybind11::init<const llvm::yaml::IO &,
                              const clang::tooling::Diagnostic &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic(
      EntityScope parent_h)
      : handle{
            parent_h, "NormalizedDiagnostic", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Helper to (de)serialize a Diagnostic since we don't have direct
  /// access to its data members.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_denormalize();
    AddCtor0();
    AddCtor1();
    handle.def_readwrite(
        "DiagnosticName",
        &llvm::yaml::MappingTraits<
            clang::tooling::Diagnostic>::NormalizedDiagnostic::DiagnosticName);
    handle.def_readwrite(
        "DiagLevel",
        &llvm::yaml::MappingTraits<
            clang::tooling::Diagnostic>::NormalizedDiagnostic::DiagLevel);
    handle.def_readwrite(
        "BuildDirectory",
        &llvm::yaml::MappingTraits<
            clang::tooling::Diagnostic>::NormalizedDiagnostic::BuildDirectory);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_"
           "NormalizedDiagnostic";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic

using Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic =
    Bind_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic<>;

#else

struct
    Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_"
           "NormalizedDiagnostic";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic

template <class Pybind11T = pybind11::class_<
              llvm::yaml::MappingTraits<clang::tooling::DiagnosticMessage>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::DiagnosticMessage;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9_mapping
    handle.def_static(
        "mapping", static_cast<pybind11_weaver::FnPtrT<
                       void, void(llvm::yaml::IO &,
                                  clang::tooling::DiagnosticMessage &)>::type>(
                       &llvm::yaml::MappingTraits<
                           clang::tooling::DiagnosticMessage>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9(
      EntityScope parent_h)
      : handle{parent_h, "MappingTraits6clang_tooling_DiagnosticMessage9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::MappingTraits<clang::tooling::DiagnosticMessage>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9

using Entity_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9<>;

#else

struct Entity_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9

template <class Pybind11T = pybind11::class_<
              llvm::yaml::MappingTraits<clang::tooling::FileByteRange>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::FileByteRange;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9_mapping
    handle.def_static("mapping",
                      static_cast<pybind11_weaver::FnPtrT<
                          void, void(llvm::yaml::IO &,
                                     clang::tooling::FileByteRange &)>::type>(
                          &llvm::yaml::MappingTraits<
                              clang::tooling::FileByteRange>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9(
      EntityScope parent_h)
      : handle{parent_h, "MappingTraits6clang_tooling_FileByteRange9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::MappingTraits<clang::tooling::FileByteRange>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_FileByteRange9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9

using Entity_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9<>;

#else

struct Entity_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_FileByteRange9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9

template <class Pybind11T = pybind11::class_<llvm::yaml::MappingTraits<
              clang::tooling::IncludeStyle::IncludeCategory>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::IncludeStyle::IncludeCategory;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9_mapping
    handle.def_static(
        "mapping",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(llvm::yaml::IO &,
                       clang::tooling::IncludeStyle::IncludeCategory &)>::type>(
            &llvm::yaml::MappingTraits<
                clang::tooling::IncludeStyle::IncludeCategory>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9(
      EntityScope parent_h)
      : handle{parent_h,
               "MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<llvm::yaml::MappingTraits<
        clang::tooling::IncludeStyle::IncludeCategory>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_"
           "IncludeCategory9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9

using Entity_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9<>;

#else

struct
    Entity_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_"
           "IncludeCategory9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9

template <class Pybind11T = pybind11::class_<
              llvm::yaml::MappingTraits<clang::tooling::Replacement>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::Replacement;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Replacement9_mapping
    handle.def_static(
        "mapping",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(llvm::yaml::IO &, clang::tooling::Replacement &)>::type>(
            &llvm::yaml::MappingTraits<clang::tooling::Replacement>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9(
      EntityScope parent_h)
      : handle{
            parent_h, "MappingTraits6clang_tooling_Replacement9",
            pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Specialized MappingTraits to describe how a Replacement is
/// (de)serialized.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::MappingTraits<clang::tooling::Replacement>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Replacement9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9

using Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9<>;

#else

struct Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Replacement9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9

template <class Pybind11T = pybind11::class_<llvm::yaml::MappingTraits<
              clang::tooling::Replacement>::NormalizedReplacement>>
struct
    Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddMethod_denormalize() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement_denormalize
    handle.def("denormalize",
               static_cast<pybind11_weaver::FnPtrT<
                   llvm::yaml::MappingTraits<
                       clang::tooling::Replacement>::NormalizedReplacement,
                   clang::tooling::Replacement, const llvm::yaml::IO &>::type>(
                   &llvm::yaml::MappingTraits<clang::tooling::Replacement>::
                       NormalizedReplacement::denormalize));
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor0() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Helper to (de)serialize a Replacement since we don't have direct
  /// access to its data members.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement_Ctor0
    handle.def(pybind11::init<const llvm::yaml::IO &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  virtual const char *AddCtor1() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/// Helper to (de)serialize a Replacement since we don't have direct
  /// access to its data members.)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement_Ctor1
    handle.def(pybind11::init<const llvm::yaml::IO &,
                              const clang::tooling::Replacement &>(),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement(
      EntityScope parent_h)
      : handle{
            parent_h, "NormalizedReplacement", pybind11::dynamic_attr(),
            R"_pb11_weaver(/// Helper to (de)serialize a Replacement since we don't have direct
  /// access to its data members.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_denormalize();
    AddCtor0();
    AddCtor1();
    handle.def_readwrite(
        "FilePath",
        &llvm::yaml::MappingTraits<
            clang::tooling::Replacement>::NormalizedReplacement::FilePath);
    handle.def_readwrite(
        "Offset",
        &llvm::yaml::MappingTraits<
            clang::tooling::Replacement>::NormalizedReplacement::Offset);
    handle.def_readwrite(
        "Length",
        &llvm::yaml::MappingTraits<
            clang::tooling::Replacement>::NormalizedReplacement::Length);
    handle.def_readwrite(
        "ReplacementText",
        &llvm::yaml::MappingTraits<clang::tooling::Replacement>::
            NormalizedReplacement::ReplacementText);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Replacement9_"
           "NormalizedReplacement";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement

using Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement =
    Bind_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement<>;

#else

struct
    Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_Replacement9_"
           "NormalizedReplacement";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement

template <class Pybind11T = pybind11::class_<llvm::yaml::MappingTraits<
              clang::tooling::TranslationUnitDiagnostics>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::TranslationUnitDiagnostics;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9_mapping
    handle.def_static(
        "mapping",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(llvm::yaml::IO &,
                       clang::tooling::TranslationUnitDiagnostics &)>::type>(
            &llvm::yaml::MappingTraits<
                clang::tooling::TranslationUnitDiagnostics>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9(
      EntityScope parent_h)
      : handle{parent_h,
               "MappingTraits6clang_tooling_TranslationUnitDiagnostics9",
               pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Specialized MappingTraits to describe how a
/// TranslationUnitDiagnostics is (de)serialized.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::MappingTraits<clang::tooling::TranslationUnitDiagnostics>>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9

using Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9<>;

#else

struct Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9

template <class Pybind11T = pybind11::class_<llvm::yaml::MappingTraits<
              clang::tooling::TranslationUnitReplacements>>>
struct Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::TranslationUnitReplacements;

  virtual const char *AddMethod_mapping() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9_mapping
    handle.def_static(
        "mapping",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(llvm::yaml::IO &,
                       clang::tooling::TranslationUnitReplacements &)>::type>(
            &llvm::yaml::MappingTraits<
                clang::tooling::TranslationUnitReplacements>::mapping));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9(
      EntityScope parent_h)
      : handle{parent_h,
               "MappingTraits6clang_tooling_TranslationUnitReplacements9",
               pybind11::dynamic_attr(),
               R"_pb11_weaver(/// Specialized MappingTraits to describe how a
/// TranslationUnitReplacements is (de)serialized.)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_mapping();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::MappingTraits<clang::tooling::TranslationUnitReplacements>>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9

using Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9 =
    Bind_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9<>;

#else

struct Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9

template <
    class Pybind11T = pybind11::class_<
        llvm::yaml::ScalarEnumerationTraits<clang::tooling::Diagnostic::Level>>>
struct Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::Diagnostic::Level;
  using Enable = void;

  virtual const char *AddMethod_enumeration() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9_enumeration
    handle.def_static(
        "enumeration",
        static_cast<pybind11_weaver::FnPtrT<
            void,
            void(llvm::yaml::IO &, clang::tooling::Diagnostic::Level &)>::type>(
            &llvm::yaml::ScalarEnumerationTraits<
                clang::tooling::Diagnostic::Level>::enumeration));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9(
      EntityScope parent_h)
      : handle{parent_h,
               "ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_enumeration();
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::ScalarEnumerationTraits<clang::tooling::Diagnostic::Level>>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9

using Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9 =
    Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9<>;

#else

struct Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9

template <class Pybind11T =
              pybind11::class_<llvm::yaml::ScalarEnumerationTraits<
                  clang::tooling::IncludeStyle::IncludeBlocksStyle>>>
struct
    Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::IncludeStyle::IncludeBlocksStyle;
  using Enable = void;

  virtual const char *AddMethod_enumeration() {

    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9_enumeration
    handle.def_static(
        "enumeration",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(llvm::yaml::IO &, clang::tooling::IncludeStyle::
                                             IncludeBlocksStyle &)>::type>(
            &llvm::yaml::ScalarEnumerationTraits<
                clang::tooling::IncludeStyle::IncludeBlocksStyle>::
                enumeration));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9(
      EntityScope parent_h)
      : handle{parent_h,
               "ScalarEnumerationTraits6clang_tooling_IncludeStyle_"
               "IncludeBlocksStyle9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    AddMethod_enumeration();
    pybind11_weaver::TryAddDefaultCtor<llvm::yaml::ScalarEnumerationTraits<
        clang::tooling::IncludeStyle::IncludeBlocksStyle>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_"
           "IncludeBlocksStyle9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9

using Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9 =
    Bind_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9<>;

#else

struct
    Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_"
           "IncludeBlocksStyle9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9

template <class Pybind11T = pybind11::class_<
              llvm::yaml::SequenceElementTraits<clang::tooling::Diagnostic>>>
struct Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::Diagnostic;
  using EnableIf = void;

  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9(
      EntityScope parent_h)
      : handle{parent_h, "SequenceElementTraits6clang_tooling_Diagnostic9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::SequenceElementTraits<clang::tooling::Diagnostic>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9

using Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9 =
    Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9<>;

#else

struct Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9

template <class Pybind11T = pybind11::class_<llvm::yaml::SequenceElementTraits<
              clang::tooling::DiagnosticMessage>>>
struct Bind_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::DiagnosticMessage;
  using EnableIf = void;

  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9(
      EntityScope parent_h)
      : handle{parent_h,
               "SequenceElementTraits6clang_tooling_DiagnosticMessage9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::SequenceElementTraits<clang::tooling::DiagnosticMessage>>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9

using Entity_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9 =
    Bind_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9<>;

#else

struct Entity_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9

template <class Pybind11T = pybind11::class_<
              llvm::yaml::SequenceElementTraits<clang::tooling::FileByteRange>>>
struct Bind_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::FileByteRange;
  using EnableIf = void;

  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9(
      EntityScope parent_h)
      : handle{parent_h, "SequenceElementTraits6clang_tooling_FileByteRange9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::SequenceElementTraits<clang::tooling::FileByteRange>>(
        handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9

using Entity_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9 =
    Bind_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9<>;

#else

struct Entity_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9

template <class Pybind11T = pybind11::class_<llvm::yaml::SequenceElementTraits<
              clang::tooling::IncludeStyle::IncludeCategory>>>
struct
    Bind_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::IncludeStyle::IncludeCategory;
  using EnableIf = void;

  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9(
      EntityScope parent_h)
      : handle{
            parent_h,
            "SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9",
            pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<llvm::yaml::SequenceElementTraits<
        clang::tooling::IncludeStyle::IncludeCategory>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_"
           "IncludeCategory9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9

using Entity_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9 =
    Bind_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9<>;

#else

struct
    Entity_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_"
           "IncludeCategory9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9

template <class Pybind11T = pybind11::class_<
              llvm::yaml::SequenceElementTraits<clang::tooling::Replacement>>>
struct Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9
    : public EntityBase {
  using Pybind11Type = Pybind11T;
  using T = clang::tooling::Replacement;
  using EnableIf = void;

  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9(
      EntityScope parent_h)
      : handle{parent_h, "SequenceElementTraits6clang_tooling_Replacement9",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<
        llvm::yaml::SequenceElementTraits<clang::tooling::Replacement>>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9

using Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9 =
    Bind_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9<>;

#else

struct Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9(
      EntityScope parent_h) {}
  static const char *Key() {
    return "llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9

/**
 * Create all entities, return a callable guard that can be called to update all
 *entities. If the returned guard is not called, the guard will call the update
 *function on its destruction.
 **/
[[nodiscard]] pybind11_weaver::CallUpdateGuard
DeclFn(pybind11::module &m,
       const pybind11_weaver::CustomBindingRegistry &registry) {
  pybind11_weaver::_PointerWrapperBase::FastBind(m);
  pybind11_weaver::PointerWrapper<clang::Decl *>::FastBind(m, "clang_Decl__");
  pybind11_weaver::PointerWrapper<clang::driver::Compilation *>::FastBind(
      m, "clang_driver_Compilation__");
  pybind11_weaver::PointerWrapper<clang::syntax::Declaration *>::FastBind(
      m, "clang_syntax_Declaration__");
  pybind11_weaver::PointerWrapper<clang::syntax::EmptyStatement *>::FastBind(
      m, "clang_syntax_EmptyStatement__");
  pybind11_weaver::PointerWrapper<clang::syntax::Expression *>::FastBind(
      m, "clang_syntax_Expression__");
  pybind11_weaver::PointerWrapper<clang::syntax::Leaf *>::FastBind(
      m, "clang_syntax_Leaf__");
  pybind11_weaver::PointerWrapper<clang::syntax::Node *>::FastBind(
      m, "clang_syntax_Node__");
  pybind11_weaver::PointerWrapper<clang::syntax::ParameterDeclarationList *>::
      FastBind(m, "clang_syntax_ParameterDeclarationList__");
  pybind11_weaver::PointerWrapper<clang::syntax::SimpleDeclarator *>::FastBind(
      m, "clang_syntax_SimpleDeclarator__");
  pybind11_weaver::PointerWrapper<clang::syntax::Statement *>::FastBind(
      m, "clang_syntax_Statement__");
  pybind11_weaver::PointerWrapper<clang::syntax::TrailingReturnType *>::
      FastBind(m, "clang_syntax_TrailingReturnType__");
  pybind11_weaver::PointerWrapper<clang::syntax::TranslationUnit *>::FastBind(
      m, "clang_syntax_TranslationUnit__");
  pybind11_weaver::PointerWrapper<clang::syntax::Tree *>::FastBind(
      m, "clang_syntax_Tree__");
  pybind11_weaver::PointerWrapper<const char **>::FastBind(m, "const_char___");
  pybind11_weaver::PointerWrapper<const clang::Decl *>::FastBind(
      m, "const_clang_Decl__");
  pybind11_weaver::PointerWrapper<const clang::Expr *>::FastBind(
      m, "const_clang_Expr__");
  pybind11_weaver::PointerWrapper<const clang::NamedDecl *>::FastBind(
      m, "const_clang_NamedDecl__");
  pybind11_weaver::PointerWrapper<const clang::Stmt *>::FastBind(
      m, "const_clang_Stmt__");
  pybind11_weaver::PointerWrapper<const clang::syntax::Leaf *>::FastBind(
      m, "const_clang_syntax_Leaf__");
  pybind11_weaver::PointerWrapper<const clang::syntax::Node *>::FastBind(
      m, "const_clang_syntax_Node__");
  pybind11_weaver::PointerWrapper<const clang::syntax::Tree *>::FastBind(
      m, "const_clang_syntax_Tree__");
  pybind11_weaver::PointerWrapper<const llvm::SmallVector<const char *, 16> *>::
      FastBind(m, "const_llvm_SmallVector6const_char____169__");

  auto v0 =
      pybind11_weaver::CreateEntity<Entity_clang>(EntityScope(m), registry);
  auto v1 =
      pybind11_weaver::CreateEntity<Entity_clang_diff>(v0->AsScope(), registry);
  auto v2 = pybind11_weaver::CreateEntity<Entity_clang_diff_ASTDiff>(
      v1->AsScope(), registry);
  auto v3 = pybind11_weaver::CreateEntity<Entity_clang_diff_ChangeKind>(
      v1->AsScope(), registry);
  auto v4 = pybind11_weaver::CreateEntity<Entity_clang_diff_ComparisonOptions>(
      v1->AsScope(), registry);
  auto v5 = pybind11_weaver::CreateEntity<Entity_clang_diff_Node>(v1->AsScope(),
                                                                  registry);
  auto v6 = pybind11_weaver::CreateEntity<Entity_clang_diff_NodeId>(
      v1->AsScope(), registry);
  auto v7 = pybind11_weaver::CreateEntity<Entity_clang_diff_SyntaxTree>(
      v1->AsScope(), registry);
  auto v8 = pybind11_weaver::CreateEntity<Entity_clang_driver>(v0->AsScope(),
                                                               registry);
  auto v9 = pybind11_weaver::CreateEntity<Entity_clang_syntax>(v0->AsScope(),
                                                               registry);
  auto v10 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Arena>(
      v9->AsScope(), registry);
  auto v11 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_BinaryOperatorExpression>(v9->AsScope(), registry);
  auto v12 = pybind11_weaver::CreateEntity<Entity_clang_syntax_FileRange>(
      v9->AsScope(), registry);
  auto v13 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Node>(
      v9->AsScope(), registry);
  auto v14 = pybind11_weaver::CreateEntity<Entity_clang_syntax_NodeKind>(
      v9->AsScope(), registry);
  auto v15 = pybind11_weaver::CreateEntity<Entity_clang_syntax_NodeRole>(
      v9->AsScope(), registry);
  auto v16 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Token>(
      v9->AsScope(), registry);
  auto v17 = pybind11_weaver::CreateEntity<Entity_clang_syntax_TokenBuffer>(
      v9->AsScope(), registry);
  auto v18 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_TokenBuffer_Expansion>(
          v17->AsScope(), registry);
  auto v19 = pybind11_weaver::CreateEntity<Entity_clang_syntax_TokenCollector>(
      v9->AsScope(), registry);
  auto v20 = pybind11_weaver::CreateEntity<Entity_clang_syntax_TokenManager>(
      v9->AsScope(), registry);
  auto v21 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Tree>(
      v9->AsScope(), registry);
  auto v22 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_Tree_ChildIterator>(
          v21->AsScope(), registry);
  auto v23 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_Tree_ConstChildIterator>(v21->AsScope(), registry);
  auto v24 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_UnaryOperatorExpression>(v9->AsScope(), registry);
  auto v25 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_UnknownExpression>(
          v9->AsScope(), registry);
  auto v26 = pybind11_weaver::CreateEntity<Entity_clang_syntax_UnqualifiedId>(
      v9->AsScope(), registry);
  auto v27 = pybind11_weaver::CreateEntity<Entity_buildSyntaxTree>(
      v9->AsScope(), registry);
  auto v28 = pybind11_weaver::CreateEntity<Entity_computeReplacements>(
      v9->AsScope(), registry);
  auto v29 = pybind11_weaver::CreateEntity<Entity_createEmptyStatement>(
      v9->AsScope(), registry);
  auto v30 = pybind11_weaver::CreateEntity<Entity_createLeaf1>(v9->AsScope(),
                                                               registry);
  auto v31 =
      pybind11_weaver::CreateEntity<Entity_createLeaf>(v9->AsScope(), registry);
  auto v32 =
      pybind11_weaver::CreateEntity<Entity_createTree>(v9->AsScope(), registry);
  auto v33 = pybind11_weaver::CreateEntity<Entity_deepCopyExpandingMacros>(
      v9->AsScope(), registry);
  auto v34 = pybind11_weaver::CreateEntity<Entity_removeStatement>(
      v9->AsScope(), registry);
  auto v35 = pybind11_weaver::CreateEntity<Entity_spelledIdentifierTouching1>(
      v9->AsScope(), registry);
  auto v36 = pybind11_weaver::CreateEntity<Entity_spelledIdentifierTouching>(
      v9->AsScope(), registry);
  auto v37 = pybind11_weaver::CreateEntity<Entity_spelledTokensTouching>(
      v9->AsScope(), registry);
  auto v38 = pybind11_weaver::CreateEntity<Entity_spelledTokensTouching1>(
      v9->AsScope(), registry);
  auto v39 =
      pybind11_weaver::CreateEntity<Entity_tokenize>(v9->AsScope(), registry);
  auto v40 =
      pybind11_weaver::CreateEntity<Entity_tokenize1>(v9->AsScope(), registry);
  auto v41 = pybind11_weaver::CreateEntity<Entity_clang_syntax_ArraySubscript>(
      v9->AsScope(), registry);
  auto v42 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Declaration>(
      v9->AsScope(), registry);
  auto v43 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Declarator>(
      v9->AsScope(), registry);
  auto v44 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_EmptyDeclaration>(
          v9->AsScope(), registry);
  auto v45 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_ExplicitTemplateInstantiation>(v9->AsScope(),
                                                         registry);
  auto v46 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Leaf>(
      v9->AsScope(), registry);
  auto v47 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_LinkageSpecificationDeclaration>(v9->AsScope(),
                                                           registry);
  auto v48 = pybind11_weaver::CreateEntity<Entity_clang_syntax_List>(
      v9->AsScope(), registry);
  auto v49 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_List_TerminationKind>(
          v48->AsScope(), registry);
  auto v50 = pybind11_weaver::CreateEntity<Entity_clang_syntax_MemberPointer>(
      v9->AsScope(), registry);
  auto v51 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_NamespaceAliasDefinition>(v9->AsScope(), registry);
  auto v52 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_NamespaceDefinition>(
          v9->AsScope(), registry);
  auto v53 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_NestedNameSpecifier>(
          v9->AsScope(), registry);
  auto v54 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_ParameterDeclarationList>(v9->AsScope(), registry);
  auto v55 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_ParametersAndQualifiers>(v9->AsScope(), registry);
  auto v56 = pybind11_weaver::CreateEntity<Entity_clang_syntax_ParenDeclarator>(
      v9->AsScope(), registry);
  auto v57 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_PostfixUnaryOperatorExpression>(v9->AsScope(),
                                                          registry);
  auto v58 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_PrefixUnaryOperatorExpression>(v9->AsScope(),
                                                         registry);
  auto v59 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_SimpleDeclaration>(
          v9->AsScope(), registry);
  auto v60 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_SimpleDeclarator>(
          v9->AsScope(), registry);
  auto v61 = pybind11_weaver::CreateEntity<Entity_clang_syntax_Statement>(
      v9->AsScope(), registry);
  auto v62 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_StaticAssertDeclaration>(v9->AsScope(), registry);
  auto v63 = pybind11_weaver::CreateEntity<Entity_clang_syntax_SwitchStatement>(
      v9->AsScope(), registry);
  auto v64 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_TemplateDeclaration>(
          v9->AsScope(), registry);
  auto v65 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_TokenBufferTokenManager>(v9->AsScope(), registry);
  auto v66 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_TrailingReturnType>(
          v9->AsScope(), registry);
  auto v67 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_TypeAliasDeclaration>(
          v9->AsScope(), registry);
  auto v68 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_UnknownDeclaration>(
          v9->AsScope(), registry);
  auto v69 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_UnknownStatement>(
          v9->AsScope(), registry);
  auto v70 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_UsingDeclaration>(
          v9->AsScope(), registry);
  auto v71 = pybind11_weaver::CreateEntity<
      Entity_clang_syntax_UsingNamespaceDirective>(v9->AsScope(), registry);
  auto v72 = pybind11_weaver::CreateEntity<Entity_clang_syntax_WhileStatement>(
      v9->AsScope(), registry);
  auto v73 = pybind11_weaver::CreateEntity<Entity_clang_syntax_BreakStatement>(
      v9->AsScope(), registry);
  auto v74 = pybind11_weaver::CreateEntity<Entity_clang_syntax_CallArguments>(
      v9->AsScope(), registry);
  auto v75 = pybind11_weaver::CreateEntity<Entity_clang_syntax_CaseStatement>(
      v9->AsScope(), registry);
  auto v76 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_CompoundStatement>(
          v9->AsScope(), registry);
  auto v77 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_ContinueStatement>(
          v9->AsScope(), registry);
  auto v78 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_DeclarationStatement>(
          v9->AsScope(), registry);
  auto v79 = pybind11_weaver::CreateEntity<Entity_clang_syntax_DeclaratorList>(
      v9->AsScope(), registry);
  auto v80 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_DefaultStatement>(
          v9->AsScope(), registry);
  auto v81 = pybind11_weaver::CreateEntity<Entity_clang_syntax_EmptyStatement>(
      v9->AsScope(), registry);
  auto v82 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_ExpressionStatement>(
          v9->AsScope(), registry);
  auto v83 = pybind11_weaver::CreateEntity<Entity_clang_syntax_ForStatement>(
      v9->AsScope(), registry);
  auto v84 = pybind11_weaver::CreateEntity<Entity_clang_syntax_IfStatement>(
      v9->AsScope(), registry);
  auto v85 =
      pybind11_weaver::CreateEntity<Entity_clang_syntax_RangeBasedForStatement>(
          v9->AsScope(), registry);
  auto v86 = pybind11_weaver::CreateEntity<Entity_clang_syntax_ReturnStatement>(
      v9->AsScope(), registry);
  auto v87 = pybind11_weaver::CreateEntity<Entity_clang_tooling>(v0->AsScope(),
                                                                 registry);
  auto v88 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ASTMatchRefactorer>(
          v87->AsScope(), registry);
  auto v89 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ApplyChangesSpec>(
          v87->AsScope(), registry);
  auto v90 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ApplyChangesSpec_FormatOption>(v89->AsScope(),
                                                          registry);
  auto v91 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ArgumentInsertPosition>(v87->AsScope(), registry);
  auto v92 = pybind11_weaver::CreateEntity<Entity_clang_tooling_AtomicChange>(
      v87->AsScope(), registry);
  auto v93 = pybind11_weaver::CreateEntity<Entity_clang_tooling_ClangTool>(
      v87->AsScope(), registry);
  auto v94 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_CodeRangeASTSelection>(
          v87->AsScope(), registry);
  auto v95 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_CommonOptionsParser>(
          v87->AsScope(), registry);
  auto v96 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_CompilationDatabase>(
          v87->AsScope(), registry);
  auto v97 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_CompilationDatabasePlugin>(v87->AsScope(), registry);
  auto v98 = pybind11_weaver::CreateEntity<Entity_clang_tooling_CompileCommand>(
      v87->AsScope(), registry);
  auto v99 = pybind11_weaver::CreateEntity<Entity_clang_tooling_Diagnostic>(
      v87->AsScope(), registry);
  auto v100 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_Diagnostic_Level>(
          v99->AsScope(), registry);
  auto v101 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_DiagnosticMessage>(
          v87->AsScope(), registry);
  auto v102 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ExecutionContext>(
          v87->AsScope(), registry);
  auto v103 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ExtractionSemicolonPolicy>(v87->AsScope(), registry);
  auto v104 = pybind11_weaver::CreateEntity<Entity_clang_tooling_FileByteRange>(
      v87->AsScope(), registry);
  auto v105 = pybind11_weaver::CreateEntity<Entity_clang_tooling_FileMatchTrie>(
      v87->AsScope(), registry);
  auto v106 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_FixedCompilationDatabase>(v87->AsScope(), registry);
  auto v107 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_HeaderIncludes>(
          v87->AsScope(), registry);
  auto v108 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_IncludeCategoryManager>(v87->AsScope(), registry);
  auto v109 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_IncludeDirective>(
          v87->AsScope(), registry);
  auto v110 = pybind11_weaver::CreateEntity<Entity_clang_tooling_IncludeStyle>(
      v87->AsScope(), registry);
  auto v111 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_IncludeStyle_IncludeBlocksStyle>(v110->AsScope(),
                                                            registry);
  auto v112 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_IncludeStyle_IncludeCategory>(v110->AsScope(),
                                                         registry);
  auto v113 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_JSONCommandLineSyntax>(
          v87->AsScope(), registry);
  auto v114 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_JSONCompilationDatabase>(v87->AsScope(), registry);
  auto v115 = pybind11_weaver::CreateEntity<Entity_clang_tooling_LocationCall>(
      v87->AsScope(), registry);
  auto v116 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_LocationCall_LocationCallFlags>(v115->AsScope(),
                                                           registry);
  auto v117 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_LocationCallFormatterCpp>(v87->AsScope(), registry);
  auto v118 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_NodeIntrospection>(
          v87->AsScope(), registry);
  auto v119 = pybind11_weaver::CreateEntity<Entity_GetLocations5>(
      v118->AsScope(), registry);
  auto v120 = pybind11_weaver::CreateEntity<Entity_GetLocations2>(
      v118->AsScope(), registry);
  auto v121 = pybind11_weaver::CreateEntity<Entity_GetLocations1>(
      v118->AsScope(), registry);
  auto v122 = pybind11_weaver::CreateEntity<Entity_GetLocations7>(
      v118->AsScope(), registry);
  auto v123 = pybind11_weaver::CreateEntity<Entity_GetLocations8>(
      v118->AsScope(), registry);
  auto v124 = pybind11_weaver::CreateEntity<Entity_GetLocations3>(
      v118->AsScope(), registry);
  auto v125 = pybind11_weaver::CreateEntity<Entity_GetLocations>(
      v118->AsScope(), registry);
  auto v126 = pybind11_weaver::CreateEntity<Entity_GetLocations4>(
      v118->AsScope(), registry);
  auto v127 = pybind11_weaver::CreateEntity<Entity_GetLocations6>(
      v118->AsScope(), registry);
  auto v128 = pybind11_weaver::CreateEntity<Entity_hasIntrospectionSupport>(
      v118->AsScope(), registry);
  auto v129 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_NodeLocationAccessors>(
          v87->AsScope(), registry);
  auto v130 = pybind11_weaver::CreateEntity<Entity_clang_tooling_PLTClass>(
      v87->AsScope(), registry);
  auto v131 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_PathComparator>(
          v87->AsScope(), registry);
  auto v132 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_QualifiedRenamingAction>(v87->AsScope(), registry);
  auto v133 = pybind11_weaver::CreateEntity<Entity_clang_tooling_Range>(
      v87->AsScope(), registry);
  auto v134 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RefactoringAction>(
          v87->AsScope(), registry);
  auto v135 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_RefactoringActionRuleBase>(v87->AsScope(), registry);
  auto v136 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_RefactoringActionRuleRequirement>(v87->AsScope(),
                                                             registry);
  auto v137 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RefactoringCallback>(
          v87->AsScope(), registry);
  auto v138 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RefactoringDescriptor>(
          v87->AsScope(), registry);
  auto v139 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RefactoringOption>(
          v87->AsScope(), registry);
  auto v140 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_RefactoringOptionVisitor>(v87->AsScope(), registry);
  auto v141 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_RefactoringOptionsRequirement>(v87->AsScope(),
                                                          registry);
  auto v142 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_RefactoringResultConsumer>(v87->AsScope(), registry);
  auto v143 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_RefactoringRuleContext>(v87->AsScope(), registry);
  auto v144 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RefactoringTool>(
          v87->AsScope(), registry);
  auto v145 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RenamingAction>(
          v87->AsScope(), registry);
  auto v146 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ReplaceIfStmtWithItsBody>(v87->AsScope(), registry);
  auto v147 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ReplaceNodeWithTemplate>(v87->AsScope(), registry);
  auto v148 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ReplaceStmtWithStmt>(
          v87->AsScope(), registry);
  auto v149 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ReplaceStmtWithText>(
          v87->AsScope(), registry);
  auto v150 = pybind11_weaver::CreateEntity<Entity_clang_tooling_Replacement>(
      v87->AsScope(), registry);
  auto v151 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ReplacementError>(
          v87->AsScope(), registry);
  auto v152 = pybind11_weaver::CreateEntity<Entity_clang_tooling_Replacements>(
      v87->AsScope(), registry);
  auto v153 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_SelectedASTNode>(
          v87->AsScope(), registry);
  auto v154 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_SourceChangeRefactoringRule>(v87->AsScope(),
                                                        registry);
  auto v155 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_SourceFileCallbacks>(
          v87->AsScope(), registry);
  auto v156 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_SourceSelectionKind>(
          v87->AsScope(), registry);
  auto v157 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_SourceSelectionRequirement>(v87->AsScope(),
                                                       registry);
  auto v158 = pybind11_weaver::CreateEntity<Entity_clang_tooling_SymbolName>(
      v87->AsScope(), registry);
  auto v159 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_SymbolOccurrence>(
          v87->AsScope(), registry);
  auto v160 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_SymbolOccurrence_OccurrenceKind>(v159->AsScope(),
                                                            registry);
  auto v161 = pybind11_weaver::CreateEntity<Entity_clang_tooling_ToolAction>(
      v87->AsScope(), registry);
  auto v162 = pybind11_weaver::CreateEntity<Entity_clang_tooling_ToolExecutor>(
      v87->AsScope(), registry);
  auto v163 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ToolExecutorPlugin>(
          v87->AsScope(), registry);
  auto v164 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ToolInvocation>(
          v87->AsScope(), registry);
  auto v165 = pybind11_weaver::CreateEntity<Entity_clang_tooling_ToolResults>(
      v87->AsScope(), registry);
  auto v166 = pybind11_weaver::CreateEntity<Entity_clang_tooling_Transformer>(
      v87->AsScope(), registry);
  auto v167 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_TransformerResult6void9>(v87->AsScope(), registry);
  auto v168 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_TranslationUnitDiagnostics>(v87->AsScope(),
                                                       registry);
  auto v169 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_TranslationUnitReplacements>(v87->AsScope(),
                                                        registry);
  auto v170 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_USRFindingAction>(
          v87->AsScope(), registry);
  auto v171 = pybind11_weaver::CreateEntity<Entity_addExpandedResponseFiles>(
      v87->AsScope(), registry);
  auto v172 =
      pybind11_weaver::CreateEntity<Entity_addTargetAndModeForProgramName>(
          v87->AsScope(), registry);
  auto v173 = pybind11_weaver::CreateEntity<Entity_applyAllReplacements1>(
      v87->AsScope(), registry);
  auto v174 = pybind11_weaver::CreateEntity<Entity_applyAllReplacements>(
      v87->AsScope(), registry);
  auto v175 = pybind11_weaver::CreateEntity<Entity_applyAtomicChanges>(
      v87->AsScope(), registry);
  auto v176 = pybind11_weaver::CreateEntity<Entity_buildASTFromCode>(
      v87->AsScope(), registry);
  auto v177 = pybind11_weaver::CreateEntity<Entity_buildASTFromCodeWithArgs>(
      v87->AsScope(), registry);
  auto v178 = pybind11_weaver::CreateEntity<Entity_buildAccess>(v87->AsScope(),
                                                                registry);
  auto v179 = pybind11_weaver::CreateEntity<Entity_buildAddressOf>(
      v87->AsScope(), registry);
  auto v180 = pybind11_weaver::CreateEntity<Entity_buildArrow>(v87->AsScope(),
                                                               registry);
  auto v181 = pybind11_weaver::CreateEntity<Entity_buildDereference>(
      v87->AsScope(), registry);
  auto v182 =
      pybind11_weaver::CreateEntity<Entity_buildDot>(v87->AsScope(), registry);
  auto v183 = pybind11_weaver::CreateEntity<Entity_buildParens>(v87->AsScope(),
                                                                registry);
  auto v184 =
      pybind11_weaver::CreateEntity<Entity_calculateRangesAfterReplacements>(
          v87->AsScope(), registry);
  auto v185 = pybind11_weaver::CreateEntity<Entity_codeContainsImports>(
      v87->AsScope(), registry);
  auto v186 = pybind11_weaver::CreateEntity<Entity_combineAdjusters>(
      v87->AsScope(), registry);
  auto v187 =
      pybind11_weaver::CreateEntity<Entity_createExecutorFromCommandLineArgs>(
          v87->AsScope(), registry);
  auto v188 = pybind11_weaver::CreateEntity<Entity_createRefactoringActions>(
      v87->AsScope(), registry);
  auto v189 = pybind11_weaver::CreateEntity<Entity_createRenameAtomicChanges>(
      v87->AsScope(), registry);
  auto v190 = pybind11_weaver::CreateEntity<Entity_createRenameReplacements>(
      v87->AsScope(), registry);
  auto v191 = pybind11_weaver::CreateEntity<Entity_clang_tooling_dependencies>(
      v87->AsScope(), registry);
  auto v192 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_CachedFileContents>(v191->AsScope(),
                                                            registry);
  auto v193 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_CachedFileSystemEntry>(v191->AsScope(),
                                                               registry);
  auto v194 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_dependencies_Command>(
          v191->AsScope(), registry);
  auto v195 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyActionController>(
      v191->AsScope(), registry);
  auto v196 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyConsumer>(v191->AsScope(),
                                                            registry);
  auto v197 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningFilesystemLocalCache>(
      v191->AsScope(), registry);
  auto v198 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache>(
      v191->AsScope(), registry);
  auto v199 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningFilesystemSharedCache_CacheShard>(
      v198->AsScope(), registry);
  auto v200 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningService>(
      v191->AsScope(), registry);
  auto v201 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningTool>(v191->AsScope(),
                                                                registry);
  auto v202 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningWorker>(
      v191->AsScope(), registry);
  auto v203 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_DependencyScanningWorkerFilesystem>(
      v191->AsScope(), registry);
  auto v204 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_dependencies_EntryRef>(
          v191->AsScope(), registry);
  auto v205 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_FullDependencyConsumer>(v191->AsScope(),
                                                                registry);
  auto v206 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_ModuleDepCollector>(v191->AsScope(),
                                                            registry);
  auto v207 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_ModuleDepCollectorPP>(v191->AsScope(),
                                                              registry);
  auto v208 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_ModuleDeps>(v191->AsScope(), registry);
  auto v209 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_dependencies_ModuleID>(
          v191->AsScope(), registry);
  auto v210 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_ModuleOutputKind>(v191->AsScope(),
                                                          registry);
  auto v211 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_P1689ModuleInfo>(v191->AsScope(),
                                                         registry);
  auto v212 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_P1689ModuleInfo_ModuleType>(
      v211->AsScope(), registry);
  auto v213 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_P1689Rule>(v191->AsScope(), registry);
  auto v214 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_PrebuiltModuleDep>(v191->AsScope(),
                                                           registry);
  auto v215 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_ScanningMode>(v191->AsScope(),
                                                      registry);
  auto v216 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_ScanningOutputFormat>(v191->AsScope(),
                                                              registry);
  auto v217 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_TranslationUnitDeps>(v191->AsScope(),
                                                             registry);
  auto v218 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_dependencies_CallbackActionController>(
      v191->AsScope(), registry);
  auto v219 = pybind11_weaver::CreateEntity<Entity_clang_tooling_detail>(
      v87->AsScope(), registry);
  auto v220 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_detail_TransformerImpl>(v219->AsScope(), registry);
  auto v221 = pybind11_weaver::CreateEntity<Entity_expandResponseFiles>(
      v87->AsScope(), registry);
  auto v222 = pybind11_weaver::CreateEntity<Entity_findSelectedASTNodes>(
      v87->AsScope(), registry);
  auto v223 = pybind11_weaver::CreateEntity<Entity_clang_tooling_fixit>(
      v87->AsScope(), registry);
  auto v224 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_fixit_internal>(
          v223->AsScope(), registry);
  auto v225 = pybind11_weaver::CreateEntity<Entity_getSourceRange1>(
      v224->AsScope(), registry);
  auto v226 = pybind11_weaver::CreateEntity<Entity_getSourceRange>(
      v224->AsScope(), registry);
  auto v227 =
      pybind11_weaver::CreateEntity<Entity_getText1>(v224->AsScope(), registry);
  auto v228 =
      pybind11_weaver::CreateEntity<Entity_formatAndApplyAllReplacements>(
          v87->AsScope(), registry);
  auto v229 = pybind11_weaver::CreateEntity<Entity_getAbsolutePath>(
      v87->AsScope(), registry);
  auto v230 = pybind11_weaver::CreateEntity<Entity_getAbsolutePath1>(
      v87->AsScope(), registry);
  auto v231 = pybind11_weaver::CreateEntity<Entity_getAssociatedRange>(
      v87->AsScope(), registry);
  auto v232 = pybind11_weaver::CreateEntity<Entity_getCC1Arguments>(
      v87->AsScope(), registry);
  auto v233 =
      pybind11_weaver::CreateEntity<Entity_getCanonicalSymbolDeclaration>(
          v87->AsScope(), registry);
  auto v234 =
      pybind11_weaver::CreateEntity<Entity_getClangStripDependencyFileAdjuster>(
          v87->AsScope(), registry);
  auto v235 = pybind11_weaver::CreateEntity<Entity_getClangStripOutputAdjuster>(
      v87->AsScope(), registry);
  auto v236 = pybind11_weaver::CreateEntity<Entity_getClangSyntaxOnlyAdjuster>(
      v87->AsScope(), registry);
  auto v237 = pybind11_weaver::CreateEntity<Entity_getFileRange1>(
      v87->AsScope(), registry);
  auto v238 = pybind11_weaver::CreateEntity<Entity_getFileRange>(v87->AsScope(),
                                                                 registry);
  auto v239 = pybind11_weaver::CreateEntity<Entity_getFileRangeForEdit1>(
      v87->AsScope(), registry);
  auto v240 = pybind11_weaver::CreateEntity<Entity_getFileRangeForEdit>(
      v87->AsScope(), registry);
  auto v241 = pybind11_weaver::CreateEntity<Entity_getInsertArgumentAdjuster>(
      v87->AsScope(), registry);
  auto v242 = pybind11_weaver::CreateEntity<Entity_getInsertArgumentAdjuster1>(
      v87->AsScope(), registry);
  auto v243 = pybind11_weaver::CreateEntity<Entity_getNamedDeclAt>(
      v87->AsScope(), registry);
  auto v244 = pybind11_weaver::CreateEntity<Entity_getNamedDeclFor>(
      v87->AsScope(), registry);
  auto v245 = pybind11_weaver::CreateEntity<Entity_getOccurrencesOfUSRs>(
      v87->AsScope(), registry);
  auto v246 = pybind11_weaver::CreateEntity<Entity_getStripPluginsAdjuster>(
      v87->AsScope(), registry);
  auto v247 =
      pybind11_weaver::CreateEntity<Entity_getText>(v87->AsScope(), registry);
  auto v248 = pybind11_weaver::CreateEntity<Entity_getUSRForDecl>(
      v87->AsScope(), registry);
  auto v249 = pybind11_weaver::CreateEntity<Entity_getUSRsForDeclaration>(
      v87->AsScope(), registry);
  auto v250 = pybind11_weaver::CreateEntity<Entity_groupReplacementsByFile>(
      v87->AsScope(), registry);
  auto v251 = pybind11_weaver::CreateEntity<Entity_inferMissingCompileCommands>(
      v87->AsScope(), registry);
  auto v252 = pybind11_weaver::CreateEntity<Entity_inferTargetAndDriverMode>(
      v87->AsScope(), registry);
  auto v253 = pybind11_weaver::CreateEntity<Entity_clang_tooling_internal>(
      v87->AsScope(), registry);
  auto v254 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_internal_RangeLessThan>(v253->AsScope(), registry);
  auto v255 = pybind11_weaver::CreateEntity<
      Entity_createExecutorFromCommandLineArgsImpl>(v253->AsScope(), registry);
  auto v256 = pybind11_weaver::CreateEntity<Entity_findError>(v253->AsScope(),
                                                              registry);
  auto v257 = pybind11_weaver::CreateEntity<Entity_ignoreError>(v253->AsScope(),
                                                                registry);
  auto v258 = pybind11_weaver::CreateEntity<Entity_visitRefactoringOptionsImpl>(
      v253->AsScope(), registry);
  auto v259 = pybind11_weaver::CreateEntity<Entity_isKnownPointerLikeType>(
      v87->AsScope(), registry);
  auto v260 = pybind11_weaver::CreateEntity<Entity_isSelfContainedHeader>(
      v87->AsScope(), registry);
  auto v261 = pybind11_weaver::CreateEntity<Entity_mayEverNeedParens>(
      v87->AsScope(), registry);
  auto v262 = pybind11_weaver::CreateEntity<Entity_maybeExtendRange>(
      v87->AsScope(), registry);
  auto v263 =
      pybind11_weaver::CreateEntity<Entity_needParensAfterUnaryOperator>(
          v87->AsScope(), registry);
  auto v264 = pybind11_weaver::CreateEntity<Entity_needParensBeforeDotOrArrow>(
      v87->AsScope(), registry);
  auto v265 = pybind11_weaver::CreateEntity<Entity_newInvocation>(
      v87->AsScope(), registry);
  auto v266 = pybind11_weaver::CreateEntity<Entity_parseIWYUPragma>(
      v87->AsScope(), registry);
  auto v267 = pybind11_weaver::CreateEntity<Entity_reallyIgnoreImplicit>(
      v87->AsScope(), registry);
  auto v268 = pybind11_weaver::CreateEntity<Entity_replaceNestedName>(
      v87->AsScope(), registry);
  auto v269 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_replacement_error>(
          v87->AsScope(), registry);
  auto v270 = pybind11_weaver::CreateEntity<Entity_runToolOnCode>(
      v87->AsScope(), registry);
  auto v271 = pybind11_weaver::CreateEntity<Entity_runToolOnCodeWithArgs>(
      v87->AsScope(), registry);
  auto v272 = pybind11_weaver::CreateEntity<Entity_runToolOnCodeWithArgs1>(
      v87->AsScope(), registry);
  auto v273 = pybind11_weaver::CreateEntity<Entity_selectFirstFix>(
      v87->AsScope(), registry);
  auto v274 = pybind11_weaver::CreateEntity<Entity_clang_tooling_stdlib>(
      v87->AsScope(), registry);
  auto v275 = pybind11_weaver::CreateEntity<Entity_clang_tooling_stdlib_Header>(
      v274->AsScope(), registry);
  auto v276 = pybind11_weaver::CreateEntity<Entity_clang_tooling_stdlib_Lang>(
      v274->AsScope(), registry);
  auto v277 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_stdlib_Recognizer>(
          v274->AsScope(), registry);
  auto v278 = pybind11_weaver::CreateEntity<Entity_clang_tooling_stdlib_Symbol>(
      v274->AsScope(), registry);
  auto v279 = pybind11_weaver::CreateEntity<Entity_clang_tooling_traits>(
      v87->AsScope(), registry);
  auto v280 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_traits_internal>(
          v279->AsScope(), registry);
  auto v281 = pybind11_weaver::CreateEntity<Entity_transferCompileCommand>(
      v87->AsScope(), registry);
  auto v282 = pybind11_weaver::CreateEntity<Entity_validateEditRange>(
      v87->AsScope(), registry);
  auto v283 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_AllTUsToolExecutor>(
          v87->AsScope(), registry);
  auto v284 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ArgumentsAdjustingCompilations>(v87->AsScope(),
                                                           registry);
  auto v285 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_ExtractFunction>(
          v87->AsScope(), registry);
  auto v286 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_FindSymbolOccurrencesRefactoringRule>(v87->AsScope(),
                                                                 registry);
  auto v287 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_FrontendActionFactory>(
          v87->AsScope(), registry);
  auto v288 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_InMemoryToolResults>(
          v87->AsScope(), registry);
  auto v289 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_QualifiedRenameRule>(
          v87->AsScope(), registry);
  auto v290 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RefactoringActionRule>(
          v87->AsScope(), registry);
  auto v291 =
      pybind11_weaver::CreateEntity<Entity_clang_tooling_RenameOccurrences>(
          v87->AsScope(), registry);
  auto v292 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_SourceRangeSelectionRequirement>(v87->AsScope(),
                                                            registry);
  auto v293 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_StandaloneToolExecutor>(v87->AsScope(), registry);
  auto v294 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_ASTSelectionRequirement>(v87->AsScope(), registry);
  auto v295 = pybind11_weaver::CreateEntity<
      Entity_clang_tooling_CodeRangeASTSelectionRequirement>(v87->AsScope(),
                                                             registry);
  auto v296 = pybind11_weaver::CreateEntity<Entity_clang_transformer>(
      v0->AsScope(), registry);
  auto v297 = pybind11_weaver::CreateEntity<Entity_clang_transformer_ASTEdit>(
      v296->AsScope(), registry);
  auto v298 = pybind11_weaver::CreateEntity<Entity_clang_transformer_Edit>(
      v296->AsScope(), registry);
  auto v299 = pybind11_weaver::CreateEntity<Entity_clang_transformer_EditKind>(
      v296->AsScope(), registry);
  auto v300 =
      pybind11_weaver::CreateEntity<Entity_clang_transformer_IncludeFormat>(
          v296->AsScope(), registry);
  auto v301 =
      pybind11_weaver::CreateEntity<Entity_clang_transformer_RewriteRuleBase>(
          v296->AsScope(), registry);
  auto v302 = pybind11_weaver::CreateEntity<
      Entity_clang_transformer_RewriteRuleBase_Case>(v301->AsScope(), registry);
  auto v303 = pybind11_weaver::CreateEntity<
      Entity_clang_transformer_RewriteRuleWith6void9>(v296->AsScope(),
                                                      registry);
  auto v304 =
      pybind11_weaver::CreateEntity<Entity_access>(v296->AsScope(), registry);
  auto v305 =
      pybind11_weaver::CreateEntity<Entity_access1>(v296->AsScope(), registry);
  auto v306 = pybind11_weaver::CreateEntity<Entity_addInclude>(v296->AsScope(),
                                                               registry);
  auto v307 = pybind11_weaver::CreateEntity<Entity_addInclude2>(v296->AsScope(),
                                                                registry);
  auto v308 = pybind11_weaver::CreateEntity<Entity_addInclude1>(v296->AsScope(),
                                                                registry);
  auto v309 = pybind11_weaver::CreateEntity<Entity_addressOf>(v296->AsScope(),
                                                              registry);
  auto v310 =
      pybind11_weaver::CreateEntity<Entity_after>(v296->AsScope(), registry);
  auto v311 = pybind11_weaver::CreateEntity<Entity_applyFirst_void>(
      v296->AsScope(), registry);
  auto v312 =
      pybind11_weaver::CreateEntity<Entity_before>(v296->AsScope(), registry);
  auto v313 =
      pybind11_weaver::CreateEntity<Entity_between>(v296->AsScope(), registry);
  auto v314 =
      pybind11_weaver::CreateEntity<Entity_callArgs>(v296->AsScope(), registry);
  auto v315 = pybind11_weaver::CreateEntity<Entity_catVector>(v296->AsScope(),
                                                              registry);
  auto v316 =
      pybind11_weaver::CreateEntity<Entity_change>(v296->AsScope(), registry);
  auto v317 =
      pybind11_weaver::CreateEntity<Entity_change1>(v296->AsScope(), registry);
  auto v318 =
      pybind11_weaver::CreateEntity<Entity_changeTo>(v296->AsScope(), registry);
  auto v319 = pybind11_weaver::CreateEntity<Entity_changeTo1>(v296->AsScope(),
                                                              registry);
  auto v320 = pybind11_weaver::CreateEntity<Entity_charRange>(v296->AsScope(),
                                                              registry);
  auto v321 =
      pybind11_weaver::CreateEntity<Entity_dPrint>(v296->AsScope(), registry);
  auto v322 =
      pybind11_weaver::CreateEntity<Entity_deref>(v296->AsScope(), registry);
  auto v323 =
      pybind11_weaver::CreateEntity<Entity_describe>(v296->AsScope(), registry);
  auto v324 = pybind11_weaver::CreateEntity<Entity_clang_transformer_detail>(
      v296->AsScope(), registry);
  auto v325 = pybind11_weaver::CreateEntity<Entity_buildMatcher>(
      v324->AsScope(), registry);
  auto v326 = pybind11_weaver::CreateEntity<Entity_buildMatchers>(
      v324->AsScope(), registry);
  auto v327 = pybind11_weaver::CreateEntity<Entity_findSelectedCase>(
      v324->AsScope(), registry);
  auto v328 = pybind11_weaver::CreateEntity<Entity_getRuleMatchLoc>(
      v324->AsScope(), registry);
  auto v329 = pybind11_weaver::CreateEntity<Entity_injectEdits>(v324->AsScope(),
                                                                registry);
  auto v330 = pybind11_weaver::CreateEntity<Entity_injectEdits1>(
      v324->AsScope(), registry);
  auto v331 = pybind11_weaver::CreateEntity<Entity_makeEditGenerator2>(
      v324->AsScope(), registry);
  auto v332 = pybind11_weaver::CreateEntity<Entity_makeEditGenerator>(
      v324->AsScope(), registry);
  auto v333 = pybind11_weaver::CreateEntity<Entity_makeEditGenerator1>(
      v324->AsScope(), registry);
  auto v334 = pybind11_weaver::CreateEntity<Entity_makeRule1>(v324->AsScope(),
                                                              registry);
  auto v335 = pybind11_weaver::CreateEntity<Entity_makeStencil1>(
      v324->AsScope(), registry);
  auto v336 = pybind11_weaver::CreateEntity<Entity_makeStencil2>(
      v324->AsScope(), registry);
  auto v337 = pybind11_weaver::CreateEntity<Entity_makeStencil>(v324->AsScope(),
                                                                registry);
  auto v338 = pybind11_weaver::CreateEntity<Entity_rewriteDescendants1>(
      v324->AsScope(), registry);
  auto v339 = pybind11_weaver::CreateEntity<Entity_rewriteDescendants4>(
      v324->AsScope(), registry);
  auto v340 = pybind11_weaver::CreateEntity<Entity_rewriteDescendants2>(
      v324->AsScope(), registry);
  auto v341 = pybind11_weaver::CreateEntity<Entity_rewriteDescendants3>(
      v324->AsScope(), registry);
  auto v342 =
      pybind11_weaver::CreateEntity<Entity_edit>(v296->AsScope(), registry);
  auto v343 =
      pybind11_weaver::CreateEntity<Entity_editList>(v296->AsScope(), registry);
  auto v344 = pybind11_weaver::CreateEntity<Entity_elseBranch>(v296->AsScope(),
                                                               registry);
  auto v345 =
      pybind11_weaver::CreateEntity<Entity_enclose>(v296->AsScope(), registry);
  auto v346 = pybind11_weaver::CreateEntity<Entity_encloseNodes>(
      v296->AsScope(), registry);
  auto v347 = pybind11_weaver::CreateEntity<Entity_expansion>(v296->AsScope(),
                                                              registry);
  auto v348 = pybind11_weaver::CreateEntity<Entity_expression>(v296->AsScope(),
                                                               registry);
  auto v349 = pybind11_weaver::CreateEntity<Entity_flattenVector>(
      v296->AsScope(), registry);
  auto v350 =
      pybind11_weaver::CreateEntity<Entity_ifBound>(v296->AsScope(), registry);
  auto v351 =
      pybind11_weaver::CreateEntity<Entity_ifBound1>(v296->AsScope(), registry);
  auto v352 =
      pybind11_weaver::CreateEntity<Entity_ifBound3>(v296->AsScope(), registry);
  auto v353 =
      pybind11_weaver::CreateEntity<Entity_ifBound2>(v296->AsScope(), registry);
  auto v354 = pybind11_weaver::CreateEntity<Entity_initListElements>(
      v296->AsScope(), registry);
  auto v355 = pybind11_weaver::CreateEntity<Entity_insertAfter>(v296->AsScope(),
                                                                registry);
  auto v356 = pybind11_weaver::CreateEntity<Entity_insertBefore>(
      v296->AsScope(), registry);
  auto v357 =
      pybind11_weaver::CreateEntity<Entity_makeRule>(v296->AsScope(), registry);
  auto v358 = pybind11_weaver::CreateEntity<Entity_maybeAddressOf>(
      v296->AsScope(), registry);
  auto v359 = pybind11_weaver::CreateEntity<Entity_maybeDeref>(v296->AsScope(),
                                                               registry);
  auto v360 =
      pybind11_weaver::CreateEntity<Entity_member>(v296->AsScope(), registry);
  auto v361 =
      pybind11_weaver::CreateEntity<Entity_name>(v296->AsScope(), registry);
  auto v362 =
      pybind11_weaver::CreateEntity<Entity_noEdits>(v296->AsScope(), registry);
  auto v363 =
      pybind11_weaver::CreateEntity<Entity_node>(v296->AsScope(), registry);
  auto v364 =
      pybind11_weaver::CreateEntity<Entity_noopEdit>(v296->AsScope(), registry);
  auto v365 = pybind11_weaver::CreateEntity<Entity_notBoundError>(
      v296->AsScope(), registry);
  auto v366 =
      pybind11_weaver::CreateEntity<Entity_note>(v296->AsScope(), registry);
  auto v367 = pybind11_weaver::CreateEntity<Entity_parseRangeSelector>(
      v296->AsScope(), registry);
  auto v368 =
      pybind11_weaver::CreateEntity<Entity_range>(v296->AsScope(), registry);
  auto v369 =
      pybind11_weaver::CreateEntity<Entity_range1>(v296->AsScope(), registry);
  auto v370 =
      pybind11_weaver::CreateEntity<Entity_remove>(v296->AsScope(), registry);
  auto v371 = pybind11_weaver::CreateEntity<Entity_rewriteDescendants>(
      v296->AsScope(), registry);
  auto v372 =
      pybind11_weaver::CreateEntity<Entity_run>(v296->AsScope(), registry);
  auto v373 = pybind11_weaver::CreateEntity<Entity_selectBound>(v296->AsScope(),
                                                                registry);
  auto v374 =
      pybind11_weaver::CreateEntity<Entity_shrinkTo>(v296->AsScope(), registry);
  auto v375 = pybind11_weaver::CreateEntity<Entity_statement>(v296->AsScope(),
                                                              registry);
  auto v376 = pybind11_weaver::CreateEntity<Entity_statements>(v296->AsScope(),
                                                               registry);
  auto v377 =
      pybind11_weaver::CreateEntity<Entity_llvm>(EntityScope(m), registry);
  auto v378 = pybind11_weaver::CreateEntity<
      Entity_llvm_DenseMapInfo6clang_tooling_dependencies_ModuleID9>(
      v377->AsScope(), registry);
  auto v379 = pybind11_weaver::CreateEntity<
      Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Header9>(v377->AsScope(),
                                                             registry);
  auto v380 = pybind11_weaver::CreateEntity<
      Entity_llvm_DenseMapInfo6clang_tooling_stdlib_Symbol9>(v377->AsScope(),
                                                             registry);
  auto v381 = pybind11_weaver::CreateEntity<Entity_llvm_yaml>(v377->AsScope(),
                                                              registry);
  auto v382 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9>(v381->AsScope(),
                                                                registry);
  auto v383 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_Diagnostic9_NormalizedDiagnostic>(
      v382->AsScope(), registry);
  auto v384 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_DiagnosticMessage9>(
      v381->AsScope(), registry);
  auto v385 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_FileByteRange9>(
      v381->AsScope(), registry);
  auto v386 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_IncludeStyle_IncludeCategory9>(
      v381->AsScope(), registry);
  auto v387 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9>(
      v381->AsScope(), registry);
  auto v388 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_Replacement9_NormalizedReplacement>(
      v387->AsScope(), registry);
  auto v389 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitDiagnostics9>(
      v381->AsScope(), registry);
  auto v390 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_MappingTraits6clang_tooling_TranslationUnitReplacements9>(
      v381->AsScope(), registry);
  auto v391 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_Diagnostic_Level9>(
      v381->AsScope(), registry);
  auto v392 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_ScalarEnumerationTraits6clang_tooling_IncludeStyle_IncludeBlocksStyle9>(
      v381->AsScope(), registry);
  auto v393 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Diagnostic9>(
      v381->AsScope(), registry);
  auto v394 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_SequenceElementTraits6clang_tooling_DiagnosticMessage9>(
      v381->AsScope(), registry);
  auto v395 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_SequenceElementTraits6clang_tooling_FileByteRange9>(
      v381->AsScope(), registry);
  auto v396 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_SequenceElementTraits6clang_tooling_IncludeStyle_IncludeCategory9>(
      v381->AsScope(), registry);
  auto v397 = pybind11_weaver::CreateEntity<
      Entity_llvm_yaml_SequenceElementTraits6clang_tooling_Replacement9>(
      v381->AsScope(), registry);

  auto update_fn = [=]() {
    v0->Update();
    v1->Update();
    v2->Update();
    v3->Update();
    v4->Update();
    v5->Update();
    v6->Update();
    v7->Update();
    v8->Update();
    v9->Update();
    v10->Update();
    v11->Update();
    v12->Update();
    v13->Update();
    v14->Update();
    v15->Update();
    v16->Update();
    v17->Update();
    v18->Update();
    v19->Update();
    v20->Update();
    v21->Update();
    v22->Update();
    v23->Update();
    v24->Update();
    v25->Update();
    v26->Update();
    v27->Update();
    v28->Update();
    v29->Update();
    v30->Update();
    v31->Update();
    v32->Update();
    v33->Update();
    v34->Update();
    v35->Update();
    v36->Update();
    v37->Update();
    v38->Update();
    v39->Update();
    v40->Update();
    v41->Update();
    v42->Update();
    v43->Update();
    v44->Update();
    v45->Update();
    v46->Update();
    v47->Update();
    v48->Update();
    v49->Update();
    v50->Update();
    v51->Update();
    v52->Update();
    v53->Update();
    v54->Update();
    v55->Update();
    v56->Update();
    v57->Update();
    v58->Update();
    v59->Update();
    v60->Update();
    v61->Update();
    v62->Update();
    v63->Update();
    v64->Update();
    v65->Update();
    v66->Update();
    v67->Update();
    v68->Update();
    v69->Update();
    v70->Update();
    v71->Update();
    v72->Update();
    v73->Update();
    v74->Update();
    v75->Update();
    v76->Update();
    v77->Update();
    v78->Update();
    v79->Update();
    v80->Update();
    v81->Update();
    v82->Update();
    v83->Update();
    v84->Update();
    v85->Update();
    v86->Update();
    v87->Update();
    v88->Update();
    v89->Update();
    v90->Update();
    v91->Update();
    v92->Update();
    v93->Update();
    v94->Update();
    v95->Update();
    v96->Update();
    v97->Update();
    v98->Update();
    v99->Update();
    v100->Update();
    v101->Update();
    v102->Update();
    v103->Update();
    v104->Update();
    v105->Update();
    v106->Update();
    v107->Update();
    v108->Update();
    v109->Update();
    v110->Update();
    v111->Update();
    v112->Update();
    v113->Update();
    v114->Update();
    v115->Update();
    v116->Update();
    v117->Update();
    v118->Update();
    v119->Update();
    v120->Update();
    v121->Update();
    v122->Update();
    v123->Update();
    v124->Update();
    v125->Update();
    v126->Update();
    v127->Update();
    v128->Update();
    v129->Update();
    v130->Update();
    v131->Update();
    v132->Update();
    v133->Update();
    v134->Update();
    v135->Update();
    v136->Update();
    v137->Update();
    v138->Update();
    v139->Update();
    v140->Update();
    v141->Update();
    v142->Update();
    v143->Update();
    v144->Update();
    v145->Update();
    v146->Update();
    v147->Update();
    v148->Update();
    v149->Update();
    v150->Update();
    v151->Update();
    v152->Update();
    v153->Update();
    v154->Update();
    v155->Update();
    v156->Update();
    v157->Update();
    v158->Update();
    v159->Update();
    v160->Update();
    v161->Update();
    v162->Update();
    v163->Update();
    v164->Update();
    v165->Update();
    v166->Update();
    v167->Update();
    v168->Update();
    v169->Update();
    v170->Update();
    v171->Update();
    v172->Update();
    v173->Update();
    v174->Update();
    v175->Update();
    v176->Update();
    v177->Update();
    v178->Update();
    v179->Update();
    v180->Update();
    v181->Update();
    v182->Update();
    v183->Update();
    v184->Update();
    v185->Update();
    v186->Update();
    v187->Update();
    v188->Update();
    v189->Update();
    v190->Update();
    v191->Update();
    v192->Update();
    v193->Update();
    v194->Update();
    v195->Update();
    v196->Update();
    v197->Update();
    v198->Update();
    v199->Update();
    v200->Update();
    v201->Update();
    v202->Update();
    v203->Update();
    v204->Update();
    v205->Update();
    v206->Update();
    v207->Update();
    v208->Update();
    v209->Update();
    v210->Update();
    v211->Update();
    v212->Update();
    v213->Update();
    v214->Update();
    v215->Update();
    v216->Update();
    v217->Update();
    v218->Update();
    v219->Update();
    v220->Update();
    v221->Update();
    v222->Update();
    v223->Update();
    v224->Update();
    v225->Update();
    v226->Update();
    v227->Update();
    v228->Update();
    v229->Update();
    v230->Update();
    v231->Update();
    v232->Update();
    v233->Update();
    v234->Update();
    v235->Update();
    v236->Update();
    v237->Update();
    v238->Update();
    v239->Update();
    v240->Update();
    v241->Update();
    v242->Update();
    v243->Update();
    v244->Update();
    v245->Update();
    v246->Update();
    v247->Update();
    v248->Update();
    v249->Update();
    v250->Update();
    v251->Update();
    v252->Update();
    v253->Update();
    v254->Update();
    v255->Update();
    v256->Update();
    v257->Update();
    v258->Update();
    v259->Update();
    v260->Update();
    v261->Update();
    v262->Update();
    v263->Update();
    v264->Update();
    v265->Update();
    v266->Update();
    v267->Update();
    v268->Update();
    v269->Update();
    v270->Update();
    v271->Update();
    v272->Update();
    v273->Update();
    v274->Update();
    v275->Update();
    v276->Update();
    v277->Update();
    v278->Update();
    v279->Update();
    v280->Update();
    v281->Update();
    v282->Update();
    v283->Update();
    v284->Update();
    v285->Update();
    v286->Update();
    v287->Update();
    v288->Update();
    v289->Update();
    v290->Update();
    v291->Update();
    v292->Update();
    v293->Update();
    v294->Update();
    v295->Update();
    v296->Update();
    v297->Update();
    v298->Update();
    v299->Update();
    v300->Update();
    v301->Update();
    v302->Update();
    v303->Update();
    v304->Update();
    v305->Update();
    v306->Update();
    v307->Update();
    v308->Update();
    v309->Update();
    v310->Update();
    v311->Update();
    v312->Update();
    v313->Update();
    v314->Update();
    v315->Update();
    v316->Update();
    v317->Update();
    v318->Update();
    v319->Update();
    v320->Update();
    v321->Update();
    v322->Update();
    v323->Update();
    v324->Update();
    v325->Update();
    v326->Update();
    v327->Update();
    v328->Update();
    v329->Update();
    v330->Update();
    v331->Update();
    v332->Update();
    v333->Update();
    v334->Update();
    v335->Update();
    v336->Update();
    v337->Update();
    v338->Update();
    v339->Update();
    v340->Update();
    v341->Update();
    v342->Update();
    v343->Update();
    v344->Update();
    v345->Update();
    v346->Update();
    v347->Update();
    v348->Update();
    v349->Update();
    v350->Update();
    v351->Update();
    v352->Update();
    v353->Update();
    v354->Update();
    v355->Update();
    v356->Update();
    v357->Update();
    v358->Update();
    v359->Update();
    v360->Update();
    v361->Update();
    v362->Update();
    v363->Update();
    v364->Update();
    v365->Update();
    v366->Update();
    v367->Update();
    v368->Update();
    v369->Update();
    v370->Update();
    v371->Update();
    v372->Update();
    v373->Update();
    v374->Update();
    v375->Update();
    v376->Update();
    v377->Update();
    v378->Update();
    v379->Update();
    v380->Update();
    v381->Update();
    v382->Update();
    v383->Update();
    v384->Update();
    v385->Update();
    v386->Update();
    v387->Update();
    v388->Update();
    v389->Update();
    v390->Update();
    v391->Update();
    v392->Update();
    v393->Update();
    v394->Update();
    v395->Update();
    v396->Update();
    v397->Update();
  };
  return {update_fn};
}

} // anonymous namespace
